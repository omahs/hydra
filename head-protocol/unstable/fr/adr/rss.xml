<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Hydra: Head Protocol Blog</title>
        <link>https://input-output-hk.github.io/head-protocol/unstable/fr/adr</link>
        <description>Hydra: Head Protocol Blog</description>
        <lastBuildDate>Sat, 05 Jun 2021 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>fr</language>
        <item>
            <title><![CDATA[1. Record Architecture Decisions
]]></title>
            <link>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/1</link>
            <guid>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/1</guid>
            <pubDate>Sat, 05 Jun 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[Status]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="status">Status<a href="#status" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>Accepted</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="context">Context<a href="#context" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>We are in search for a means to describe our technical architecture.</p><p>We are a small team working in a very lean and agile way (XP), so we naturally prefer also light-weight documentation methods which also accomodate change easily.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="decision">Decision<a href="#decision" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li>We will use <em>Architecture Decision Records</em>, as described by Michael Nygard in this <a href="http://thinkrelevance.com/blog/2011/11/15/documenting-architecture-decisions" target="_blank" rel="noopener noreferrer">article</a>.</li><li>We will follow the convention of storing those ADRs as Markdown formatted documents stored under <code>docs/adr</code> directory, as exemplified in Nat Pryce's <a href="https://github.com/npryce/adr-tools" target="_blank" rel="noopener noreferrer">adr-tools</a>. This does not imply we will be using <code>adr-tools</code> itself.</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="consequences">Consequences<a href="#consequences" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>See Michael Nygard's article, linked above.</p>]]></content:encoded>
            <category>Accepted</category>
        </item>
        <item>
            <title><![CDATA[2. Reactive Core
]]></title>
            <link>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/2</link>
            <guid>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/2</guid>
            <pubDate>Sun, 06 Jun 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[Status]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="status">Status<a href="#status" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>Accepted</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="context">Context<a href="#context" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>We are looking for a way of expressing the Hydra Head protocol logic in a Hydra node.</p><p>The Hydra Head protocol is defined as a <em>State machine</em> in the paper, whose transitions are inputs that come from different sources which can emit outputs to other instances of the state machine or the mainchain. See the <a href="https://iohk.io/en/research/library/papers/hydrafast-isomorphic-state-channels/" target="_blank" rel="noopener noreferrer">FC2021</a> paper for details</p><p>It should also be easy to review / feed-back to researchers.</p><p>We are familiar with React's <a href="https://react-redux.js.org/" target="_blank" rel="noopener noreferrer">redux</a> way of structuring applications, which in turn is inspired by <a href="https://guide.elm-lang.org/architecture/" target="_blank" rel="noopener noreferrer">The Elm Architecture</a> which itself is a simplification of <a href="https://en.wikipedia.org/wiki/Functional_reactive_programming" target="_blank" rel="noopener noreferrer">Functional Reactive Programming</a> principles.</p><p>We have experienced benefits with <em>Event Sourcing</em> in the domain of persistence in the past</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="decision">Decision<a href="#decision" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>Implements the Hydra Head core logic as a <em>loop</em> that:</p><ol><li>Consumes <em>input events</em> from an event <em>queue</em>,</li><li>Applies each <em>event</em> to the current <em>state</em> yielding potentially an <em>updated state</em> and a sequence of <em>effects</em>,</li><li>Execute all <em>effects</em>.</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="consequences">Consequences<a href="#consequences" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>The internal state is only ever changed through <em>Events</em>.</p><p>The core state machine <em>transition</em> function <em>is pure</em> and reviewing it requires minimal Haskell knowledge.</p><p>Side-effects are all handled at the level of the <code>Node</code>.</p>]]></content:encoded>
            <category>Accepted</category>
        </item>
        <item>
            <title><![CDATA[3. Asynchronous Duplex Client API]]></title>
            <link>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/3</link>
            <guid>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/3</guid>
            <pubDate>Mon, 07 Jun 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[Status]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="status">Status<a href="#status" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>Accepted</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="context">Context<a href="#context" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>The <a href="/head-protocol/unstable/fr/adr/2"><em>reactive</em> nature of the Hydra node</a> means that
clients produce a <em>stream</em> of <em>inputs</em> to a node which in turns issues a stream
of <em>outputs</em> representing the outcome of previous inputs or resulting from
interaction with peers in the network.</p><p>For example, a client may send a <em>command</em> as <em>input</em>, upon which the node might
do something. When that something is finished, a <em>output</em> does indicate that.
However, there might also be an <em>output</em> emitted to the client when another peer
interacted with "our" node.</p><p>Queries, messages by clients which do only fetch information from the node, are
not in scope of this ADR.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="decision">Decision<a href="#decision" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li>We use a single, full-duplex communication channel per client connected to a Hydra node</li><li>This is implemented using a simple <a href="https://datatracker.ietf.org/doc/html/rfc6455" target="_blank" rel="noopener noreferrer">Websocket</a> with messages corresponding to <code>Input</code>s and <code>Output</code>s.</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="consequences">Consequences<a href="#consequences" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li>Clients needing a synchronous API need to implement it on top</li><li>Clients can receive <em>outputs</em> decorrelated from any <em>inputs</em> and at any time</li></ul>]]></content:encoded>
            <category>Accepted</category>
        </item>
        <item>
            <title><![CDATA[4. Use Handle to model Effects
]]></title>
            <link>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/4</link>
            <guid>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/4</guid>
            <pubDate>Tue, 08 Jun 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[Status]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="status">Status<a href="#status" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>Accepted</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="context">Context<a href="#context" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>Given we are structuring Hydra node as a <a href="/head-protocol/unstable/fr/adr/2">reactive core</a> we need a way to ensure a strict separation of pure and impure (or effectful) code.</p><p>We want to be able to test those impure/effectful parts of the code. This requires a means for exchanging the actual implementation for e.g. the function to send messages over a network.</p><p>Also we want the ability to swap implementations not only for testing, but also be able
to accommodate different usage scenarios, e.g. use a different middleware
depending on peer configuration.</p><p>In Haskell there are various common <em>patterns</em> to model effects:</p><ul><li><a href="http://okmij.org/ftp/tagless-final/index.html" target="_blank" rel="noopener noreferrer">Tagless final encoding</a> also known as <em>MTL-style</em> although using typeclasses to implement is <a href="https://www.foxhound.systems/blog/final-tagless/" target="_blank" rel="noopener noreferrer">not necessary</a>, whereby Effect(s) are expressed as typeclass(es) which are propagated as constraints</li><li><a href="https://reasonablypolymorphic.com/blog/freer-monads/" target="_blank" rel="noopener noreferrer">Free monads</a>, or any variant thereof like Eff, freer, extensible-effects, whereby effect(s) are expressed as ADTs which are <em>interpreted</em> in the context of an <em>Effect stack</em></li><li><a href="https://jaspervdj.be/posts/2018-03-08-handle-pattern.html" target="_blank" rel="noopener noreferrer">Handle</a> pattern also known as <em>record-of-functions</em> whereby effects are grouped together in a datatype with a single record constructor</li></ul><p>(These tradeoffs also appear in other functional languages like
<a href="https://medium.com/@dogwith1eye/prefer-records-of-functions-to-interfaces-d6413af4d2c3" target="_blank" rel="noopener noreferrer">F#</a>)</p><p>There is not one most favored solution though and we all have various
experiences with these techniques.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="decision">Decision<a href="#decision" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>Effectful components of the Hydra node (our code) will be defined using the <em>Handle pattern</em>.</p><p>There might be other techniques in use because of libraries used etc.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="consequences">Consequences<a href="#consequences" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>For example, the network component is defined as:</p><div class="language-hs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-hs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">newtype</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">Network</span><span class="token plain"> </span><span class="token hvariable">m</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">Network</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"> </span><span class="token hvariable">broadcast</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">::</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">MonadThrow</span><span class="token plain"> </span><span class="token hvariable">m</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=&gt;</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">HydraMessage</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain"> </span><span class="token hvariable">m</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copier le code" title="Copier" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>There might be multiple <code>createNetwork :: m (Network m)</code> functions</p>]]></content:encoded>
            <category>Accepted</category>
        </item>
        <item>
            <title><![CDATA[5. Use io-classes
]]></title>
            <link>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/5</link>
            <guid>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/5</guid>
            <pubDate>Wed, 09 Jun 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[Status]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="status">Status<a href="#status" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>Accepted</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="context">Context<a href="#context" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>Although we try to contain the use of IO at the outskirt of the Hydra node using <a href="/head-protocol/unstable/fr/adr/4">Handle pattern</a> and <a href="/head-protocol/unstable/fr/adr/2">Reactive core</a>, low-level effects are still needed in various places, notably to define concurrently executing actions, and thus need to be tested</p><p>Testing asynchronous and concurrent code is notoriously painful</p><p>The ouroboros consensus test suite and <a href="https://github.com/input-output-hk/hydra-sim" target="_blank" rel="noopener noreferrer">hydra-sim</a> simulation have demonstrated the effectiveness of abstracting concurrent primitives through the use of typeclasses (MTL-style pattern) and being able to run these as pure code, harvesting and analysing produced execution traces.</p><p>There are other such libraries, e.g. <a href="https://hackage.haskell.org/package/concurrency" target="_blank" rel="noopener noreferrer">concurrency</a> and <a href="https://hackage.haskell.org/package/dejafu" target="_blank" rel="noopener noreferrer">dejafu</a>, as well as the venerable <a href="https://hackage.haskell.org/package/exceptions" target="_blank" rel="noopener noreferrer">exceptions</a> (for abstracting exception throwing).</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="decision">Decision<a href="#decision" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>For all IO effects covered by the library, use functions from typeclasses exposed by <a href="https://github.com/input-output-hk/ouroboros-network/tree/e338f2cf8e1078fbda9555dd2b169c6737ef6774/io-classes" target="_blank" rel="noopener noreferrer">io-classes</a>. As of this writing, this covers:</p><ul><li>All STM operations through <code>MonadSTM</code></li><li>Time and timers through <code>MonadTime</code> and <code>MonadTimer</code></li><li>Concurrency through <code>MonadAsync</code>, <code>MonadFork</code></li><li>Exceptions through <code>MonadThrow</code>, <code>MonadCatch</code> and <code>MonadMask</code></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="consequences">Consequences<a href="#consequences" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>We can use <code>io-sim</code> to evaluate IO-ish functions easily</p><p>Instantiation to concrete IO is pushed at the outermost layer, eg. in the <code>Main</code> or tests.</p><p>As some of these functions and typeclasses clash with the
<a href="https://github.com/input-output-hk/cardano-prelude" target="_blank" rel="noopener noreferrer">cardano-prelude</a> we might
want to define a custom prelude (candidate for another ADR)</p>]]></content:encoded>
            <category>Accepted</category>
        </item>
        <item>
            <title><![CDATA[6. Network Broadcasts all messages
]]></title>
            <link>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/6</link>
            <guid>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/6</guid>
            <pubDate>Thu, 10 Jun 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[Status]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="status">Status<a href="#status" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>Accepted</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="context">Context<a href="#context" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>The simplified Head protocol in the <a href="https://iohk.io/en/research/library/papers/hydrafast-isomorphic-state-channels/" target="_blank" rel="noopener noreferrer">Hydra
paper</a>
requires <em>unicast</em> and <em>multicast</em> messaging between participants. However, this
can be simplified to only <em>multicast</em> by also sending <code>AckTx</code> messages to all
participants and removing the necessity for <code>ConfTx</code>.</p><p>There is already a battle-tested implementation for <em>broadcasting</em> messages over
networks with any kind of topology (mesh), namely the
<a href="https://github.com/input-output-hk/ouroboros-network/tree/master/ouroboros-network/src/Ouroboros/Network/TxSubmission" target="_blank" rel="noopener noreferrer">TxSubmission</a>
protocol of <code>ouroroboros-network</code>.</p><p>If the network connects only to interested peers, <em>broadcast</em> is essentially the
<em>multicast</em> required by the protocol. If this is not the case, some addressing
scheme is required and <em>broadcast</em> would be a waste of resources.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="decision">Decision<a href="#decision" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li>All messages emitted by a Hydra node through the Network component are <em>broadcasted</em> to <em>all</em> nodes in the network</li><li>This implies the emitter shall itself receive the message</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="consequences">Consequences<a href="#consequences" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li>The network layer is responsible for ensuring sent messages effectively
reaches all nodes in the network. How this is achieved is left as an
implementation detail, i.e. whether it uses relaying or not.</li><li>We need to make sure all Head participants are connected to the same network.</li></ul>]]></content:encoded>
            <category>Accepted</category>
        </item>
        <item>
            <title><![CDATA[7. Use with-pattern based component interfaces
]]></title>
            <link>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/7</link>
            <guid>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/7</guid>
            <pubDate>Fri, 11 Jun 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[Status]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="status">Status<a href="#status" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>Accepted</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="context">Context<a href="#context" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>The <em>with pattern</em> or <em>bracket pattern</em> is a functional programming idiom, a
particular instance of <em>Continuation-Passing Style</em>, whereby one component that
controls some resource that is consumed by another component of the system, is
created via a function that takes as argument a function consuming the resource,
instead of returning it. This pattern allows safe reclaiming of resources when
the "wrapped" action terminates, whether normally or unexpectedly.</p><p>TODO "Tying the knot"</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="decision">Decision<a href="#decision" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>We use this pattern to provide interfaces to all <em>active components</em>, which
exchange messages with other components of the system. A prototypical signature
of such a component could be:</p><div class="language-hs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-hs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">type</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">Component</span><span class="token plain"> </span><span class="token hvariable">m</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token hvariable">inmsg</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain"> </span><span class="token hvariable">m</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">type</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">Callback</span><span class="token plain"> </span><span class="token hvariable">m</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token hvariable">outmsg</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain"> </span><span class="token hvariable">m</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token hvariable">withXXX</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">::</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">Callback</span><span class="token plain"> </span><span class="token hvariable">m</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token constant" style="color:#36acaa">Component</span><span class="token plain"> </span><span class="token hvariable">m</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain"> </span><span class="token hvariable">m</span><span class="token plain"> </span><span class="token hvariable">a</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain"> </span><span class="token hvariable">m</span><span class="token plain"> </span><span class="token hvariable">a</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copier le code" title="Copier" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Note that <code>withXXX</code> can also allocate resources in order to provide <code>Component</code>
or use the <code>Callback</code>, e.g. fork threads which invoke <code>Callback</code>, but also make
sure they are cleaned up.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="consequences">Consequences<a href="#consequences" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>Components can be layered on top of another to provide additional behavior given the same interface. This also similar to "decorating" in the object-orientation world.</p><p>If the <code>Component</code> is agnostic about the messages it consumes/produces, it can be defined as a <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-Functor-Contravariant.html" target="_blank" rel="noopener noreferrer"><code>Contravariant</code> functor</a> and the <code>Callback</code> part as a (covariant) <code>Functor</code>. This makes it possible to use <code>map</code> and <code>contramap</code> operations to transform messages.</p>]]></content:encoded>
            <category>Accepted</category>
        </item>
        <item>
            <title><![CDATA[8. Custom Prelude
]]></title>
            <link>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/8</link>
            <guid>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/8</guid>
            <pubDate>Fri, 18 Jun 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[Status]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="status">Status<a href="#status" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>Accepted</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="context">Context<a href="#context" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>In a Haskell project, we often get to use and re-use the same libraries and functions. Haskell comes with a default <code>Prelude</code> package with the <code>base</code> library, which provides a good and sensible starting point. However, the base <code>Prelude</code> also comes with a few quirks:</p><ul><li>Many commonly used functions or constructors are not exported by default (e.g. <code>bracket</code>, <code>foldM</code>, <code>first</code>, <code>lift</code>, <code>forM</code>, <code>when</code>, <code>SomeException</code>, <code>Set</code>, <code>&amp;</code> ...etc).</li><li>Many functions in the base Prelude are partial, like <code>head</code> or <code>read</code>. </li><li>Many functions simply happens in plain <code>IO</code>, whereas applications usually try to push IO to the boundary as much as possible (for example, using mtl-style class constraints).</li><li>The interface for I/O operations in the base Prelude is <code>String</code>, which comes with quite major performance hit and often forces to convert back and forth to <code>Text</code> or <code>ByteString</code> equivalents.</li></ul><p>All-in-all, while it <em>does the job</em>, the base <code>Prelude</code> may not necessarily be the most <em>convenient</em> prelude for an active project development. </p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="decision">Decision<a href="#decision" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>We'll use a custom prelude to help us get more productive and more importantly, to reduce the daily friction of our interactions with the base prelude. While <a href="https://hackage.haskell.org/package/relude" target="_blank" rel="noopener noreferrer"><code>relude</code></a> makes for a good candidate, we still chose to re-wrap it in a custom <code>Hydra.Prelude</code> module to grant us the ability to add or remove a few things specifics to Hydra and Cardano in general. In particular, we will hide from <code>relude</code> all the re-exports of the <a href="https://hackage.haskell.org/package/stm" target="_blank" rel="noopener noreferrer"><code>stm</code></a> library in favor of <a href="https://github.com/input-output-hk/ouroboros-network/tree/e338f2cf8e1078fbda9555dd2b169c6737ef6774/io-classes" target="_blank" rel="noopener noreferrer"><code>io-classes</code></a> which we already use pervasively and which provides (among other things) most of the same capabilities.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="consequences">Consequences<a href="#consequences" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li>Remove uses of 'cardano-prelude' in favor of a new 'hydra-prelude' module.</li><li>Cleaning up of imports from existing file modules.</li><li>Happier feeling day after day from using a developer-friendly prelude.</li><li>Stop loosing time in often re-importing the same functions over and over. </li><li>Have an explicit point for discouraging / blessing usage of one or the other function, as well as documenting such decisions</li></ul>]]></content:encoded>
            <category>Accepted</category>
        </item>
        <item>
            <title><![CDATA[9. Simplify Logging
]]></title>
            <link>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/9</link>
            <guid>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/9</guid>
            <pubDate>Thu, 19 Aug 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[Status]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="status">Status<a href="#status" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>Proposed</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="context">Context<a href="#context" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li>Logs are critical to provide <em>observability</em> to Hydra nodes' operators</li><li>Providing the needed components and tools to be able to configure logging and monitoring to each operator's liking should not be the responibility of the Hydra node, and requires complex machinery that will need to be maintained and evolved</li><li>When a problem occurs in production, if the process is not verbose enough it can be very hard to analyse the problem<ul><li>Enabling dynamic changes of verbosity in logs is both complex to implement and comes too late</li><li>Deciding in the code on what's the right "severity" for a log entry leads to dropping important information on <em>how</em> some error occured</li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="decision">Decision<a href="#decision" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p><em>Therefore</em></p><p>Hydra node provides a very simplified logging mechanism whereby:</p><ul><li>All logs are emitted as JSON-encoded structures providing some metadata (timestamp, threadId) around well-defined data</li><li>Each <em>log entry</em> is written to the <code>hydra-node</code> process' <em>stdout</em> port, one line per entry</li><li>The definition of the logged items is considered to be part of the public AγPI of the Hydra node</li></ul><p><strong>Note</strong>: Proper redaction of sensitive information contained in log entries should still be handled in the code.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="consequences">Consequences<a href="#consequences" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li>The schema of the logged items should be properly documented in a JSON schema, just like we do for client side API</li><li>It is the responsibility of the node operator to consume the logs and process them</li></ul>]]></content:encoded>
            <category>Accepted</category>
        </item>
        <item>
            <title><![CDATA[10. Use Direct Connection to `cardano-node`
]]></title>
            <link>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/10</link>
            <guid>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/10</guid>
            <pubDate>Sat, 23 Oct 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[Status]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="status">Status<a href="#status" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>Accepted</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="context">Context<a href="#context" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li>On-Chain Validation is a critical part of the Hydra protocol, it requires both the ability to <em>submit</em> transactions to the <em>Layer 1</em> chain advancing the state of a Head, and <em>observing</em> those transactions as the <a href="https://github.com/input-output-hk/plutus" target="_blank" rel="noopener noreferrer">Plutus</a> contracts are validated</li><li>The <a href="https://github.com/input-output-hk/plutus-apps" target="_blank" rel="noopener noreferrer">Plutus Application Framework</a> is expected to provide the necessary machinery to allow "Smart Contracts" applications to interact with the chain but it's still under active development and not ready for deployment on-chain</li><li>We want to gather feedback as early as possible and deliver a fully functional Hydra Head node for early adopters to test on a "real" chain (testnet)</li><li>Our experiment connecting directly to a Cardano node has been conclusive. We can:<ul><li>Connect to a node using local protocols,</li><li>Build and submit Head transactions triggering smart contracts validation, and</li><li>Observe transactions using chain-sync protocol.</li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="decision">Decision<a href="#decision" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p><em>Therefore</em></p><p>For the time being, until <em>Plutus Application Framework</em> is released, we will implement on-chain interaction of Hydra nodes <em>directly</em>, connecting to a Cardano node through a <em>local socket</em>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="consequences">Consequences<a href="#consequences" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li>Limit Hydra dependencies to <a href="https://github.com/input-output-hk/plutus" target="_blank" rel="noopener noreferrer">plutus</a> repository</li><li>Remove all PAB-related code as well as off-chain <code>Contract</code>s code and related dependencies</li></ul>]]></content:encoded>
            <category>Accepted</category>
        </item>
        <item>
            <title><![CDATA[11. Use cardano-api
]]></title>
            <link>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/11</link>
            <guid>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/11</guid>
            <pubDate>Thu, 18 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[Status]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="status">Status<a href="#status" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>Accepted</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="context">Context<a href="#context" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li>To implement Hydra Head's ledger we have been working with the <a href="https://github.com/input-output-hk/cardano-ledger-specs" target="_blank" rel="noopener noreferrer">ledger-specs</a> packages which provide a low-level interface to work with transactions and ledgers<ul><li>We also use a lightly wrapped ledger-specs API as our interface for Off-chain transaction submission. This introduced some boilerplate in order to align with cardano-api and provide JSON serialisation.</li></ul></li><li>In our initial experiments <a href="/head-protocol/unstable/fr/adr/10">connecting directly</a> to a cardano node we have also been using the ledger API for building transactions for want of some scripts-related features in the cardano-api</li><li>cardano-api is expected to be the supported entrypoint for clients to interact with Cardano chain while ledger-specs is reserved for internal use and direct interactions with ledgers</li><li>cardano-api now provides all the features we need to run our on-chain validators</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="decision">Decision<a href="#decision" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p><em>Therefore</em></p><ul><li>Use cardano-api types and functions instead of ledger-specs in <code>Hydra.Chain.Direct</code> component</li><li>Use cardano-api types instead of custom ones in <code>Hydra.Ledger.Cardano</code> component</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="consequences">Consequences<a href="#consequences" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li>Removes the boilerplate in <code>Hydra.Ledger.Cardano</code> required to map cardano-api types sent by clients to builtin and ledger-specs types</li><li>Simplifies the  <code>Hydra.Chain.Direct</code> component:<ul><li>Replaces custom transaction building in <code>Tx</code></li><li>Replaces custom transaction fees calculation and balancing in <code>Wallet</code></li><li>Replace low-level connection establishment using cardano-api functions connecting to the node (keeping the chain sync subscription)</li></ul></li></ul>]]></content:encoded>
            <category>Accepted</category>
        </item>
        <item>
            <title><![CDATA[12. Top-down Test-driven Design
]]></title>
            <link>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/12</link>
            <guid>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/12</guid>
            <pubDate>Thu, 25 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[Status]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="status">Status<a href="#status" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>Accepted</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="context">Context<a href="#context" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li><a href="https://en.wikipedia.org/wiki/Test-driven_development" target="_blank" rel="noopener noreferrer">Test-Driven Development</a> or <em>Test-Driven Design</em> is a technique that helps team promotes simple and loosely coupled design, reduces the amount of code written, increases confidence in delivered software by providing a high level of code coverage by regression tests, and improves development speed through shorter feedback loop</li><li>While initially focused on <em>unit tests</em>, TDD has evolved over time to include higher-level tests like <a href="https://en.wikipedia.org/wiki/Behavior-driven_development" target="_blank" rel="noopener noreferrer">Behaviour Driven Development</a> or <a href="https://en.wikipedia.org/wiki/Specification_by_example" target="_blank" rel="noopener noreferrer">Specification by Example</a>, leading to comprehensive strategies like the <a href="http://tpierrain.blogspot.com/2021/03/outside-in-diamond-tdd-1-style-made.html" target="_blank" rel="noopener noreferrer">Outside-In Diamond TDD</a></li><li>Being a foundational part of scalable applications based on Cardano blockchain, Hydra Head needs to be released early, often, and with high assurance in order to benefit from early adopters' feedback</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="decision">Decision<a href="#decision" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p><em>Therefore</em></p><p>We start as early as possible with <em>End-to-End</em> tests, gradually making them more complex as we develop the various components but starting with something simple (like a system-level but dummy chain and hydra network).</p><p>We flesh out other integration tests as needed, when we refine the technological stack used for the various bits and pieces.</p><p>We do most of our work in the <em>Executable Specifications</em> layer while we are developing the core domain functions, eg. the Head protocol. The rationale being this is the level at which we can test the most complex behaviours in the fastest and safest possible way as we everything runs without external dependencies or can even run as pure code using io-sim.</p><p>We tactically drop to <em>Unit tests</em> level when dealing with the protocol's "fine prints".</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="consequences">Consequences<a href="#consequences" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li>Development of each "feature", whether new or change to existing one, should start with a test defined at the highest level possible, but no higher</li><li>A detailed presentation of the various testing layers is available in the <a href="https://github.com/input-output-hk/hydra/wiki/Testing-Strategy" target="_blank" rel="noopener noreferrer">wiki</a></li></ul>]]></content:encoded>
            <category>Accepted</category>
        </item>
        <item>
            <title><![CDATA[13. Plutus Contracts Testing Strategy
]]></title>
            <link>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/13</link>
            <guid>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/13</guid>
            <pubDate>Wed, 19 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[Status]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="status">Status<a href="#status" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>Accepted</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="context">Context<a href="#context" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li>We are implementing our custom (<a href="/head-protocol/unstable/fr/adr/10">Direct</a>) interaction w/ Cardano blockchain and not using the PAB nor the <code>Contract</code> monad to define off-chain contract code</li><li>This implies we cannot use the <a href="https://github.com/input-output-hk/plutus-apps/blob/main/plutus-contract/src/Plutus/Contract/Test.hs" target="_blank" rel="noopener noreferrer">official</a> testing framework for Contracts which relies on <code>Contract</code> monad and emulator traces nor the <a href="https://plutus-apps.readthedocs.io/en/latest/plutus/tutorials/contract-testing.html" target="_blank" rel="noopener noreferrer">QuickCheck based framework</a></li><li>We want to follow our <a href="/head-protocol/unstable/fr/adr/12">Test-Driven Development</a> approach for contracts as this is a critical part of Hydra</li><li>On-Chain Validators need not only to be correct and functional, but also secure and hardened against malicious parties</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="decision">Decision<a href="#decision" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p><em>Therefore</em></p><ul><li>We test-drive single contracts code using <em>Mutation-Based Property Testing</em></li><li>Contracts are tested through the construction of actual <em>transactions</em> and running phase-2 ledger validation process</li><li>We start from a "healthy" transaction, that's expected to be correct and stay so</li><li>Contract code is initially <code>const True</code> function that validates any transaction</li><li>We flesh the contract's code piecemeal through the introduction of <em>Mutations</em> that turn a healthy transaction into an expectedly invalid one</li><li>We gradually build a set of combinators and generators that make it easier to mutate arbitrarily transactions, and combine those mutations</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="consequences">Consequences<a href="#consequences" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li>We make the contracts' <em>Threat model</em>  explicit through the tests we write, which should help future auditors' work</li><li>We'll need an additional layer of tests to exercise the Hydra OCV State Machine through <em>sequence of transactions</em>. This could be implemented using <a href="https://github.com/input-output-hk/plutus-apps/tree/main/quickcheck-dynamic" target="_blank" rel="noopener noreferrer">quickcheck-dynamic</a> library, or other tools that are currently being developed by the Cardano community</li></ul>]]></content:encoded>
            <category>Accepted</category>
        </item>
        <item>
            <title><![CDATA[14. Token usage in Hydra Scripts
]]></title>
            <link>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/14</link>
            <guid>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/14</guid>
            <pubDate>Mon, 14 Feb 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[Status]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="status">Status<a href="#status" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>Accepted</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="context">Context<a href="#context" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li>The Hydra on-chain-verification scripts are used to validate Hydra protocol transactions and ensure they are lawful.</li><li>At least these three properties need to be enforced:<ul><li>Authentication: ensure that only Head participants can, for example, <code>abort</code> a Head</li><li>Contract continuity: ensure that a Head was <code>init</code>ialized before it can be opened by a <code>collectCom</code> tx.</li><li>Completeness: ensure that all Head participants had chance to <code>commit</code> funds to a Head.</li></ul></li><li>The Hydra Head paper introduces <strong>participation tokens (PT)</strong> and a <strong>state thread token (ST)</strong> for that matter.</li><li>Such tokens (a.k.a native assets) are identified by the <code>CurrencySymbol</code>, that is the hash of their <code>MintingPolicyScript</code> (a.k.a <code>PolicyID</code> in the ledger), and a <code>ByteString</code>, the socalled <code>TokenName</code> (a.k.a as <code>AssetName</code> in the ledger, see <a href="https://hydra.iohk.io/job/Cardano/cardano-ledger-specs/specs.shelley-ma/latest/download-by-type/doc-pdf/shelley-ma#subsection.3.2" target="_blank" rel="noopener noreferrer">shelley-ma ledger spec</a>)</li><li>There can be multiple Hydra Heads on a network and a <code>hydra-node</code> need to distinguish individual Head instances or even (later) keep track of multiple Heads. Concretely, this means that we need to infer a Head identifier (<code>HeadId</code>) from observing each of the Hydra protocol transactions. </li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="decision">Decision<a href="#decision" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li>We solve both challenges by defining that ST and PTs <strong>shall use the same</strong> <code>MintingPolicyScript</code> and thus have same <code>CurrencySymbol</code></li><li>The <code>MintingPolicyScript</code> shall be parameterized by <code>TxOutRef</code> to yield a unique <code>CurrencySymbol</code> per Head
(similar to the <a href="https://github.com/input-output-hk/plutus/tree/1efbb276ef1a10ca6961d0fd32e6141e9798bd11/plutus-use-cases/src/Plutus/Contracts/Currency.hs" target="_blank" rel="noopener noreferrer"><code>OneShotCurrency</code></a> example)</li><li>ST and one PT per participant are minted in the <code>initTx</code></li><li>The <code>TokenName</code> of the ST can be any well-known <code>ByteString</code>, e.g. <code>"HydraHeadV1"</code></li><li>The <code>TokenName</code> of the PTs needs to be the <code>PubKeyHash</code> of the respective participant</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="consequences">Consequences<a href="#consequences" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li><p>Heads can be identified by looking for the <code>ST</code> in <code>init</code>, <code>collectCom</code>, <code>close</code>, <code>contest</code> or <code>fanout</code> transactions, or the <code>PT</code> in <code>commit</code> transactions. In both cases, the <code>CurrencySymbol == HeadId</code></p></li><li><p>Our scripts become simpler as we only need to check that ST/PT are paid forward, instead of needing to check datums</p></li><li><p>The datum produced by <code>commit</code> txs (and consumed by <code>collectCom</code>) is <code>Just SerializedTxOut</code>, which is simpler than also keeping the participant which committed in the datum (compare to full life-cycle of <a href="https://github.com/input-output-hk/hydra/tree/0.3.0/docs/images/on-chain-full.jpg" target="_blank" rel="noopener noreferrer">0.3.0</a>).</p></li><li><p>The <code>v_head</code> script validator does not need to be parameterized, which makes discovering new Heads (and also tracking them for metrics) easier as the address to watch for is common to all Heads (of the same <code>v_head</code> version).</p></li><li><p>The <code>v_head</code> script (path) for the abort life-cycle can be implemented already much safer by checking that all PTs are burned on the <code>abort</code> transaction (counting inputs in abort life-cycle of <a href="https://github.com/input-output-hk/hydra/tree/0.3.0/docs/images/on-chain-abort.jpg" target="_blank" rel="noopener noreferrer">0.3.0</a>).</p></li><li><p>Updated diagrams for the <a target="_blank" href="/head-protocol/unstable/fr/assets/files/on-chain-full-eea3dda97376810a7bfac1848a11a84a.jpg">full</a> and <a target="_blank" href="/head-protocol/unstable/fr/assets/files/on-chain-abort-c3483946d3116662c5cabfd67e3dde4e.jpg">abort</a> on-chain life-cycles of a Hydra Head.</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="follow-up-questions">Follow-up questions<a href="#follow-up-questions" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li>What value does the <code>ST</code> actually add? We could always look for the <code>PT</code> to identify a Head and contract continuity would already be achieved by the <code>PT</code>s!</li><li>In discussions it turned out to be not clear where the Head's <code>CurrencySymbol</code> is coming from, and consequently how to identify that an <code>ST</code> is indeed an <code>ST</code>?</li></ul>]]></content:encoded>
            <category>Accepted</category>
        </item>
        <item>
            <title><![CDATA[15. Configuration Through an Admin API
]]></title>
            <link>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/15</link>
            <guid>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/15</guid>
            <pubDate>Thu, 17 Mar 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[Status]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="status">Status<a href="#status" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>Draft</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="context">Context<a href="#context" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li>Hydra-node currently requires a whole slew of command-line arguments to configure properly its networking layer: <code>--peer</code> to connect to each peer, <code>--cardano-verification-key</code> and <code>--hydra-verification-key</code> to identify the peer on the L1 and L2 respectively.</li><li>This poses significant challenges for operating a <em>cluster</em> of Hydra nodes as one needs to know beforehand everything about the cluster, then pass a large number of arguments to some program or docker-compose file, before any node can be started<ul><li>This is a pain that's been felt first-hand for benchmarking and testing purpose</li></ul></li><li>Having static network configuration is probably not sustainable in the long run, even if we don't add any fancy multihead capabilities to the node, as it would make it significantly harder to have automated creation of Heads.</li><li>There's been an <a href="https://github.com/input-output-hk/hydra/pull/222" target="_blank" rel="noopener noreferrer">attempt</a> at providing a file-based network configuration but this was deemed unconvincing</li><li><a href="https://eprint.iacr.org/2020/299.pdf" target="_blank" rel="noopener noreferrer">Hydra paper (sec. 4, p. 13)</a> explicitly assumes the existence of a <em>setup</em> phase<ul><li>This <em>setup</em> is currently left aside, e.g. exchange of keys for setting up multisig and identifying peers. The <a href="https://github.com/input-output-hk/hydra/blob/abailly-iohk/admin-api-adr/hydra-node/exe/hydra-node/Main.hs#L41" target="_blank" rel="noopener noreferrer">hydra-node</a> executable is statically configured and those things are assumed to be known beforehand</li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="decision">Decision<a href="#decision" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li>Hydra-node exposes an <em>Administrative API</em> to enable configuration of the Hydra network using "standard" tools<ul><li>API is exposed as a set of HTTP endpoints on some port, consuming and producing JSON data,</li><li>It is documented as part of the User's Guide for Hydra Head</li></ul></li><li>This API provides <em>commands</em> and <em>queries</em> to:<ul><li>Add/remove <em>peers</em> providing their address and keys,</li><li>List currently known peers and their connectivity status,</li><li>Start/stop/reset the Hydra network</li></ul></li><li>This API is implemented by a <em>new component</em> accessible through a network port separate from current <em>Client API</em>, that <em>configures</em> the <code>Network</code> component</li></ul><p>The following picture sketches the proposed architectural change:</p><p><img loading="lazy" alt="Architecture change" src="/head-protocol/unstable/fr/assets/images/0015-architecture-change-18873d5f6fa6f8237431a6cfa83a03e3.jpg" width="5351" height="2989" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="qa">Q&amp;A<a href="#qa" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li><em>Why a REST interface?</em><ul><li>This API is an interface over a specific <em>resource</em> controlled by the Hydra node, namely its knowledge of other peers with which new <em>Head_s can be opened. As such a proper REST interface (_not</em> RPC-in-disguise) seems to make sense here, rather than stream/event-based <a href="/head-protocol/unstable/fr/adr/3">duplex communication channels</a></li><li>We can easily extend such an API with WebSockets to provide notifications (e.g. peers connectivity, setup events...)</li></ul></li><li><em>Why a separate component?</em><ul><li>We could imagine extending the existing <a href="https://github.com/input-output-hk/hydra/blob/9129c7c013fe2cdc77db048a54981e1ace0843b8/hydra-node/src/Hydra/API/Server.hs" target="_blank" rel="noopener noreferrer">APIServer</a> interface with new messages related to this network configuration, however this seems to conflate different responsibilities in a single place: Configuring and managing the Hydra node itself, and configuring, managing, and interacting with the Head itself</li><li>"Physical" separation of endpoints makes it easier to secure a very sensitive part of the node, namely its administration, e.g by ensuring this can only be accessed through a specific network interface, without relying on application level authentication mechanisms</li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="consequences">Consequences<a href="#consequences" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li>It's easy to deploy Hydra nodes with some standard configuration, then dynamically configure them, thus reducing the hassle of defining and configuring the Hydra network</li><li>It makes it possible to <em>reconfigure</em> a Hydra node with different peers</li><li>The <em>Client API</em> should reflect the state of the network and disable <code>Init</code>ing a head if the network layer is not started<ul><li>In the long run, it should also have its scope reduced to represent only the possible interactions with a <em>Head</em>, moving things related to network connectivity and setup to the Admin API</li><li>In a <em>Managed Head</em> scenario it would even make sense to have another layer of separation between the API to manage the life-cycle of the Head and the API to make transactions within the Head</li></ul></li><li>Operational tools could be built easily on top of the API, for command-line or Web-based configuration</li></ul>]]></content:encoded>
            <category>Draft</category>
        </item>
        <item>
            <title><![CDATA[16. Keep Rejected ADRs
]]></title>
            <link>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/16</link>
            <guid>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/16</guid>
            <pubDate>Wed, 23 Mar 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[Status]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="status">Status<a href="#status" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>Accepted</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="context">Context<a href="#context" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>We have started using <em>Architecture Decision Records</em> as our primary way to document the most important design decisions we take while developing Hydra Node, and this has proved effective in fostering fruitful discussions about major architecture changes.</p><p>During the course of this project, we have sometimes had debates on various topics leading to rejection of <a href="https://github.com/input-output-hk/hydra/pull/230" target="_blank" rel="noopener noreferrer">some ADRs</a>. It could be the case that  a previously rejected proposal turns out to be interesting, either because the context and situation have changed enough to reevaluate a proposal, or as background for some new proposal.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="decision">Decision<a href="#decision" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p><em>therefore</em></p><ul><li>We will keep rejected <em>Architecture Decision Records</em> alongside accepted and draft ones, in the same location and format</li><li>Rejected ADRs <em>must</em> have tag <code>[Rejected]</code> set</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="consequences">Consequences<a href="#consequences" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>Once attributed a <em>serial number</em> an ADR keeps it "forever", whether it's rejected or accepted</p>]]></content:encoded>
            <category>Accepted</category>
        </item>
        <item>
            <title><![CDATA[17. Use UDP protocol for Hydra networking
]]></title>
            <link>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/17</link>
            <guid>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/17</guid>
            <pubDate>Mon, 28 Mar 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[Status]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="status">Status<a href="#status" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>Draft</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="context">Context<a href="#context" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>Current Hydra networking layer is based on <a href="https://github.com/input-output-hk/ouroboros-network/tree/master/ouroboros-network-framework" target="_blank" rel="noopener noreferrer">Ouroboros network framework</a> networking stack which, among other features, provides:</p><ol><li>An abstraction of stream-based duplex communication channels called a <a href="https://github.com/input-output-hk/ouroboros-network/blob/6c15a8093bac34091ad96af2b8b0d1f7fe54b732/ouroboros-network-framework/src/Ouroboros/Network/Snocket.hs" target="_blank" rel="noopener noreferrer">Snocket</a>,</li><li>A Multiplexing connection manager that manages a set of equivalent peers, maintains connectivity, and ensures diffusion of messages to/from all peers,</li><li>Typed protocols for expressing the logic of message exchanges as a form of <em>state machine</em>.</li></ol><p>While it's been working mostly fine so far, the abstractions and facilities provided by this network layer are not well suited for Hydra Head networking. Some of the questions and shortcomings are discussed in a document on <a href="/head-protocol/unstable/fr/core-concepts/architecture/networking">Networking Requirements</a>, and as the Hydra Head matures it seems time is ripe for overhauling current network implementation to better suite current and future Hydra Head networks needs.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="decision">Decision<a href="#decision" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li>Hydra Head nodes communicate by sending messages to other nodes using <a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol" target="_blank" rel="noopener noreferrer">UDP</a> protocol</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="details">Details<a href="#details" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li><em>How do nodes know each other?</em>: This is unspecified by this ADR and left for future work, it is assumed that a Hydra node operator knows the IP:Port address of its peers before opening a Head with them</li><li><em>Are messages encrypted?</em>: This should probably be the case in order to ensure Heads' privacy but is also left for future work</li><li><em>How are nodes identified?</em>: At the moment they are identified by their IP:Port pair. As we implement more of the setup process from section 4 of the Hydra Head paper, we should identify nodes by some public key(hash) and resolve the actual IP:Port pair using some other mechanism</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="consequences">Consequences<a href="#consequences" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li>Node's <em>HeadLogic</em> handles lost, duplicates, and out-of-order messages using <em>retry</em> and <em>timeout</em> mechanisms</li><li>Messages should carry a unique identifier, eg. source node and index</li><li>Protocol, eg. messages format, is documented</li></ul>]]></content:encoded>
            <category>Draft</category>
        </item>
        <item>
            <title><![CDATA[18. Single state in Hydra.Node.
]]></title>
            <link>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/18</link>
            <guid>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/18</guid>
            <pubDate>Wed, 13 Apr 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[Status]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="status">Status<a href="#status" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>Superseded by <a href="/head-protocol/unstable/fr/adr/23">ADR 23</a> and <a href="/head-protocol/unstable/fr/adr/26">ADR 26</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="context">Context<a href="#context" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li>Currently the <code>hydra-node</code> maintains two pieces of state during the life-cycle of a Hydra Head:<ol><li>A <code>HeadState tx</code> provided by the <code>HydraHead tx m</code> handle interface and part of the <code>Hydra.Node</code> module. It provides the basis for the main <code>hydra-node</code> business logic in <code>Hydra.Node.processNextEvent</code> and <code>Hydra.HeadLogic.update</code><a href="https://github.com/input-output-hk/hydra/blob/a98e2907c4e425de2736782793383aad63132c14/hydra-node/src/Hydra/Node.hs#L256-L257" target="_blank" rel="noopener noreferrer">Creation</a>, <a href="https://github.com/input-output-hk/hydra/blob/a98e2907c4e425de2736782793383aad63132c14/hydra-node/src/Hydra/Node.hs#L174" target="_blank" rel="noopener noreferrer">Usage</a></li><li><code>SomeOnChainHeadState</code> is kept in the <code>Hydra.Chain.Direct</code> to keep track of the latest known head state, including notable transaction outputs and information how to spend it (e.g. scripts and datums)
<a href="https://github.com/input-output-hk/hydra/blob/a98e2907c4e425de2736782793383aad63132c14/hydra-node/src/Hydra/Chain/Direct.hs#L156-L162" target="_blank" rel="noopener noreferrer">Code</a>, <a href="https://github.com/input-output-hk/hydra/blob/a98e2907c4e425de2736782793383aad63132c14/hydra-node/src/Hydra/Chain/Direct.hs#L449" target="_blank" rel="noopener noreferrer">Usage 1</a>, <a href="https://github.com/input-output-hk/hydra/blob/a98e2907c4e425de2736782793383aad63132c14/hydra-node/src/Hydra/Chain/Direct.hs#L414" target="_blank" rel="noopener noreferrer">Usage 2</a>, <a href="https://github.com/input-output-hk/hydra/blob/a98e2907c4e425de2736782793383aad63132c14/hydra-node/src/Hydra/Chain/Direct.hs#L349-L352" target="_blank" rel="noopener noreferrer">Usage 3</a>
(There are other unrelated things kept in memory like the event history in the API server or a peer map in the network heartbeat component.)</li></ol></li><li>The interface between the <code>Hydra.Node</code> and a <code>Hydra.Chain</code> component consists of <ul><li>constructing certain Head protocol transactions given a description of it (<code>PostChainTx tx</code>):<div class="language-hs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-hs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token hvariable">postTx</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">::</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">MonadThrow</span><span class="token plain"> </span><span class="token hvariable">m</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=&gt;</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">PostChainTx</span><span class="token plain"> </span><span class="token hvariable">tx</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain"> </span><span class="token hvariable">m</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copier le code" title="Copier" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li><li>a callback function when the <code>Hydra.Chain</code> component observed a new Head protocol transaction described by <code>OnChainTx tx</code>:<div class="language-hs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-hs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">type</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">ChainCallback</span><span class="token plain"> </span><span class="token hvariable">tx</span><span class="token plain"> </span><span class="token hvariable">m</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">OnChainTx</span><span class="token plain"> </span><span class="token hvariable">tx</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain"> </span><span class="token hvariable">m</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copier le code" title="Copier" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li></ul></li><li>Given by the usage sites above, the <code>Hydra.Chain.Direct</code> module requires additional info to do both, construct protocol transactions with <code>postTx</code> as well as observe potential <code>OnChainTx</code> (<a href="https://github.com/input-output-hk/hydra/blob/a98e2907c4e425de2736782793383aad63132c14/hydra-node/src/Hydra/Chain/Direct.hs#L333-L336" target="_blank" rel="noopener noreferrer">here</a>). Hence we see that, operation of the <code>Hydra.Chain.Direct</code> component (and likely any implementing the interface fully) is <strong>inherently stateful</strong>.</li><li>We are looking at upcoming features to <a href="https://github.com/input-output-hk/hydra/issues/185" target="_blank" rel="noopener noreferrer">handle rollbacks</a> and dealing with <a href="https://github.com/input-output-hk/hydra/issues/187" target="_blank" rel="noopener noreferrer">persisting the head state</a>.<ul><li>Both could benefit from the idea, that the <code>HeadState</code> is just a result of pure <code>Event</code> processing (a.k.a event sourcing).</li><li>Right now the <code>HeadState</code> kept in <code>Hydra.Node</code> alone, is not enough to fully describe the state of the <code>hydra-node</code>. Hence it would not be enough to just persist all the <code>Event</code>s and replaying them to achieve persistence, nor resetting to some previous <code>HeadState</code> in the presence of a rollback.</li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="decision">Decision<a href="#decision" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li><p>We define and keep a "blackbox" <code>ChainStateType tx</code> in the <code>HeadState tx</code></p><ul><li>It shall not be introspectable to the business logic in <code>HeadLogic</code></li><li>It shall contain chain-specific information about the current Hydra Head, which will naturally need to evolve once we have multiple Heads in our feature scope</li><li>For example:</li></ul><div class="language-hs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-hs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">data</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">HeadState</span><span class="token plain"> </span><span class="token hvariable">tx</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">IdleState</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token operator" style="color:#393A34">|</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">InitialState</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"> </span><span class="token hvariable">chainState</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">::</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">ChainStateType</span><span class="token plain"> </span><span class="token hvariable">tx</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token comment" style="color:#999988;font-style:italic">-- ...</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token operator" style="color:#393A34">|</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">OpenState</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"> </span><span class="token hvariable">chainState</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">::</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">ChainStateType</span><span class="token plain"> </span><span class="token hvariable">tx</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token comment" style="color:#999988;font-style:italic">-- ...</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token operator" style="color:#393A34">|</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">ClosedState</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"> </span><span class="token hvariable">chainState</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">::</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">ChainStateType</span><span class="token plain"> </span><span class="token hvariable">tx</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token comment" style="color:#999988;font-style:italic">-- ...</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copier le code" title="Copier" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li><li><p>We provide the latest <code>ChainStateType tx</code> to <code>postTx</code>:</p><div class="language-hs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-hs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token hvariable">postTx</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">::</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">ChainStateType</span><span class="token plain"> </span><span class="token hvariable">tx</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">PostChainTx</span><span class="token plain"> </span><span class="token hvariable">tx</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain"> </span><span class="token hvariable">m</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copier le code" title="Copier" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li><li><p>We change the <code>ChainEvent tx</code> data type and callback interface of <code>Chain</code> to:</p><div class="language-hs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-hs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">data</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">ChainEvent</span><span class="token plain"> </span><span class="token hvariable">tx</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">Observation</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"> </span><span class="token hvariable">observedTx</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">::</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">OnChainTx</span><span class="token plain"> </span><span class="token hvariable">tx</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token hvariable">newChainState</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">::</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">ChainStateType</span><span class="token plain"> </span><span class="token hvariable">tx</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token operator" style="color:#393A34">|</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">Rollback</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">ChainSlot</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token operator" style="color:#393A34">|</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">Tick</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">UTCTime</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">type</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">ChainCallback</span><span class="token plain"> </span><span class="token hvariable">tx</span><span class="token plain"> </span><span class="token hvariable">m</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token constant" style="color:#36acaa">ChainStateType</span><span class="token plain"> </span><span class="token hvariable">tx</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">Maybe</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token constant" style="color:#36acaa">ChainEvent</span><span class="token plain"> </span><span class="token hvariable">tx</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain"> </span><span class="token hvariable">m</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copier le code" title="Copier" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>with the meaning, that invocation of the callback indicates receival of a transaction which is <code>Maybe</code> observing a relevant <code>ChainEvent tx</code>, where an <code>Observation</code> may include a <code>newChainState</code>.</p></li><li><p>We also decide to extend <code>OnChainEffect</code> with a <code>ChainState tx</code> to explicitly
thread the used <code>chainState</code> in the <code>Hydra.HeadLogic</code>.</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="consequences">Consequences<a href="#consequences" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li>We need to change the construction of <code>Chain</code> handles and the call sites of <code>postTx</code></li><li>We need to extract the state handling (similar to the event queue) out of the <code>HydraNode</code> handle and shuffle the main of <code>hydra-node</code> a bit to be able to provide the latest <code>ChainState</code> to the chain callback as a continuation.</li><li>We need to make the <code>ChainState</code> serializable (<code>ToJSON</code>, <code>FromJSON</code>) as it will be part of the <code>HeadState</code>.</li><li>We can drop the <code>TVar</code> of keeping <code>OnChainHeadState</code> in the <code>Hydra.Chain.Direct</code> module.</li><li>We need to update <code>DirectChainSpec</code> and <code>BehaviorSpec</code> test suites to mock/implement the callback &amp; state handling.</li><li>We might be able to simplify the <code>ChainState tx</code> to be just a <code>UTxOType tx</code> later.</li><li>As <code>OnChainEffect</code> and <code>Observation</code> values will contain a <code>ChainStateType tx</code>, traces will automatically include the full <code>ChainState</code>, which might be helpful but also possible big. </li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="alternative">Alternative<a href="#alternative" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li>We could extend <code>PostChainTx</code> (like <code>Observation</code>) with <code>ChainState</code> and keep the signatures:</li></ul><div class="language-hs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-hs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token hvariable">postTx</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">::</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">MonadThrow</span><span class="token plain"> </span><span class="token hvariable">m</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=&gt;</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">PostChainTx</span><span class="token plain"> </span><span class="token hvariable">tx</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain"> </span><span class="token hvariable">m</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">type</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">ChainCallback</span><span class="token plain"> </span><span class="token hvariable">tx</span><span class="token plain"> </span><span class="token hvariable">m</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token constant" style="color:#36acaa">ChainState</span><span class="token plain"> </span><span class="token hvariable">tx</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">Maybe</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token constant" style="color:#36acaa">ChainEvent</span><span class="token plain"> </span><span class="token hvariable">tx</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain"> </span><span class="token hvariable">m</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copier le code" title="Copier" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li>Not implemented as it is less clear on the need for a <code>ChainState</code> in the signatures.</li></ul>]]></content:encoded>
            <category>Superseded</category>
        </item>
        <item>
            <title><![CDATA[19. Use of reference scripts
]]></title>
            <link>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/19</link>
            <guid>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/19</guid>
            <pubDate>Fri, 22 Jul 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[Status]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="status">Status<a href="#status" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>Proposed</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="context">Context<a href="#context" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li><p>In the desire to make Hydra transactions smaller and cheaper (at the time of writing any abort tx was too big), we want to use the <strong>reference script</strong> and <strong>reference input</strong> features of the upcoming <code>Babbage</code> ledger era. See the <a href="https://hydra.iohk.io/build/16861604/download/1/babbage-changes.pdf" target="_blank" rel="noopener noreferrer">babbage ledger spec</a>, <a href="https://github.com/cardano-foundation/CIPs/tree/master/CIP-0031" target="_blank" rel="noopener noreferrer">CIP-31</a> and <a href="https://github.com/cardano-foundation/CIPs/tree/master/CIP-0033" target="_blank" rel="noopener noreferrer">CIP-33</a> for details.</p></li><li><p>With these features we do not need to (re-)include scripts in each transaction.</p></li><li><p>The CIPs do not specify how reference scripts are to be managed and we can see at least two options:</p><ol><li>Add them as outputs to the <code>init</code> transaction or prior that as part of each Hydra Head instance</li><li>Post them out-of-band, separate to individual Head instances</li></ol></li><li><p>Ownership of the outputs holding the scripts is to be considered. If these "reference outputs" are spent, they cannot be referred to anymore. This would mean all heads referring to them can be denied of service (DoS).</p></li><li><p>Each head will need to refer to the correct version of the hydra scripts. That is, consistent with the script hashes known to the <code>hydra-node</code>.</p><ul><li>This is also related to the problem of managing script versions &amp; updates.</li><li>Right now, the <code>hydra-node</code> is compiled against <code>hydra-plutus</code> to access compiled script content and hashes.</li></ul></li><li><p>The general trade-off is: instead of paying ADA fees for scripts adding to the transaction size in <em>each</em> transaction, ADA deposits will need to be put down to have scripts be part of the UTxO set in the ledger <em>once</em>.</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="decision">Decision<a href="#decision" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li><p>Publish outputs holding Hydra scripts out-of-band (option 2), because</p><ul><li>All scripts would not fit into the <code>init</code> transaction directly, we would need to post multiple.</li><li>Costs (deposits) would need to be payed for each head instance.</li></ul></li><li><p>The scripts are stored at outputs addressed to some <strong>unspendable</strong> <code>v_publish</code> validator.</p><ul><li>This is to avoid DoS risk and unnecessariy centralization</li><li>We have considered "garbage collection" by allowing spending these outputs into re-publishing new versions of the script.<ul><li>This would make things even more complicated and we decided to not bother about "littering the chain" right now.</li></ul></li></ul></li><li><p>We will publish scripts on release of the <code>hydra-node</code>, or more specifically of the <code>hydra-plutus</code> package.</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="consequences">Consequences<a href="#consequences" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li><p>We need a process and/or tool to publish <code>hydra-plutus</code> scripts and need to pay the deposits.</p><ul><li>Any other party could do the same, this does not lead to centralization.</li></ul></li><li><p>The <code>hydra-node</code> would be need to know the <code>TxIn</code>s of the "right" published scripts.</p><ul><li>In the simplest case we would just make this configurable and provide configurations for the various networks after publishing scripts.</li></ul></li><li><p>If we combine the <code>v_publish</code> validator with a "tag", this allows nodes to "discover" scripts of a known version </p><ul><li>For example, we could define <code>HydraHeadV1</code>, <code>HydraInitialV1</code> and <code>HydraCommitV1</code> as such tags</li><li>We could parameterize the validator by the tag, yielding unique addresses per tag.</li><li>Alternatively, the "tag" could be stored in a canonical form as datum on the script outputs. </li><li>In any case, this allows for some checking consistency or easier configuration (not needing to enumerate which <code>TxIn</code> is which script)</li></ul></li><li><p>By also knowing the script hashes the <code>hydra-node</code> can verify the integrity of "found" reference scripts</p><ul><li>This would be possible right now, as they are compiled into the node</li><li>Might be undesirable later for easier system configuration</li></ul></li><li><p>By making <code>v_publish</code> unspendable, we "litter" the chain. However, any garbage collection scheme would mean potential to DoS again.</p></li><li><p>Extended diagram for the <a target="_blank" href="/head-protocol/unstable/fr/assets/files/on-chain-abort-reference-scripts-4fdf2aae00b80ca995690fe6f3208f4e.jpg">abort</a> on-chain life-cycles of a Hydra Head to include reference scripts.</p></li></ul>]]></content:encoded>
            <category>Proposed</category>
        </item>
        <item>
            <title><![CDATA[20. Handling time
]]></title>
            <link>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/20</link>
            <guid>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/20</guid>
            <pubDate>Tue, 02 Aug 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[Status]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="status">Status<a href="#status" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>Accepted</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="context">Context<a href="#context" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li><p>The Hydra Head protocol is expected to be isomorphic to the ledger it runs on. That means, it should support the same transaction formats and (if desired) use the same ledger rules as the layer 1.</p></li><li><p>Cardano is our layer 1 and its consensus layer separates time into discrete steps, where each step is called a <code>Slot</code>. The network is expected to evolve strictly monotonically on this time scale and so slot numbers (<code>SlotNo</code>) are always increasing.</p></li><li><p>The Cardano mainnet has a block scheduled every 20 seconds, although it may take longer.</p><ul><li>This is because <code>slotLength = 1.0</code> and every 20th slot is "active" with <code>f = 0.05</code>.</li><li>The consensus protocol requires <code>k</code> blocks to be produced within <code>3k/f</code> slots, where <code>k = 2160</code> on mainnet.</li></ul></li><li><p>Transactions on Cardano may have a validity range with a lower and upper bound given as <code>SlotNo</code>.</p></li><li><p>Wall-clock time can be converted to slots (and back) using an <code>EraHistory</code> or <code>EpochInterpreter</code> provided by the consensus layer of the cardano node. This is required as the slot lengths could change over time.</p><ul><li>All past points in time since the <code>SystemStart</code> can be converted.</li><li>Future points in time can <strong>only</strong> be converted in the "safe zone", practically being at least <code>3k/f</code> slots (TODO: cross check). Refer to chapter 17 <em>Time</em> on the <a href="https://hydra.iohk.io/build/16997794/download/1/report.pdf" target="_blank" rel="noopener noreferrer">consensus spec</a> for more details.</li></ul></li><li><p>The Hydra Head protocol allows <code>close</code> and <code>contest</code> transactions only up before a deadline <code>T_final</code>, and <code>fanout</code> transactions after the deadline.</p><ul><li>In the current implementation the deadline is upper validity of <code>closed</code> plus the contestation period.</li><li>We also consider protocol variants which push out the deadline by the contestation period on each <code>contest</code>.</li><li>Contestation periods may very well be longer than the stability window of the protocol. For example: 7 days, while the mainnet stability window is more like 36 hours.</li></ul></li><li><p>We have encountered two problems with handling time in the past</p><ul><li>Trying to convert wall-clock time to slots of the Head protocol deadline led to <code>PastHorizonException</code> (when using very low security parameter <code>k</code>)</li><li>Trying to <code>fanout</code> after the deadline, but before another block has been seen by the L1 ledger led to <code>OutsideValidityIntervalUTxO</code>.</li></ul></li><li><p>The second problem scenario and solution ideas are roughly visible on this whiteboard:</p></li></ul><p><img loading="lazy" src="/head-protocol/unstable/fr/assets/images/020-timing-fanout-ab1b5156cfc3fa34b570aa3eec42d0dd.jpg" width="1005" height="1067" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="decision">Decision<a href="#decision" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li><p>The head logic uses wall-clock time to track time and only convert to/from slots when constructing/observing transactions in the chain layer.</p><ul><li>This ensures that transactions we post or see on the chain can be converted to/from slots.</li><li>The head logic would use <code>UTCTime</code> for points in time and <code>NominalDiffTime</code> for durations.</li><li>The chain layer converts these using the <code>SystemStart</code> and <code>EraHistory</code> into <code>SlotNo</code>.</li></ul></li><li><p>The chain layer informs the logic layer whenever time passed (on the chain) using a new <code>Tick</code> event.</p><ul><li>For the direct chain implementation, this is whenever we see a block in the chain sync protocol.</li><li>Per above decision, the <code>Tick</code> shall contain a <code>UTCTime</code> corresponding to the new "now" as seen through the block chain.</li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="consequences">Consequences<a href="#consequences" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li><p>Conversion from <code>UTCTime -&gt; SlotNo</code> and vice versa stays local to the chain layer.</p></li><li><p>The <code>HeadLogic</code> can track chain time in its state and condition <code>ReadyToFanout</code> upon seeing it pass the deadline.</p><ul><li>Ensures clients only see <code>ReadyToFanout</code> when a following <code>Fanout</code> would be really possible.</li><li>Makes the <code>Delay</code> effect redundant and we can remove it (only delay via reenqueue on the <code>Wait</code> outcome)</li></ul></li><li><p>By introducing <code>Tick</code> events, <code>IOSim</code> will not be able to detect non-progress (deadlocks).</p><ul><li>This means we cannot rely on early exit of simulations anymore and need to determine meaningful simulation endings instead of <code>waitUntilTheEndOfTime</code>.</li></ul></li><li><p>We get a first, rough notion of time for free in our L2 and can support "timed transactions" with same resolution as the L1.</p><ul><li>Tracking time in the state makes it trivial to provide it to the ledger when we <code>applyTransaction</code>.</li><li>Of course we could extend the fidelity of this feature using the system clock for "dead reckoning" between blocks. The conversion of wall clock to slot could even be configurable using an L2 <code>slotLength</code> analogous to L1 (although we might not want/need this).</li></ul></li></ul>]]></content:encoded>
            <category>Accepted</category>
        </item>
        <item>
            <title><![CDATA[21. Bounded transaction validity on Hydra protocol transactions
]]></title>
            <link>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/21</link>
            <guid>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/21</guid>
            <pubDate>Mon, 05 Dec 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[Status]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="status">Status<a href="#status" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>Proposed</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="context">Context<a href="#context" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li><p>The HydraHeadV1 formal specification contains a <em>bounded confirmation window</em>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Deadline</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">T_max &lt;= T_min + L // Bounded confirmation window</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">DL’ = T_max + L    // The latest possible deadline is 2*L</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copier le code" title="Copier" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>with <code>T_min</code> and <code>T_max</code> being the tx validity bounds and <code>L</code> being the
contestation period.</p><ul><li>This is to avoid attacks with specified upper validity bound being too far
in the future and denial of service the head with this (e.g. 10 years).</li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="current-state-of-things">Current state of things:<a href="#current-state-of-things" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h4><ul><li><p>The contestation period and upper tx validity is used for computing the
contestation deadline.</p></li><li><p>There is a <code>closeGraceTime</code> currently hard-coded (to <code>100</code> slots) to set some
upper bound on the <code>closeTx</code>. This was also required so far to compute the
contestation deadline.</p></li><li><p>Different networks (chains) have different slot lenghts, e.g. the preview
network has a slot every <code>1s</code>, while our local devnets use <code>0.1s</code>. This means
hardcoded values like <code>closeGraceTime</code> need to be <em>in sync</em> with the
underlying network.</p></li><li><p>The <code>contestationPeriod</code> can be configured by users via the <code>Init</code> client
input. For example, the hydra-cluster test suite uses a hardcoded <code>cperiod</code> on
the client side.</p></li><li><p>Default value for <code>T_Min</code> is negative infinity.</p></li><li><p>Lower tx validity being in the future does not pose a problem since other
participant is able to close a head.</p></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="what-we-want-to-achieve">What we want to achieve:<a href="#what-we-want-to-achieve" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h4><ul class="contains-task-list containsTaskList_mC6p"><li><p>We want to enforce topmost formula in this file in our code on-chain.</p></li><li><p>Introduce <code>maxGraceTime</code> expressed in seconds in place of <code>closeGraceTime</code> and adjust to
appropriate value.</p></li><li><p>The contestation period is to be used to create bounded close transaction
(together with <code>maxGraceTime</code>). Before it was only used for computing the
contestation deadline.</p></li><li class="task-list-item"><p><input type="checkbox" checked="" disabled=""> <!-- -->If contestation period is higher than <code>maxGraceTime</code> we will pick the
latter. We still need <code>maxGraceTime</code> since if <code>contestationPeriod</code> is low for
the current network our txs reach the upper bound fast and become invalid.
That is why we set the upper tx bound to be minimum between
<code>contestationPeriod</code> and <code>maxGraceTime</code> so that txs have high enough upper
bound.</p></li><li><p>Make sure all head participants use the same value for <code>contestationPeriod</code>.</p></li><li><p>Attack vector has a corresponding mutation test.</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="decision">Decision<a href="#decision" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li><p>Use the specification formula on-chain.</p></li><li><p>Configure the contestation period (number of seconds) on the <code>hydra-node</code>,
e.g. via a <code>--contestation-period</code> command line option.</p></li><li><p>Lower tx bound should be the last known slot as reported by the
<code>cardano-node</code>.</p></li><li><p>Upper tx bound is the current time + minimum between <code>contestationPeriod</code> and
<code>maxGraceTime</code>.</p></li><li><p>When submitting the <code>InitTx</code> make sure to use <code>--contestation-period</code> value
from our node's flag.</p></li><li><p>If other nodes observe <code>OnInitTx</code> and the <code>contestationPeriod</code> value does not
match with their <code>--contestation-period</code> setting - ignore <code>InitTx</code>.</p></li><li><p>Rename <code>closeGraceTime</code> to <code>maxGraceTime</code> since we are using it also for upper
bound of a contest tx.</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="consequences">Consequences<a href="#consequences" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li><p>Not any positive number of seconds is a valid contestation period any more!</p></li><li><p>Upper tx validity of close transaction is the minimum between <code>maxGraceTime</code>
and <code>contestationPeriod</code> and this needs to be <em>good enough</em> value with respect
to running network. This is a consequence required by the ledger when
constructing transactions since we cannot convert arbitrary point in times to
slots.</p></li><li><p>All parties need to aggree on contestation period before trying to run a Head
protocol otherwise InitTx will be ignored.</p></li></ul>]]></content:encoded>
            <category>Accepted</category>
        </item>
        <item>
            <title><![CDATA[22. Test High-level Properties using Model-Based Testing
]]></title>
            <link>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/22</link>
            <guid>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/22</guid>
            <pubDate>Tue, 06 Dec 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[Status]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="status">Status<a href="#status" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>Accepted</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="context">Context<a href="#context" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li>We have been experimenting with <a href="https://hackage.org/packages/quickcheck-dynamic" target="_blank" rel="noopener noreferrer">quickcheck-dynamic</a> for a while, leading to the implementation of basic <a href="https://github.com/input-output-hk/hydra/blob/master/hydra-node/test/Hydra/ModelSpec.hs" target="_blank" rel="noopener noreferrer">Model-Based tests</a> for the Hydra Head Protocol</li><li>These tests fill a gap in our testing strategy, between <a href="https://github.com/input-output-hk/hydra/blob/master/hydra-node/test/Hydra/BehaviorSpec.hs" target="_blank" rel="noopener noreferrer">BehaviorSpec</a> tests which test a "network" of nodes but only at the level of the off-chain Head logic, and <a href="https://github.com/input-output-hk/hydra/blob/master/hydra-cluster/test/Test/EndToEndSpec.hs" target="_blank" rel="noopener noreferrer">EndToEndSpec</a> tests which test a full blown network of nodes interconnected through real network connections and to a real cardano-node:<ul><li>The former are fast but do not test the complete lifecycle of a Head. Furthermore, they are only unit tests so do not provide coverage into various corner cases that could arise in practice</li><li>The latter exercise the full lifecycle but are very slow and brittle</li></ul></li><li>Because they run in <a href="https://github.com/input-output-hk/io-sim" target="_blank" rel="noopener noreferrer">io-sim</a>, those Model-based tests are fast and robust as they don't depend on system interactions. Moreover, decoupling the <em>System-under-Test</em> from <code>IO</code> makes it easy to simulate an environment that deviates from the "happy path" such as delays from the network, filesystem errors, or even adversarial behaviour from the node, or the chain.</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="decision">Decision<a href="#decision" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li>We will maintain and evolve the <a href="https://github.com/input-output-hk/hydra/blob/master/hydra-node/test/Hydra/Model.hs" target="_blank" rel="noopener noreferrer">Model</a> over time to cover more features</li><li>Key properties of the whole system should be written-down as proper <code>DynamicLogic</code> properties and thoroughly tested using quickcheck-dynamic. This includes but is not limited to:<ul><li>Liveness of the Head</li><li>Consistency of the Head</li><li>Soundness of Chain</li><li>Completeness of Chain</li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="consequences">Consequences<a href="#consequences" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li>We need to ensure the Model covers the full lifecycle of a Hydra Head network which at the time of writing this ADR is not the case</li><li>There cannot be <em>One Model to Rule Them All</em> so we should refrain from defining different <code>StateModel</code> or different <code>RunModel</code> depending on what needs to be tested</li><li>In particular, testing against adversarial conditions will certainly require defining different instances of the <code>Network</code> or <code>Chain</code> components, for example:<ul><li>An <em>Active Adversary</em> that fully the controls the protocol and the parties,</li><li>A <em>Network Adversary</em> that can delay and or drop messages,</li><li>A <em>Faulty Filesystem</em> that can causes exceptions when reading or writing files,</li><li>...</li></ul></li></ul>]]></content:encoded>
            <category>Accepted</category>
        </item>
        <item>
            <title><![CDATA[23. Local chain state in chain layer
]]></title>
            <link>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/23</link>
            <guid>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/23</guid>
            <pubDate>Wed, 26 Apr 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Status]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="status">Status<a href="#status" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>Accepted</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="context">Context<a href="#context" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li><a href="/head-protocol/unstable/fr/adr/18">ADR 18</a> merged both <code>headState</code> and <code>chainState</code> into one single
state in the Hydra node, giving the chain layer a way to <em>fetch</em> and update
the <code>chainState</code> when observing a chain event.</li><li>Having the <code>headState</code> containing the <code>chainState</code> made persistency easier to
deal with: we ensure that we always save cohesive states.</li><li>When opening our first head on mainnet we suffered from a <a href="https://github.com/input-output-hk/hydra/issues/784" target="_blank" rel="noopener noreferrer">commit/rollback
issue</a> that was the
result of a race condition in the management of the <code>chainState</code> as implemented
in the context of <a href="/head-protocol/unstable/fr/adr/18">ADR 18</a>.</li><li>Reproducing the issue by introducing rollbacks in the model based tests, we
discovered that, as a client of a hydra-node, we had no idea how to deal with
the rollback event as it is defined now.</li><li><a href="https://github.com/input-output-hk/hydra/issues/185" target="_blank" rel="noopener noreferrer">#185</a> plans to improve
rollback management.</li></ul><p>The following picture details the race condition through an exemple:</p><ol><li><p>The DirectChain component fetch some <code>chainState 0</code> from the <code>headState</code></p></li><li><p>The DirectChain component observes a transaction and it</p></li></ol><ul><li>publishes an event about this observation</li><li>updates the <code>headState</code> with some <code>chainState 1</code></li></ul><ol><li>The Node processes the event and emits a new <code>headState</code> with a
<code>previousRecoverableState</code> in case a rollback later happens</li></ol><p>The problem is that <code>HeadState 2</code> in the figure should point to a previous
recoverable head state containing <code>chainState 0</code> and not <code>chainState 1</code>.</p><p><img loading="lazy" alt="race condition" src="/head-protocol/unstable/fr/assets/images/2023-04-26-023-race-condition-7bc6b62f01470cdeaaaf81ec5227363e.jpg" width="2310" height="1731" class="img_ev3q"></p><p>Updating the chain state only in the <code>HeadLogic</code> leads to problems when several
transactions are in the same block. This can be mitigated by keeping a volatile
chain state locally while analysing the block. But then it leads to race
conditions issues if, for some reason, blocks are produced faster than they are
processed by the HeadLogic. Low probability in production but higher when
testing.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="decision">Decision<a href="#decision" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li>We supersede <a href="/head-protocol/unstable/fr/adr/18">ADR 18</a> with the current ADR.</li><li>A local chain state is re-introduced in the chain component, not shared with
the head logic.</li><li>A copy of the <code>chainState</code> is kept in the <code>headState</code> to keep the benefits of
<a href="/head-protocol/unstable/fr/adr/18">ADR 18</a> regarding persistency.</li><li>The <code>RolledBack</code> output is removed from the API unless actionable by users or
<a href="https://github.com/input-output-hk/hydra/issues/185" target="_blank" rel="noopener noreferrer">#185</a> implemented.</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="consequences">Consequences<a href="#consequences" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li>The rollback logic is removed from the HeadLogic and only maintained in the
chain component.</li><li>The Rollback event carries the ChainState.</li><li>At the node startup, we initialize the chain layer with the persisted
<code>chainState</code></li></ul>]]></content:encoded>
            <category>Accepted</category>
        </item>
        <item>
            <title><![CDATA[24. Persist state changes incrementally
]]></title>
            <link>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/24</link>
            <guid>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/24</guid>
            <pubDate>Mon, 19 Jun 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Status]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="status">Status<a href="#status" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>Accepted</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="context">Context<a href="#context" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li>The state of a Hydra Head is currently persisted as a whole upon each <code>NewState</code> <em>outcome</em> from the <code>update</code> function: The new state is serialised and the <code>state</code> file is overwritten with the corresponding bytes. While this is a straightforward strategy to implement, it has a huge impact on the performance of a Hydra Head as serialising a large data structure like the <code>HeadState</code> and completely overwriting a file is costly<ul><li>We revisited our benchmarks and <a href="https://github.com/input-output-hk/hydra/issues/186#issuecomment-1584292265" target="_blank" rel="noopener noreferrer">found</a> that persistence was the major bottleneck when measuring roundtrip confirmation time,e g. the time it takes from a client's perspective to submit a transaction and observe in a <code>ConfirmedSnapshot</code></li></ul></li><li>Furthermore, the way we currently handle changes to the <code>HeadState</code> in the hydra-node, while conceptually being an <code>Effect</code> is handled differently from other <code>Effect</code>s: The state is updated transactionally through a dedicated <code>modifyHeadState</code> function in the core loop of processing events, and <em>then</em> effects are processed.</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="decision">Decision<a href="#decision" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>Implement state persistence using <a href="https://thinkbeforecoding.com/post/2013/07/28/Event-Sourcing-vs-Command-Sourcing" target="_blank" rel="noopener noreferrer"><em>Event Sourcing</em></a>. Practically, this means:</p><ol><li>Replace the <code>NewState</code> outcome with a <code>StateChanged</code> <em>event</em> which can be part of the <code>Outcome</code> of <code>HeadLogic</code>'s <code>update</code> function, representing the <em>change</em> to be applied to the current state.</li><li>Add an <code>aggregate</code> function to manage applying <code>StateChanged</code> events on top of the current <code>HeadState</code> to keep it updated in-memory.</li><li>Persist <code>StateChanged</code>s in an append-only log using a dedicated <a href="/head-protocol/unstable/fr/adr/4">handle</a>.</li><li>Upon node startup, reread <code>StateChanged</code> events log and reapply those to reset the <code>HeadState</code>.</li></ol><p>The following sequence diagram illustrates new event handling in the <code>HeadLogic</code>:</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="consequences">Consequences<a href="#consequences" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li><p>🐎 The main expected consequence of this change is an increase of the overall performance of Hydra Head network.</p></li><li><p>Need to pattern match twice on the <code>HeadState</code>, once in <code>update</code> and once in <code>aggregate</code>.</p></li><li><p>Terms from the specification are distributed over <code>update</code> and <code>aggregate</code> function. For example, the statements about updating all seen transactions would now be in <code>aggregate</code> and not anymore in <code>update</code>.</p></li><li><p>New possibilities this change introduces with respect to <code>ServerOutput</code> handling and client's access to a head's state:</p><ul><li>Instead of having the <code>HeadLogic</code> emits directly a <code>ClientEffect</code>, the latter could be the result of a client-centric <em>interpretation</em> of a <code>StateChanged</code>.</li><li>Pushing this a little further, we could maintain a <em>Query Model</em> for clients with a dedicated <a href="https://github.com/input-output-hk/hydra/discussions/686" target="_blank" rel="noopener noreferrer">Query API</a> to ease implementation of stateless clients.</li></ul></li><li><p>Calling <code>StateChanged</code> an <em>event</em> while treating it in the code alongside <em>effects</em> might introduce some confusion as we already use the word <a href="https://github.com/input-output-hk/hydra/blob/45913954eb18ef550a31017daa443cee6720a00c/hydra-node/src/Hydra/HeadLogic.hs#L64" target="_blank" rel="noopener noreferrer">Event</a> to designate the inputs (a.k.a. commands) to the Head logic state machine. We might want at some later point to unify the terminology.</p></li></ul>]]></content:encoded>
            <category>Accepted</category>
        </item>
        <item>
            <title><![CDATA[25. Event-sourced, resource-based API
]]></title>
            <link>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/25</link>
            <guid>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/25</guid>
            <pubDate>Fri, 18 Aug 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Status]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="status">Status<a href="#status" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>Draft</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="context">Context<a href="#context" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li><p><a href="/head-protocol/unstable/fr/adr/3">ADR-3</a> concluded that a full-duplex communication channels are
desirable to interact with a <em>reactive</em> system.</p></li><li><p>The Client API communicates several types of messages to clients. Currently
this ranges from node-level <code>PeerConnected</code>, over head-specific <code>HeadIsOpen</code>
to messages about transactions like <code>TxValid</code>. These messages are all of type
<code>StateChanged</code>.</p></li><li><p>Current capabilities of the API:</p><ul><li><p>Clients can retrieve the whole history of <code>StateChanged</code> messages or
opt-out using a query parameter - all or nothing.</p></li><li><p>There is a welcome message called <code>Greetings</code> which is always sent, that
contains the last <code>headStatus</code>.</p></li><li><p>There exists a <code>GetUTxO</code> query-like <code>ClientInput</code>, which will respond with a
<code>GetUTxOResponse</code> containing the confirmed UTxO set in an open head, or (!)
the currently committed UTxO set when the head is initializing.</p></li><li><p>While overall <code>json</code> encoded, clients can choose choose between <code>json</code> or
binary (<code>cbor</code>) output of <code>transaction</code> fields in several of these using a
query parameter.</p></li></ul></li><li><p>Many of these features have been added in a "quick and dirty" way, by monkey
patching the encoded JSON.</p></li><li><p>The current capabalities even do not satisfy all user needs:</p><ul><li><p>Need to wade through lots of events to know the latest state (except the
very basic <code>headStatus</code> from the <code>Greetings</code>).</p></li><li><p>Need to poll <code>GetUTxO</code> <em>or</em> aggregate confirmed transactions on client side
to know the latest UTxO set for constructing transactions.</p></li><li><p>Inclusion of the whole UTxO set in the head is not always desirable and
filtering by address would be beneficial. (not addressed in this ADR though,
relevant discussion
<a href="https://github.com/input-output-hk/hydra/discussions/797" target="_blank" rel="noopener noreferrer">#797</a>)</p></li><li><p>As <a href="/head-protocol/unstable/fr/adr/15">ADR-15</a> also proposes, some clients may not need (or should
not have) access to administrative information.</p></li></ul></li><li><p>It is often a good idea to separate the responsibilities of Commands and
Queries (<a href="https://martinfowler.com/bliki/CQRS.html" target="_blank" rel="noopener noreferrer">CQRS</a>), as well as the model they use.</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="decision">Decision<a href="#decision" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li><p>Drop <code>GetUTxO</code> and <code>GetUTxOResponse</code> messages as they advocate a
request/response way of querying.</p></li><li><p>Realize that <code>ClientInput</code> data is actually a <code>ClientCommand</code> (renaming them)
and that <code>ServerOutput</code> are just <code>projections</code> of the <a href="/head-protocol/unstable/fr/adr/24">internal event stream
(see ADR-24)</a> into read <code>models</code> on the API layer.</p></li><li><p>Compose a versioned (<code>/v1</code>) API out of resource <code>models</code>, which
compartmentalize the domain into topics on the API layer.</p><ul><li><p>A resource has a <code>model</code> type and the <em>latest</em> value is the result of a pure
<code>projection</code> folded over the <code>StateChanged</code> event stream, i.e. <code>project :: model -&gt; StateChanged -&gt; model</code>.</p></li><li><p>Each resource is available at some HTTP path, also called "endpoint":</p><ul><li><p><code>GET</code> requests must respond with the <em>latest</em> state in a single response.</p></li><li><p><code>GET</code> requests with <code>Upgrade: websocket</code> headers must start a websocket
connection, push the <em>latest</em> state as first message and any resource
state updates after.</p></li><li><p>Other HTTP verbs may be accepted by a resource handler, i.e. to issue
resource-specific <em>commands</em>. Any commands accepted must also be available
via the corresponding websocket connection.</p></li></ul></li><li><p><code>Accept</code> request headers can be used to configure the <code>Content-Type</code> of the
response</p><ul><li><p>All resources must provide <code>application/json</code> responses</p></li><li><p>Some resources might support more content types (e.g. CBOR-encoded binary)</p></li></ul></li><li><p>Query parameters may be used to further configure responses of some
resources. For example, <code>?address=&lt;bech32&gt;</code> could be used to filter UTxO by
some address.</p></li></ul></li><li><p>Keep the semantics of <code>/</code>, which accepts websocket upgrade connections and
sends direct/raw output of <code>ServerOutput</code> events on <code>/</code>, while accepting all
<code>ClientCommand</code> messages.</p><ul><li>Define <code>ServerOutput</code> also in terms of the <code>StateChanged</code> event stream</li></ul></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="example-resources">Example resources<a href="#example-resources" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h3><p>Example resource paths + HTTP verbs mapped to existing things to demonstrate the
effects of the decision points above. The mappings may change and are to be
documented by an API specification instead.</p><table><thead><tr><th align="left">Path</th><th align="left">GET</th><th align="left">POST</th><th>PATCH</th><th align="left">DELETE</th></tr></thead><tbody><tr><td align="left"><code>/v1/head/status</code></td><td align="left"><code>HeadStatus(..)</code></td><td align="left">-</td><td>-</td><td align="left">-</td></tr><tr><td align="left"><code>/v1/head/snapshot/utxo</code></td><td align="left">last confirmed snapshot utxo</td><td align="left">-</td><td>-</td><td align="left">-</td></tr><tr><td align="left"><code>/v1/head/snapshot/transactions</code></td><td align="left">confirmed snapshot txs</td><td align="left"><code>NewTx</code> + responses</td><td>-</td><td align="left">-</td></tr><tr><td align="left"><code>/v1/head/ledger/utxo</code></td><td align="left"><code>localUTxO</code></td><td align="left">-</td><td>-</td><td align="left">-</td></tr><tr><td align="left"><code>/v1/head/ledger/transactions</code></td><td align="left"><code>localTxs</code></td><td align="left"><code>NewTx</code> + responses</td><td>-</td><td align="left">-</td></tr><tr><td align="left"><code>/v1/head/commit</code></td><td align="left">-</td><td align="left"><code>Chain{draftCommitTx}</code></td><td>-</td><td align="left">-</td></tr><tr><td align="left"><code>/v1/head</code></td><td align="left">all <code>/v1/head/*</code> data</td><td align="left"><code>Init</code></td><td><code>Close</code></td><td align="left"><code>Fanout</code> / <code>Abort</code></td></tr><tr><td align="left"><code>/v1/protocol-parameters</code></td><td align="left">current protocol parameters</td><td align="left"></td><td></td><td align="left"></td></tr><tr><td align="left"><code>/v1/cardano-transaction</code></td><td align="left">-</td><td align="left"><code>Chain{submitTx}</code></td><td>-</td><td align="left">-</td></tr><tr><td align="left"><code>/v1/peers</code></td><td align="left">a list of peers</td><td align="left">-</td><td>-</td><td align="left">-</td></tr><tr><td align="left"><code>/v1/node-version</code></td><td align="left">node version as in <code>Greetings</code></td><td align="left">-</td><td>-</td><td align="left">-</td></tr><tr><td align="left"><code>/v1/</code></td><td align="left">all <code>/v1/*</code> data</td><td align="left">-</td><td>-</td><td align="left">-</td></tr></tbody></table><p>Multiple heads are out of scope now and hence paths are not including a
<code>&lt;headId&gt;</code> variable section.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="consequences">Consequences<a href="#consequences" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li><p>Clear separation of what types are used for querying and gets subscribed to by
clients and we have dedicated types for sending data to clients</p></li><li><p>Changes on the querying side of the API are separated from the business logic.</p></li><li><p>Clients do not need to aggregate data that is already available on the server
side without coupling the API to internal state representation.</p></li><li><p>Separation of Head operation and Head usage, e.g. some HTTP endpoints can be
operated with authentication.</p></li><li><p>Clients have a fine-grained control over what to subscribe to and what to
query.</p></li><li><p>Versioned API allows clients to detect incompatibility easily.</p></li><li><p>Need to rewrite how the <code>hydra-tui</code> is implemented.</p></li></ul>]]></content:encoded>
            <category>Draft</category>
        </item>
        <item>
            <title><![CDATA[27. Network failures model
]]></title>
            <link>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/27</link>
            <guid>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/27</guid>
            <pubDate>Fri, 08 Sep 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Status]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="status">Status<a href="#status" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>Draft</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="context">Context<a href="#context" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>The current Head cluster is very fragile as has been observed on several occasions: A single hiccup in the connectivity between nodes while a head is open and nodes are exchanging messages can very easily lead to the Head being stuck and require an emergency closing, possibly even manually.</p><p>We want Hydra to be <em>Consistent</em> in the presence of <em>Network Partitions</em>, under the <em>fail-recovery</em> model assumption, eg. processes may fail by stopping and later recovering. Our system lies in the <a href="https://en.wikipedia.org/wiki/CAP_theorem" target="_blank" rel="noopener noreferrer">CP</a> space of the landscape mapped by the CAP theorem.</p><p>We have identified 3 main sources of failures in the <em>fail-recovery</em> model that can lead to a head being stuck:</p><ol><li>The network layer can drop messages from the moment a node <code>broadcast</code>s it, leading to some messages not being received at the other end</li><li>The sending node can crash in between the moment the state is changed (and persisted) and the moment a message is actually sent through the network (or even when it calls <code>broadcast</code>)</li><li>The receiving node can crash in between the moment the message has been received in the network layer, and it's processed (goes through the queue)</li></ol><p>We agree that we'll want to address all those issues in order to provide a good user experience, as not addressing 2. and 3. can lead to hard to troubleshoot issues with heads. We have not experienced those issues yet as they would probably only crop up under heavy loads, or in the wild. But we also agree we want to tackle 1. first because it's where most of the risk lies. By providing a <em>Reliable Broadcast</em> layer, we will significantly reduce the risks and can then later on address the other points.</p><p>Therefore, the scope of this ADR is to address only point 1. above: Ensure broadcast messages are eventually received by all peers, given the sender does not stop before.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="discussion">Discussion<a href="#discussion" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h3><ul><li><p>We are currently using the <a href="https://github.com/input-output-hk/ouroboros-network" target="_blank" rel="noopener noreferrer">ouroboros-framework</a> and <a href="https://github.com/input-output-hk/typed-protocols" target="_blank" rel="noopener noreferrer">typed-protocols</a> network stack as a mere <a href="https://osi-model.com/transport-layer/" target="_blank" rel="noopener noreferrer">transport</a> layer.</p><ul><li>Being built on top of TCP, ouroboros multiplexer (Mux) provides the same reliability guarantees, plus the multiplexing capabilities of course</li><li>It also takes care of reconnecting to peers when a failure is detected which relieves us from doing so, but any reconnection implies a reset of each peer's state machine which means we need to make sure any change to the state of pending/received messages is handled by the applicative layer</li><li>Our <a href="https://github.com/input-output-hk/hydra/blob/8a8e0829964132bde8949e5249a1ab303af92fb8/hydra-node/src/Hydra/Network/Ouroboros/Type.hs#L31" target="_blank" rel="noopener noreferrer">FireForget protocol</a> ignores connections/disconnections</li><li>Ouroboros/typed-protocols provides enough machinery to implement a reliable broadcast protocol, for example by reusing existing <code>[KeepAlive](https://github.com/input-output-hk/ouroboros-network/tree/master/ouroboros-network-protocols/src/Ouroboros/Network/Protocol/KeepAlive)</code> protocol and building a more robust point-to-point protocol than what we have now</li><li>There is a minor limitation, namely that the subscription mechanism does not handle connections invidually, but as a set of equivalent point-to-point full duplex connections whose size (valency) needs to be maintained at a certain threshold, which means that unless backed in the protocol itself, protocol state-machine and applications are not aware of the identity of the remote peer</li></ul></li><li><p>We have built our <code>Network</code> infrastructure over the concept of relatively independent layers, each implementing a similar interface with different kind of messages, to <code>broadcast</code> messages to all peers and be notified of incoming messages through a <code>callback</code>.</p><ul><li><p>This pipes-like abstraction allows us to compose our network stack like:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> withAuthentication (contramap Authentication tracer) signingKey otherParties $</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  withHeartbeat nodeId connectionMessages $</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    withOuroborosNetwork (contramap Network tracer) localhost peers</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copier le code" title="Copier" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li><li><p>This has the nice property that we can basically swap the lower layers should we need to, for example to use <a href="https://github.com/input-output-hk/hydra/blob/abailly-iohk/multi-node-udp/hydra-node/src/Hydra/Network/UDP.hs" target="_blank" rel="noopener noreferrer">UDP</a>, or add other layers for example to address specific head instances in presence of <a href="https://github.com/input-output-hk/hydra/blob/abailly-iohk/multi-node-udp/hydra-node/src/Hydra/Network/MultiHead.hs#L26" target="_blank" rel="noopener noreferrer">multiple heads</a></p></li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="decision">Decision<a href="#decision" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li>We implement our own message tracking and resending logic as a standalone <code>Network</code> layer</li><li>That layer consumes and produces <code>Authenticated msg</code> messages as it relies on identifying the source of messages</li><li>It uses a vector of monotonically increasing <em>sequence numbers</em> associated with each party (including itself) to track what are the last messages from each party and to ensure FIFO delivery of messages<ul><li>This <em>vector</em> is used to identify peers which are lagging behind, resend the missing messages, or to drop messages which have already been received</li><li>The <em>Heartbeat</em> mechanism is relied upon to ensure dissemination of state even when the node is quiescent</li></ul></li><li>We do not implement a <em>pull-based</em> message communication mechanism as initially envisioned</li><li>We do not persist messages either on the receiving or sending side at this time</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="consequences">Consequences<a href="#consequences" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li>We keep our existing <code>Network</code> interface hence all messages will be resent to all peers<ul><li>This could be later optimized either by providing a smarter interface with a <code>send :: Peer -&gt; msg -&gt; m ()</code> unicast function, or by adding a layer with filtering capabilities, or both</li></ul></li><li>We want to specify this protocol clearly in order to ease implementation in other languages, detailing the structure of messages and the semantics of retries and timeouts.</li><li>We may consider relying on the vector clock in the future to ensure perfect ordering of messages on each peer and make impossible for legit transactions to be temporarily seen as invalid. This can happen in the current version and is handled through wait and <em>TTL</em></li></ul>]]></content:encoded>
            <category>Proposed</category>
        </item>
        <item>
            <title><![CDATA[26. Stateless transaction observaion & construction
]]></title>
            <link>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/26</link>
            <guid>https://input-output-hk.github.io/head-protocol/unstable/fr/adr/26</guid>
            <pubDate>Fri, 08 Sep 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Status]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="status">Status<a href="#status" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><p>Draft</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="context">Context<a href="#context" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li><p><a href="/head-protocol/unstable/fr/adr/18">ADR 18</a> merged both <code>headState</code> and <code>chainState</code> into one single
state in the Hydra node, giving the chain layer a way to <em>fetch</em> and update
the <code>chainState</code> when observing a chain event.</p></li><li><p><a href="/head-protocol/unstable/fr/adr/23">ADR 23</a> outlined the need for a local chain state in the chain layer
again to correctly handle correct observation of multiple relevant
transactions and the resulting <code>chainState</code> updates.</p></li><li><p>The <code>ChainStateType tx</code> for our "actual" Cardano chain layer is currently:</p><div class="language-haskell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-haskell codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">data</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">ChainStateAt</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">ChainStateAt</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"> </span><span class="token hvariable">chainState</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">::</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">ChainState</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token hvariable">recordedAt</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">::</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">Maybe</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">ChainPoint</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">data</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">ChainState</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">Idle</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token operator" style="color:#393A34">|</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">Initial</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">InitialState</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token operator" style="color:#393A34">|</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">Open</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">OpenState</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token operator" style="color:#393A34">|</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">Closed</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">ClosedState</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copier le code" title="Copier" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>where <code>InitialState</code>, <code>OpenState</code> and <code>ClosedState</code> hold elaborate information
about the currently tracked Hydra head.</p></li><li><p>We face <a href="https://github.com/input-output-hk/hydra/issues/529" target="_blank" rel="noopener noreferrer">difficulties</a> to
provide sufficient user feedback when an <code>initTx</code> was observed but (for
example) keys do not match our expectation.</p><ul><li>Core problem is, that <code>observeInit</code> is required to take a decision whether
it wants to "adopt" the Head by returning an <code>InitialState</code> or not.</li><li>This makes it impossible to provide user feedback through the <code>HeadLogic</code>
and <code>API</code> layers.</li></ul></li><li><p>We want to build a <a href="https://github.com/input-output-hk/hydra/issues/696" target="_blank" rel="noopener noreferrer">Hydra head
explorer</a>, which should
be able to keep track and discover Hydra heads and their state changes even
when the heads were initialized before starting the explorer.</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="decision">Decision<a href="#decision" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li>We supersede <a href="/head-protocol/unstable/fr/adr/18">ADR 18</a> with the current ADR.</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="changes-internal-to-direct-chain-layer">Changes internal to Direct chain layer<a href="#changes-internal-to-direct-chain-layer" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h3><ul><li><p>Introduce a <code>ResolvedTx</code> type that has its inputs resolved. Where a normal
<code>Tx</code> will only contain <code>TxIn</code> information of its inputs, a <code>ResolvedTx</code> also
includes the <code>TxOut</code> for each input.</p></li><li><p>Change <code>ChainSyncHandler</code> signature to <code>onRollForward :: BlockHeader -&gt; [ResolvedTx] -&gt; m ()</code></p></li><li><p>Change observing function signature to <code>observeSomeTx :: ChainContext -&gt;
ResolvedTx -&gt; Maybe (OnChainTx Tx)</code>. Notably there is no <code>ChainState</code>
involved.</p></li><li><p>Do not guard observation by <code>HeadId</code> in the chain layer and instead do it in the <code>HeadLogic</code> layer.</p></li><li><p>Define a <code>SpendableUTxO</code> type that is a <code>UTxO</code> with potentially needed datums included.</p><ul><li>TBD: instead we could decide to use inline datums and rely on <code>UTxO</code> containing them</li></ul></li><li><p>Change transaction creation functions <code>initialize</code>, <code>commit</code>, <code>abort</code>,
<code>collect</code>, <code>close</code>, <code>contest</code> and <code>fanout</code> in <code>Hydra.Direct.Chain.State</code> to
take <code>SpendableUTxO</code> and <code>HeadId</code>/<code>HeadParameters</code> as needed.</p></li><li><p>Extend <code>IsChainState</code> type class to enforce that it can be updated by
concurrent transactions <code>update :: ChainStateType tx -&gt; [tx] -&gt; ChainStateType tx</code>.</p><ul><li>While this is not strictly needed "outside" of the chain layer, it will have
us not fall into the same pit again.</li></ul></li><li><p>Change <code>ChainStateAt</code> to only hold a <code>spendableUTxO</code> and the <code>recordedAt</code>.</p></li><li><p>Update the <code>LocalChainState</code> in <code>onRollForward</code> by using <code>update</code> and pushing
a new <code>ChainStateAt</code> generically.</p></li></ul><p>TBD:</p><ul><li>Impact on generators</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="chain-interface-changes">Chain interface changes<a href="#chain-interface-changes" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h3><ul><li><p>Add <code>HeadId</code> and <code>HeadParameters</code> to <code>PostChainTx</code>.</p></li><li><p>Add <code>HeadId</code> to all <code>OnChainTx</code> constructors.</p></li><li><p>Extend <code>OnInitTx</code> with observed chain participants.</p><ul><li>TBD: How are <em>cardano</em> verification keys generically represented in <code>HeadLogic</code>?</li></ul></li><li><p>Extend <code>OnContestTx</code> with new deadline and a list of contesters.</p></li><li><p>Move off-chain checks for what makes a "proper head" to <code>HeadLogic</code></p></li></ul><p>TBD:</p><ul><li>Merge <code>HeadSeed</code> and <code>HeadId</code>? How to abstract?</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="consequences">Consequences<a href="#consequences" class="hash-link" aria-label="Lien direct vers le titre" title="Lien direct vers le titre">​</a></h2><ul><li><p>All logic is kept in the logic layer and no protocol decisions (i.e. whether
to adopt or ignore a head initialization) are taken in the chain layer.</p><ul><li>The <code>HeadLogic</code> gets informed of any proper <code>initTx</code> and can log that it is
ignored and for what reason.</li></ul></li><li><p>The transaction observation and construction functions can be moved into a
dedicated package that is cardano-specific, but not requires special state
knowledge of the "direct chain following" and can be re-used as a library.</p></li><li><p>All transaction observation functions used by <code>observeSomeTx</code> will need to be
able to identify a Hydra Head transaction from only the <code>ResolvedTx</code> and the
<code>ChainContext</code></p></li><li><p>Any <code>Chain Tx</code> implementation wanting to re-use existing transaction
observation functions must be able to resolve transaction inputs (against some
ledger state) and produce <code>ResolvedTx</code>.</p><ul><li>A chain-following implementation (as <code>Hydra.Chain.Direct</code>) can keep previous
transactions around.</li><li>A chain indexer on "interesting" protocol addresses can be used to
efficiently query most inputs.</li></ul></li><li><p>We can get rid of the <code>Hydra.Chain.Direct.State</code> glue code altogether.</p></li><li><p>While this does not directly supersede <a href="/head-protocol/unstable/fr/adr/23">ADR23</a>, it paves the way to
remove <code>LocalChainState</code> again as the <code>ChainStateAt</code> is now combinable from
multiple transactions (see <code>update</code> above) and we can keep the state (again)
only in the <code>HeadState</code> aggregate. Note that this would shift the rollback
handling back into the logic layer.</p></li></ul>]]></content:encoded>
            <category>Draft</category>
        </item>
    </channel>
</rss>