-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The Hydra node
--   
--   The Hydra node
@package hydra-node
@version 0.13.0


-- | <a>Projection</a> module exposes the handle which is our
--   implementation of projections from the CQRS terminology.
--   
--   Projections allow us to easily tailor the needs of different API
--   clients (related to our <tt>ServerOutput</tt> messages) and enable us
--   to more easily implement future user needs.
--   
--   This module provides abstract interface for serving different data
--   from the API endpoints and abstracts over the internal implementation
--   (in this case a <a>TVar</a>).
--   
--   What we serve from the API server is <a>TimedServerOutputs</a> and
--   <a>Projection</a> allows us to transform these outputs and add more
--   (stateful) information (like the <a>HeadStatus</a> model).
--   
--   <a>Projection</a>s always need to use a function in form of `(model
--   -&gt; event -&gt; model)` where depending on event we are currently
--   dealing with we might want to alter our existing model.
module Hydra.API.Projection

-- | <a>Projection</a> type used to alter/project the API output to suit
--   the client needs.
data Projection stm event model
Projection :: stm model -> (event -> stm ()) -> Projection stm event model
[getLatest] :: Projection stm event model -> stm model
[update] :: Projection stm event model -> event -> stm ()

-- | Create a <a>Projection</a> handle that knows how to:
--   
--   <ul>
--   <li>get the latest model state</li>
--   <li>update the model using a projection function</li>
--   </ul>
mkProjection :: MonadSTM m => model -> [event] -> (model -> event -> model) -> m (Projection (STM m) event model)


-- | A basic cardano-node client that can talk to a local cardano-node.
--   
--   The idea of this module is to provide a Haskell interface on top of
--   cardano-cli's API, using cardano-api types.
module Hydra.Chain.CardanoClient
data QueryException
QueryAcquireException :: AcquiringFailure -> QueryException
QueryEraMismatchException :: EraMismatch -> QueryException
QueryProtocolParamsConversionException :: ProtocolParametersConversionError -> QueryException

-- | Handle interface for abstract querying of a cardano node.
data CardanoClient
CardanoClient :: ([Address ShelleyAddr] -> IO UTxO) -> NetworkId -> CardanoClient
[queryUTxOByAddress] :: CardanoClient -> [Address ShelleyAddr] -> IO UTxO
[networkId] :: CardanoClient -> NetworkId

-- | Construct a <a>CardanoClient</a> handle.
mkCardanoClient :: NetworkId -> SocketPath -> CardanoClient

-- | Construct a simple payment consuming some inputs and producing some
--   outputs (no certificates or withdrawals involved).
--   
--   On success, the returned transaction is fully balanced. On error,
--   return <a>TxBodyErrorAutoBalance</a>.
buildTransaction :: NetworkId -> SocketPath -> AddressInEra -> UTxO -> [TxIn] -> [TxOut CtxTx] -> IO (Either TxBodyErrorAutoBalance TxBody)

-- | Submit a (signed) transaction to the node.
--   
--   Throws <a>SubmitTransactionException</a> if submission fails.
submitTransaction :: NetworkId -> SocketPath -> Tx -> IO ()

-- | Exceptions that <tt>can</tt> occur during a transaction submission.
--   
--   In principle, we can only encounter an <a>EraMismatch</a> at era
--   boundaries, when we try to submit a "next era" transaction as a
--   "current era" transaction, or vice-versa. Similarly,
--   <tt>TxValidationError</tt> shouldn't occur given that the transaction
--   was safely constructed through <a>buildTransaction</a>.
data SubmitTransactionException
SubmitEraMismatch :: EraMismatch -> SubmitTransactionException
SubmitTxValidationError :: TxValidationErrorInMode CardanoMode -> SubmitTransactionException

-- | Await until the given transaction is visible on-chain. Returns the
--   UTxO set produced by that transaction.
--   
--   Note that this function loops forever; hence, one probably wants to
--   couple it with a surrounding timeout.
awaitTransaction :: NetworkId -> SocketPath -> Tx -> IO UTxO

-- | Describes whether to query at the tip or at a specific point.
data QueryPoint
QueryTip :: QueryPoint
QueryAt :: ChainPoint -> QueryPoint

-- | Query the latest chain point aka "the tip".
queryTip :: NetworkId -> SocketPath -> IO ChainPoint

-- | Query the latest chain point just for the slot number.
queryTipSlotNo :: NetworkId -> SocketPath -> IO SlotNo

-- | Query the system start parameter at given point.
--   
--   Throws at least <a>QueryException</a> if query fails.
querySystemStart :: NetworkId -> SocketPath -> QueryPoint -> IO SystemStart

-- | Query the era history at given point.
--   
--   Throws at least <a>QueryException</a> if query fails.
queryEraHistory :: NetworkId -> SocketPath -> QueryPoint -> IO (EraHistory CardanoMode)

-- | Query the protocol parameters at given point.
--   
--   Throws at least <a>QueryException</a> if query fails.
queryProtocolParameters :: NetworkId -> SocketPath -> QueryPoint -> IO (PParams LedgerEra)

-- | Query <a>GenesisParameters</a> at a given point.
--   
--   Throws at least <a>QueryException</a> if query fails.
queryGenesisParameters :: NetworkId -> SocketPath -> QueryPoint -> IO (GenesisParameters ShelleyEra)

-- | Query UTxO for all given addresses at given point.
--   
--   Throws at least <a>QueryException</a> if query fails.
queryUTxO :: NetworkId -> SocketPath -> QueryPoint -> [Address ShelleyAddr] -> IO UTxO

-- | Query UTxO for given tx inputs at given point.
--   
--   Throws at least <a>QueryException</a> if query fails.
queryUTxOByTxIn :: NetworkId -> SocketPath -> QueryPoint -> [TxIn] -> IO UTxO

-- | Query the whole UTxO from node at given point. Useful for debugging,
--   but should obviously not be used in production code.
--   
--   Throws at least <a>QueryException</a> if query fails.
queryUTxOWhole :: NetworkId -> SocketPath -> QueryPoint -> IO UTxO

-- | Query UTxO for the address of given verification key at point.
--   
--   Throws at least <a>QueryException</a> if query fails.
queryUTxOFor :: NetworkId -> SocketPath -> QueryPoint -> VerificationKey PaymentKey -> IO UTxO

-- | Query the current set of registered stake pools.
--   
--   Throws at least <a>QueryException</a> if query fails.
queryStakePools :: NetworkId -> SocketPath -> QueryPoint -> IO (Set PoolId)

-- | Throws at least <a>QueryException</a> if query fails.
runQuery :: NetworkId -> SocketPath -> QueryPoint -> QueryInMode CardanoMode a -> IO a
throwOnEraMismatch :: MonadThrow m => Either EraMismatch a -> m a
localNodeConnectInfo :: NetworkId -> SocketPath -> LocalNodeConnectInfo CardanoMode
cardanoModeParams :: ConsensusModeParams CardanoMode
instance GHC.Show.Show Hydra.Chain.CardanoClient.QueryException
instance GHC.Show.Show Hydra.Chain.CardanoClient.SubmitTransactionException
instance GHC.Generics.Generic Hydra.Chain.CardanoClient.QueryPoint
instance GHC.Show.Show Hydra.Chain.CardanoClient.QueryPoint
instance GHC.Classes.Eq Hydra.Chain.CardanoClient.QueryPoint
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Chain.CardanoClient.QueryPoint
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Chain.CardanoClient.QueryPoint
instance GHC.Exception.Type.Exception Hydra.Chain.CardanoClient.SubmitTransactionException
instance GHC.Classes.Eq Hydra.Chain.CardanoClient.QueryException
instance GHC.Exception.Type.Exception Hydra.Chain.CardanoClient.QueryException

module Hydra.Chain.Direct.Util
type Block = CardanoBlock StandardCrypto
type VerificationKey = VerKeyDSIGN (DSIGN StandardCrypto)
type SigningKey = SignKeyDSIGN (DSIGN StandardCrypto)
readKeyPair :: FilePath -> IO (VerificationKey PaymentKey, SigningKey PaymentKey)
readFileTextEnvelopeThrow :: HasTextEnvelope a => AsType a -> FilePath -> IO a
readVerificationKey :: FilePath -> IO (VerificationKey PaymentKey)

-- | A simple retrying function with a constant delay. Retries only if the
--   given predicate evaluates to <a>True</a>.
--   
--   Better coupled with a <a>timeout</a> function.
retry :: forall e m a. (MonadCatch m, MonadDelay m, Exception e) => (e -> Bool) -> m a -> m a

module Hydra.ContestationPeriod

-- | A positive, non-zero number of seconds.
newtype ContestationPeriod
UnsafeContestationPeriod :: Natural -> ContestationPeriod

-- | Convert an off-chain contestation period to its on-chain
--   representation.
toChain :: ContestationPeriod -> ContestationPeriod

-- | Convert an on-chain contestation period to its off-chain
--   representation. NOTE: Does truncate to whole seconds.
fromChain :: ContestationPeriod -> ContestationPeriod
toNominalDiffTime :: ContestationPeriod -> NominalDiffTime
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.ContestationPeriod.ContestationPeriod
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.ContestationPeriod.ContestationPeriod
instance GHC.Classes.Ord Hydra.ContestationPeriod.ContestationPeriod
instance GHC.Classes.Eq Hydra.ContestationPeriod.ContestationPeriod
instance GHC.Show.Show Hydra.ContestationPeriod.ContestationPeriod
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.ContestationPeriod.ContestationPeriod


-- | Hydra multi-signature credentials and cryptographic primitives used to
--   sign and verify snapshots (or any messages) within the Hydra protocol.
--   
--   We are re-using the <a>Key</a> interface of 'cardano-api' for a
--   consistent representation. For example: Cardano credentials are
--   'VerificationKey PaymentKey', Hydra credentials are 'VerificationKey
--   HydraKey'.
--   
--   Currently <a>MultiSignature</a> interface is only supporting naiive,
--   concatenated multi-signatures and will change when we adopt aggregated
--   multi-signatures including aggregate keys.
module Hydra.Crypto
class (Eq VerificationKey keyrole, Show VerificationKey keyrole, SerialiseAsRawBytes Hash keyrole, HasTextEnvelope VerificationKey keyrole, HasTextEnvelope SigningKey keyrole) => Key keyrole where {
    data family VerificationKey keyrole;
    data family SigningKey keyrole;
}
getVerificationKey :: Key keyrole => SigningKey keyrole -> VerificationKey keyrole
deterministicSigningKey :: Key keyrole => AsType keyrole -> Seed -> SigningKey keyrole
deterministicSigningKeySeedSize :: Key keyrole => AsType keyrole -> Word
verificationKeyHash :: Key keyrole => VerificationKey keyrole -> Hash keyrole
data family Hash keyrole
data family AsType t
pattern AsHydraKey :: () => AsType HydraKey
pattern HydraKeyHash :: () => Hash Blake2b_256 (VerificationKey HydraKey) -> Hash HydraKey
pattern HydraSigningKey :: () => SignKeyDSIGN Ed25519DSIGN -> SigningKey HydraKey
pattern HydraVerificationKey :: () => VerKeyDSIGN Ed25519DSIGN -> VerificationKey HydraKey

-- | A result type for multisigs verification providing some information in
--   case of failure.
--   
--   This type is of course structurally equivalent to `Maybe
--   [VerificationKey HydraKey]` but it's much more explicit.
data Verified
Verified :: Verified
FailedKeys :: [VerificationKey HydraKey] -> Verified
[failedKeys] :: Verified -> [VerificationKey HydraKey]
KeyNumberMismatch :: Verified

-- | Naiively aggregated multi-signatures.
newtype MultiSignature a
HydraMultiSignature :: [Signature a] -> MultiSignature a
[multiSignature] :: MultiSignature a -> [Signature a]

-- | Signature of <tt>a</tt>, not containing the actual payload.
newtype Signature a
HydraSignature :: SigDSIGN Ed25519DSIGN -> Signature a

-- | Hydra keys (keyrole) which can be used to <a>sign</a> and
--   <a>verify</a> messages, as well as <a>aggregate</a> multi-signatures.
data HydraKey

-- | Create a new <a>SigningKey</a> from a <a>ByteString</a> seed. The
--   created keys are not random and insecure, so don't use this in
--   production code!
generateSigningKey :: ByteString -> SigningKey HydraKey

-- | Sign some value <tt>a</tt> with the provided <a>SigningKey</a>.
sign :: SignableRepresentation a => SigningKey HydraKey -> a -> Signature a

-- | Verify a given 'Signature a' and value <tt>a</tt> using provided
--   <a>VerificationKey</a>.
verify :: SignableRepresentation a => VerificationKey HydraKey -> Signature a -> a -> Bool

-- | Combine multiple signatures of <tt>a</tt> into a 'MultiSignature a'.
aggregate :: [Signature a] -> MultiSignature a

-- | Like aggregate, but use order of given list of keys instead.
--   FIXME(AB): This function exists solely because the order of signatures
--   matters on-chain, and it should match the order of parties as declared
--   in the initTx. This should disappear once we use a proper
--   multisignature scheme
aggregateInOrder :: Ord k => Map k (Signature a) -> [k] -> MultiSignature a

-- | Verify a given 'MultiSignature a' and value <tt>a</tt> provided a list
--   of <a>VerificationKey</a>.
--   
--   Note that order of keys is relevant and that length of signature and
--   multisignature list needs to be the same.
verifyMultiSignature :: SignableRepresentation a => [VerificationKey HydraKey] -> MultiSignature a -> a -> Verified
toPlutusSignatures :: MultiSignature a -> [Signature]
instance GHC.Show.Show (Cardano.Api.Hash.Hash Hydra.Crypto.HydraKey)
instance GHC.Classes.Eq (Cardano.Api.Hash.Hash Hydra.Crypto.HydraKey)
instance GHC.Classes.Ord (Cardano.Api.Hash.Hash Hydra.Crypto.HydraKey)
instance Cardano.Api.SerialiseCBOR.SerialiseAsCBOR (Cardano.Api.Keys.Class.SigningKey Hydra.Crypto.HydraKey)
instance Cardano.Binary.FromCBOR.FromCBOR (Cardano.Api.Keys.Class.SigningKey Hydra.Crypto.HydraKey)
instance Cardano.Binary.ToCBOR.ToCBOR (Cardano.Api.Keys.Class.SigningKey Hydra.Crypto.HydraKey)
instance GHC.Show.Show (Cardano.Api.Keys.Class.SigningKey Hydra.Crypto.HydraKey)
instance GHC.Classes.Eq (Cardano.Api.Keys.Class.SigningKey Hydra.Crypto.HydraKey)
instance Cardano.Api.SerialiseCBOR.SerialiseAsCBOR (Cardano.Api.Keys.Class.VerificationKey Hydra.Crypto.HydraKey)
instance Cardano.Binary.FromCBOR.FromCBOR (Cardano.Api.Keys.Class.VerificationKey Hydra.Crypto.HydraKey)
instance Cardano.Binary.ToCBOR.ToCBOR (Cardano.Api.Keys.Class.VerificationKey Hydra.Crypto.HydraKey)
instance (TypeError ...) => GHC.Classes.Ord (Cardano.Api.Keys.Class.VerificationKey Hydra.Crypto.HydraKey)
instance GHC.Show.Show (Cardano.Api.Keys.Class.VerificationKey Hydra.Crypto.HydraKey)
instance GHC.Classes.Eq (Cardano.Api.Keys.Class.VerificationKey Hydra.Crypto.HydraKey)
instance Data.Typeable.Internal.Typeable a => Cardano.Binary.FromCBOR.FromCBOR (Hydra.Crypto.Signature a)
instance Data.Typeable.Internal.Typeable a => Cardano.Binary.ToCBOR.ToCBOR (Hydra.Crypto.Signature a)
instance GHC.Classes.Eq (Hydra.Crypto.Signature a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hydra.Crypto.MultiSignature a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hydra.Crypto.MultiSignature a)
instance GHC.Base.Monoid (Hydra.Crypto.MultiSignature a)
instance GHC.Base.Semigroup (Hydra.Crypto.MultiSignature a)
instance GHC.Generics.Generic (Hydra.Crypto.MultiSignature a)
instance GHC.Show.Show (Hydra.Crypto.MultiSignature a)
instance GHC.Classes.Eq (Hydra.Crypto.MultiSignature a)
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Crypto.Verified
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Crypto.Verified
instance GHC.Generics.Generic Hydra.Crypto.Verified
instance GHC.Show.Show Hydra.Crypto.Verified
instance GHC.Classes.Eq Hydra.Crypto.Verified
instance (Test.QuickCheck.Arbitrary.Arbitrary a, Cardano.Crypto.Util.SignableRepresentation a) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Crypto.MultiSignature a)
instance GHC.Show.Show (Hydra.Crypto.Signature a)
instance Data.Hashable.Class.Hashable (Hydra.Crypto.Signature a)
instance (Test.QuickCheck.Arbitrary.Arbitrary a, Cardano.Crypto.Util.SignableRepresentation a) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Crypto.Signature a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hydra.Crypto.Signature a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hydra.Crypto.Signature a)
instance Cardano.Api.HasTypeProxy.HasTypeProxy Hydra.Crypto.HydraKey
instance Cardano.Api.SerialiseRaw.SerialiseAsRawBytes (Cardano.Api.Hash.Hash Hydra.Crypto.HydraKey)
instance Cardano.Api.Keys.Class.Key Hydra.Crypto.HydraKey
instance Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Api.Keys.Class.SigningKey Hydra.Crypto.HydraKey)
instance Cardano.Api.SerialiseRaw.SerialiseAsRawBytes (Cardano.Api.Keys.Class.SigningKey Hydra.Crypto.HydraKey)
instance Cardano.Api.SerialiseTextEnvelope.HasTextEnvelope (Cardano.Api.Keys.Class.SigningKey Hydra.Crypto.HydraKey)
instance Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Api.Keys.Class.VerificationKey Hydra.Crypto.HydraKey)
instance Cardano.Api.SerialiseRaw.SerialiseAsRawBytes (Cardano.Api.Keys.Class.VerificationKey Hydra.Crypto.HydraKey)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.Keys.Class.VerificationKey Hydra.Crypto.HydraKey)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Api.Keys.Class.VerificationKey Hydra.Crypto.HydraKey)
instance Cardano.Api.SerialiseTextEnvelope.HasTextEnvelope (Cardano.Api.Keys.Class.VerificationKey Hydra.Crypto.HydraKey)

module Hydra.Ledger
class (Eq tx, Show tx, Typeable tx, Arbitrary tx, FromCBOR tx, ToCBOR tx, FromJSON tx, ToJSON tx, Eq (TxIdType tx), Ord (TxIdType tx), Show (TxIdType tx), Typeable (TxIdType tx), Arbitrary (TxIdType tx), FromJSON (TxIdType tx), ToJSON (TxIdType tx), FromCBOR (TxIdType tx), ToCBOR (TxIdType tx), FromJSONKey (TxIdType tx), ToJSONKey (TxIdType tx), Eq (UTxOType tx), Show (UTxOType tx), Arbitrary (UTxOType tx), FromJSON (UTxOType tx), Monoid (UTxOType tx), ToJSON (UTxOType tx), FromCBOR (UTxOType tx), ToCBOR (UTxOType tx)) => IsTx tx where {
    type UTxOType tx;
    type TxIdType tx;
    type ValueType tx;
}
txId :: IsTx tx => tx -> TxIdType tx
balance :: IsTx tx => UTxOType tx -> ValueType tx

-- | Hash a utxo set to be able to sign (off-chain) and verify it
--   (on-chain).
hashUTxO :: IsTx tx => UTxOType tx -> ByteString

-- | A generic description for a chain slot all implementions need to use.
newtype ChainSlot
ChainSlot :: Natural -> ChainSlot

-- | Get the next chain slot. Use this instead of giving <a>Enum</a> or
--   <a>Num</a> instances to <a>ChainSlot</a>.
nextChainSlot :: ChainSlot -> ChainSlot

-- | An abstract interface for a <a>Ledger</a>. Allows to define mock /
--   simpler implementation for testing as well as limiting feature-envy
--   from the business logic by forcing a closed interface.
data Ledger tx
Ledger :: (ChainSlot -> UTxOType tx -> [tx] -> Either (tx, ValidationError) (UTxOType tx)) -> UTxOType tx -> Ledger tx

-- | Apply a set of transaction to a given UTXO set. Returns the new UTXO
--   or validation failures returned from the ledger. TODO:
--   <a>ValidationError</a> should also include the UTxO, which is not
--   necessarily the same as the given UTxO after some transactions
[applyTransactions] :: Ledger tx -> ChainSlot -> UTxOType tx -> [tx] -> Either (tx, ValidationError) (UTxOType tx)

-- | Generates an initial UTXO set. This is only temporary as it does not
--   allow to initialize the UTXO.
--   
--   TODO: This seems redundant with the `Monoid (UTxOType tx)` constraints
--   coming with <a>IsTx</a>. We probably want to dry this out.
[initUTxO] :: Ledger tx -> UTxOType tx
canApply :: Ledger tx -> ChainSlot -> UTxOType tx -> tx -> ValidationResult

-- | Either valid or an error which we get from the ledger-specs tx
--   validation.
data ValidationResult
Valid :: ValidationResult
Invalid :: ValidationError -> ValidationResult
newtype ValidationError
ValidationError :: Text -> ValidationError
[reason] :: ValidationError -> Text
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Ledger.ChainSlot
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Ledger.ChainSlot
instance GHC.Num.Num Hydra.Ledger.ChainSlot
instance GHC.Generics.Generic Hydra.Ledger.ChainSlot
instance GHC.Show.Show Hydra.Ledger.ChainSlot
instance GHC.Classes.Eq Hydra.Ledger.ChainSlot
instance GHC.Classes.Ord Hydra.Ledger.ChainSlot
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Ledger.ValidationError
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Ledger.ValidationError
instance GHC.Generics.Generic Hydra.Ledger.ValidationError
instance GHC.Show.Show Hydra.Ledger.ValidationError
instance GHC.Classes.Eq Hydra.Ledger.ValidationError
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Ledger.ValidationResult
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Ledger.ValidationResult
instance GHC.Generics.Generic Hydra.Ledger.ValidationResult
instance GHC.Show.Show Hydra.Ledger.ValidationResult
instance GHC.Classes.Eq Hydra.Ledger.ValidationResult
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Ledger.ValidationError
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Ledger.ChainSlot

module Hydra.API.ClientInput
data ClientInput tx
Init :: ClientInput tx
Abort :: ClientInput tx
NewTx :: tx -> ClientInput tx
[transaction] :: ClientInput tx -> tx
GetUTxO :: ClientInput tx
Close :: ClientInput tx
Contest :: ClientInput tx
Fanout :: ClientInput tx
instance GHC.Generics.Generic (Hydra.API.ClientInput.ClientInput tx)
instance Hydra.Ledger.IsTx tx => GHC.Classes.Eq (Hydra.API.ClientInput.ClientInput tx)
instance Hydra.Ledger.IsTx tx => GHC.Show.Show (Hydra.API.ClientInput.ClientInput tx)
instance Hydra.Ledger.IsTx tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.API.ClientInput.ClientInput tx)
instance Hydra.Ledger.IsTx tx => Data.Aeson.Types.FromJSON.FromJSON (Hydra.API.ClientInput.ClientInput tx)
instance Test.QuickCheck.Arbitrary.Arbitrary tx => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.API.ClientInput.ClientInput tx)


-- | Utilities to building transactions on top of the cardano-api.
module Hydra.Ledger.Cardano.Builder

-- | Construct a transction from a builder. It is said <tt>unsafe</tt>
--   because the underlying implementation will perform some sanity check
--   on a transaction; for example, check that it has at least one input,
--   that no outputs are negatives and whatnot.
--   
--   We use the builder only internally for on-chain transaction crafted in
--   the context of Hydra.
unsafeBuildTransaction :: HasCallStack => TxBodyContent BuildTx -> Tx

-- | A runtime exception to capture (programmer) failures when building
--   transactions. This should never happened in practice (famous last
--   words...)!
data InvalidTransactionException
InvalidTransactionException :: TxBodyError -> TxBodyContent BuildTx -> InvalidTransactionException
[txBodyError] :: InvalidTransactionException -> TxBodyError
[builder] :: InvalidTransactionException -> TxBodyContent BuildTx

-- | An empty <a>TxBodyContent</a> with all empty/zero values to be
--   extended using record updates.
--   
--   NOTE: <tt>makeTransactionBody</tt> throws when one tries to build a
--   transaction with scripts but no collaterals. This is unfortunate
--   because collaterals are currently added after by our integrated
--   wallet.
--   
--   Similarly, <tt>makeTransactionBody</tt> throws when building a
--   transaction with scripts and no protocol parameters (needed to compute
--   the script integrity hash). This is also added by our wallet at the
--   moment and this ugly work-around will be removed eventually (related
--   item <a>215</a>.
--   
--   So we currently bypass this by having default but seemingly
--   innofensive values for collaterals and protocol params in the
--   <a>empty</a> value
emptyTxBody :: TxBodyContent BuildTx

-- | Add new inputs to an ongoing builder.
addInputs :: TxIns BuildTx -> TxBodyContent BuildTx -> TxBodyContent BuildTx
addReferenceInputs :: [TxIn] -> TxBodyContent BuildTx -> TxBodyContent BuildTx

-- | Like <a>addInputs</a> but only for vk inputs which requires no
--   additional data.
addVkInputs :: [TxIn] -> TxBodyContent BuildTx -> TxBodyContent BuildTx

-- | Append new outputs to an ongoing builder.
addOutputs :: [TxOut CtxTx] -> TxBodyContent BuildTx -> TxBodyContent BuildTx

-- | Add extra required key witnesses to a transaction.
addExtraRequiredSigners :: [Hash PaymentKey] -> TxBodyContent BuildTx -> TxBodyContent BuildTx

-- | Mint tokens with given plutus minting script and redeemer.
mintTokens :: ToScriptData redeemer => PlutusScript -> redeemer -> [(AssetName, Quantity)] -> TxBodyContent BuildTx -> TxBodyContent BuildTx

-- | Burn tokens with given plutus minting script and redeemer. This is
--   really just <a>mintTokens</a> with negated <a>Quantity</a>.
burnTokens :: ToScriptData redeemer => PlutusScript -> redeemer -> [(AssetName, Quantity)] -> TxBodyContent BuildTx -> TxBodyContent BuildTx

-- | Set the upper validity bound for this transaction to some
--   <a>SlotNo</a>.
setValidityUpperBound :: SlotNo -> TxBodyContent BuildTx -> TxBodyContent BuildTx

-- | Set the lower validity bound for this transaction to some
--   <a>SlotNo</a>.
setValidityLowerBound :: SlotNo -> TxBodyContent BuildTx -> TxBodyContent BuildTx
instance GHC.Show.Show Hydra.Ledger.Cardano.Builder.InvalidTransactionException
instance GHC.Exception.Type.Exception Hydra.Ledger.Cardano.Builder.InvalidTransactionException

module Hydra.Ledger.Cardano.Configuration
data GlobalsTranslationException
GlobalsTranslationException :: GlobalsTranslationException
readJsonFileThrow :: (Value -> Parser a) -> FilePath -> IO a

-- | Create new L2 ledger <a>Globals</a> from <a>GenesisParameters</a>.
--   
--   Throws at least <a>GlobalsTranslationException</a>
newGlobals :: MonadThrow m => GenesisParameters ShelleyEra -> m Globals
protocolParametersFromJson :: Value -> Parser ProtocolParameters

-- | Create a new ledger env from given protocol parameters.
newLedgerEnv :: PParams LedgerEra -> LedgerEnv LedgerEra
data Globals
data LedgerEnv era
instance GHC.Show.Show Hydra.Ledger.Cardano.Configuration.GlobalsTranslationException
instance GHC.Classes.Eq Hydra.Ledger.Cardano.Configuration.GlobalsTranslationException
instance GHC.Exception.Type.Exception Hydra.Ledger.Cardano.Configuration.GlobalsTranslationException


-- | Simplified interface to phase-2 validation of transactions, eg.
--   evaluation of Plutus scripts.
--   
--   The <a>evaluateTx</a> function simplifies the call to ledger and
--   plutus providing an <a>EvaluationReport</a> using pre-canned
--   <tt>ProtocolParameters</tt>. This should only be used for
--   <i>testing</i> or <i>benchmarking</i> purpose as the real evaluation
--   parameters are set when the Hydra node starts.
--   
--   <b>NOTE</b>: The reason this module is here instead of part of `test/`
--   directory is to be used in <tt>tx-cost</tt> executable.
module Hydra.Ledger.Cardano.Evaluate

-- | Thin wrapper around <a>evaluateTransactionExecutionUnits</a>, using
--   fixtures from this module for <a>systemStart</a>, <tt>eraHistory</tt>
--   and <a>pparams</a>.
--   
--   Additionally, this function checks the overall execution units are not
--   exceeding <a>maxTxExecutionUnits</a>.
evaluateTx :: Tx -> UTxO -> Either EvaluationError EvaluationReport

-- | Like <a>evaluateTx</a>, but with a configurable maximum transaction
--   <a>ExecutionUnits</a>.
evaluateTx' :: ExecutionUnits -> Tx -> UTxO -> Either EvaluationError EvaluationReport

-- | Check the budget used by provided <a>EvaluationReport</a> does not
--   exceed given maximum <a>ExecutionUnits</a>.
checkBudget :: ExecutionUnits -> EvaluationReport -> Either EvaluationError EvaluationReport

-- | Errors returned by <a>evaluateTx</a> extending the upstream
--   <a>TransactionValidityError</a> with additional cases.
data EvaluationError
TransactionBudgetOverspent :: ExecutionUnits -> ExecutionUnits -> EvaluationError
[used] :: EvaluationError -> ExecutionUnits
[available] :: EvaluationError -> ExecutionUnits
TransactionInvalid :: TransactionValidityError -> EvaluationError
PParamsConversion :: ProtocolParametersConversionError -> EvaluationError

-- | Evaluation result for each of the included scripts. Either they failed
--   evaluation or used a number of <a>ExecutionUnits</a>.
type EvaluationReport = (Map ScriptWitnessIndex (Either ScriptExecutionError ExecutionUnits))
renderEvaluationReportFailures :: EvaluationReport -> Text

-- | Get the total used <a>ExecutionUnits</a> from an
--   <a>EvaluationReport</a>. Useful to further process the result of
--   <a>evaluateTx</a>.
usedExecutionUnits :: EvaluationReport -> ExecutionUnits

-- | Estimate minimum fee for given transaction and evaluated redeemers.
--   Instead of using the budgets from the transaction (which are usually
--   set to 0 until balancing), this directly computes the fee from
--   transaction size and the units of the <a>EvaluationReport</a>. Note
--   that this function only provides a rough estimate using this modules'
--   <a>pparams</a> and likely under-estimates cost as we have no witnesses
--   on this <a>Tx</a>.
estimateMinFee :: Tx -> EvaluationReport -> Lovelace

-- | Like <a>evaluateTx</a>, but instead of actual evaluation, return the
--   flat-encoded, fully applied scripts for each redeemer to be evaluated
--   externally by <tt>uplc</tt>. Use input format "flat-namedDeBruijn".
--   This can be used to gather profiling information.
--   
--   NOTE: This assumes we use <tt>Babbage</tt> and only <a>PlutusV2</a>
--   scripts are used.
prepareTxScripts :: Tx -> UTxO -> Either String [ByteString]

-- | Current (2023-04-12) mainchain protocol parameters. XXX: Avoid
--   specifiying not required parameters here (e.g. max block units should
--   not matter). XXX: Load and use mainnet parameters from a file which we
--   can easily review to be in sync with mainnet.
pparams :: PParams LedgerEra
maxTxSize :: Natural

-- | Max transaction execution unit budget of the current <a>pparams</a>.
maxTxExecutionUnits :: ExecutionUnits

-- | Max memory and cpu units of the current <a>pparams</a>.
maxMem :: Natural

-- | Max memory and cpu units of the current <a>pparams</a>.
maxCpu :: Natural

-- | An artifical <a>EpochInfo</a> comprised by a single never ending
--   (forking) era, with fixed <a>epochSize</a> and <a>slotLength</a>.
epochInfo :: Monad m => EpochInfo m

-- | An era history with a single era which will end at some point.
--   
--   A "real" <a>EraHistory</a> received from the cardano-node will have
--   the <a>eraEnd</a> at a known or earliest possible end of the current
--   era + a safe zone.
--   
--   See <a>EraParams</a> for details.
--   
--   NOTE: This era is using not so realistic epoch sizes of 1 and sets a
--   slot length of 1
eraHistoryWithHorizonAt :: SlotNo -> EraHistory CardanoMode
epochSize :: EpochSize
slotLength :: SlotLength
systemStart :: SystemStart
genPointInTime :: Gen (SlotNo, UTCTime)

-- | Parameter here is the contestation period (cp) so we need to generate
--   start (tMin) and end (tMax) tx validity bound such that their
--   difference is not higher than the cp. Returned slots are tx validity
--   bounds
genValidityBoundsFromContestationPeriod :: ContestationPeriod -> Gen (SlotNo, (SlotNo, UTCTime))
genPointInTimeBefore :: UTCTime -> Gen (SlotNo, UTCTime)
genPointInTimeAfter :: UTCTime -> Gen (SlotNo, UTCTime)

-- | Using hard-coded systemStart and slotLength, do not use in production!
slotNoFromUTCTime :: UTCTime -> SlotNo

-- | Using hard-coded defaults above. Fails for slots past epoch
--   boundaries.
slotNoToUTCTime :: HasCallStack => SlotNo -> UTCTime

-- | Current (2023-08-04) mainnet PlutusV2 cost model.
plutusV2CostModel :: CostModel
instance GHC.Show.Show Hydra.Ledger.Cardano.Evaluate.EvaluationError


-- | Module to deal with time in direct cardano chain layer. Defines the
--   type for a <a>PointInTime</a> and a means to acquire one via a
--   <a>TimeHandle</a> and <a>queryTimeHandle</a>.
module Hydra.Chain.Direct.TimeHandle
type PointInTime = (SlotNo, UTCTime)
data TimeHandle
TimeHandle :: Either Text PointInTime -> (UTCTime -> Either Text SlotNo) -> (SlotNo -> Either Text UTCTime) -> TimeHandle

-- | Get the current <a>PointInTime</a>
[currentPointInTime] :: TimeHandle -> Either Text PointInTime

-- | Lookup slot number given a <a>UTCTime</a>. This will fail if the time
--   is outside the "safe zone".
[slotFromUTCTime] :: TimeHandle -> UTCTime -> Either Text SlotNo

-- | Convert a slot number to a <a>UTCTime</a> using the stored epoch info.
--   This will fail if the slot is outside the "safe zone".
[slotToUTCTime] :: TimeHandle -> SlotNo -> Either Text UTCTime
data TimeHandleParams
TimeHandleParams :: SystemStart -> EraHistory CardanoMode -> SlotNo -> SlotNo -> TimeHandleParams
[systemStart] :: TimeHandleParams -> SystemStart
[eraHistory] :: TimeHandleParams -> EraHistory CardanoMode
[horizonSlot] :: TimeHandleParams -> SlotNo
[currentSlot] :: TimeHandleParams -> SlotNo

-- | Generate consistent values for <a>SystemStart</a> and
--   <a>EraHistory</a> which has a horizon at the returned SlotNo as well
--   as some UTCTime before that
genTimeParams :: Gen TimeHandleParams

-- | Construct a time handle using current slot and given chain parameters.
--   See <a>queryTimeHandle</a> to create one by querying a cardano-node.
mkTimeHandle :: HasCallStack => SlotNo -> SystemStart -> EraHistory CardanoMode -> TimeHandle

-- | Query node for system start and era history before constructing a
--   <a>TimeHandle</a> using the slot at the tip of the network.
queryTimeHandle :: NetworkId -> SocketPath -> IO TimeHandle
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Chain.Direct.TimeHandle.TimeHandle


-- | Orphans ToJSON/FromJSON instances on ledger types used by
--   Hydra.Ledger.Cardano to have JSON representations for various types.
--   
--   XXX: The ledger team notified that we should be using lenses going
--   forward.
module Hydra.Ledger.Cardano.Json
decodeAddress :: Crypto crypto => Text -> Parser (Addr crypto)
rewardAcntToText :: RewardAcnt crypto -> Text
rewardAcntFromText :: Crypto crypto => Text -> Maybe (RewardAcnt crypto)
safeHashToText :: SafeHash crypto any -> Text
safeHashFromText :: (Crypto crypto, MonadFail m) => Text -> m (SafeHash crypto any)
onlyIf :: ToJSON a => (a -> Bool) -> Key -> a -> [Pair]
isOpenInterval :: ValidityInterval -> Bool

-- | Parse a hex-encoded CBOR value in given <tt>era</tt>.
parseHexEncodedCbor :: forall era a. (Era era, DecCBOR a) => Text -> Value -> Parser a

-- | Parse a hex-encoded, annotated CBOR value in given <tt>era</tt>.
parseHexEncodedCborAnnotated :: forall era a. (Era era, DecCBOR (Annotator a)) => Text -> Value -> Parser a
instance Cardano.Ledger.Core.Era.Era era => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Alonzo.TxAuxData.AlonzoTxAuxData era)
instance Cardano.Ledger.Core.Era.Era era => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Alonzo.TxAuxData.AlonzoTxAuxData era)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.AuxiliaryData.AuxiliaryDataHash crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Keys.Bootstrap.BootstrapWitness crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Keys.Bootstrap.BootstrapWitness crypto)
instance Cardano.Ledger.Core.Era.Era era => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.TxCert.ShelleyTxCert era)
instance (Cardano.Ledger.Shelley.TxCert.ShelleyEraTxCert era, Cardano.Ledger.Core.TxCert.TxCert era GHC.Types.~ Cardano.Ledger.Shelley.TxCert.ShelleyTxCert era) => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Shelley.TxCert.ShelleyTxCert era)
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Alonzo.Tx.IsValid
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.Alonzo.Tx.IsValid
instance Cardano.Ledger.Core.Era.Era era => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Alonzo.TxWits.Redeemers era)
instance Cardano.Ledger.Core.Era.Era era => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Alonzo.TxWits.Redeemers era)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSONKey (Cardano.Ledger.SafeHash.SafeHash crypto any)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.FromJSON.FromJSONKey (Cardano.Ledger.SafeHash.SafeHash crypto any)
instance Cardano.Ledger.Core.Era.Era era => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Alonzo.Scripts.AlonzoScript era)
instance Cardano.Ledger.Core.Era.Era era => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Allegra.Scripts.Timelock era)
instance Cardano.Ledger.Core.Era.Era era => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Allegra.Scripts.Timelock era)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Babbage.TxBody.BabbageTxBody Hydra.Cardano.Api.Prelude.LedgerEra)
instance (Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR a, Data.Aeson.Types.FromJSON.FromJSON a) => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Binary.Decoding.Sized.Sized a)
instance (Cardano.Ledger.Babbage.Core.BabbageEraTxBody era, Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Mary.Value.MaryValue (Cardano.Ledger.Core.Era.EraCrypto era)), Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Core.TxAuxData era), Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Core.TxOut era), Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Core.TxCert.TxCert era), Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.TxIn.TxIn (Cardano.Ledger.Core.Era.EraCrypto era)), Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Babbage.TxOut.BabbageTxOut era)) => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Babbage.TxBody.BabbageTxBody era)
instance (Cardano.Ledger.Core.Era.Era era, Cardano.Ledger.Crypto.Crypto (Cardano.Ledger.Core.Era.EraCrypto era)) => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Alonzo.TxWits.TxDats era)
instance (Cardano.Ledger.Crypto.Crypto (Cardano.Ledger.Core.Era.EraCrypto era), Cardano.Ledger.Core.Era.Era era) => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Alonzo.TxWits.TxDats era)
instance Cardano.Ledger.Core.Era.Era era => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Alonzo.Scripts.Data.Data era)
instance Cardano.Ledger.Core.Era.Era era => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Alonzo.Scripts.Data.Data era)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.TxIn.TxIn Cardano.Ledger.Crypto.StandardCrypto)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Babbage.TxOut.BabbageTxOut Hydra.Cardano.Api.Prelude.LedgerEra)
instance (Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Core.Script era), Cardano.Ledger.Core.Script era GHC.Types.~ Cardano.Ledger.Alonzo.Scripts.AlonzoScript era, Cardano.Ledger.Core.Era.Era era) => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Alonzo.TxWits.AlonzoTxWits era)
instance (Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Core.Script era), Cardano.Ledger.Core.Script era GHC.Types.~ Cardano.Ledger.Alonzo.Scripts.AlonzoScript era, Cardano.Ledger.Core.Era.Era era) => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Alonzo.TxWits.AlonzoTxWits era)
instance (Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Core.TxBody era), Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Core.TxAuxData era), Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Core.TxWits era), Cardano.Ledger.Core.EraTxBody era, Cardano.Ledger.Core.Era.Era era) => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Alonzo.Tx.AlonzoTx era)
instance (Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Core.TxBody era), Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Core.TxWits era), Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Core.TxAuxData era), Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Binary.Decoding.Annotated.Annotator (Cardano.Ledger.Core.TxBody era)), Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Binary.Decoding.Annotated.Annotator (Cardano.Ledger.Core.TxWits era)), Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Binary.Decoding.Annotated.Annotator (Cardano.Ledger.Core.TxAuxData era)), Cardano.Ledger.Core.Era.Era era) => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Alonzo.Tx.AlonzoTx era)
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Allegra.Scripts.ValidityInterval
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.Allegra.Scripts.ValidityInterval
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Mary.Value.MaryValue Cardano.Ledger.Crypto.StandardCrypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Address.Withdrawals crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Address.Withdrawals crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Keys.WitVKey.WitVKey 'Cardano.Ledger.Keys.Witness crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Keys.WitVKey.WitVKey 'Cardano.Ledger.Keys.Witness crypto)

module Hydra.Ledger.Cardano

-- | Use the cardano-ledger as an in-hydra <a>Ledger</a>.
cardanoLedger :: Globals -> LedgerEnv LedgerEra -> Ledger Tx

-- | Simple conversion from a generic slot to a specific local one.
fromChainSlot :: ChainSlot -> SlotNo

-- | Create a zero-fee, payment cardano transaction.
mkSimpleTx :: (TxIn, TxOut CtxUTxO) -> (AddressInEra, Value) -> SigningKey PaymentKey -> Either TxBodyError Tx

-- | Create a zero-fee, payment cardano transaction with validity range.
mkRangedTx :: (TxIn, TxOut CtxUTxO) -> (AddressInEra, Value) -> SigningKey PaymentKey -> (Maybe TxValidityLowerBound, Maybe TxValidityUpperBound) -> Either TxBodyError Tx
genSigningKey :: Gen (SigningKey PaymentKey)
genVerificationKey :: Gen (VerificationKey PaymentKey)
genKeyPair :: Gen (VerificationKey PaymentKey, SigningKey PaymentKey)

-- | Generates a sequence of simple "transfer" transactions for a single
--   key. The kind of transactions produced by this generator is very
--   limited, see <a>generateOneTransfer</a>.
genSequenceOfSimplePaymentTransactions :: Gen (UTxO, [Tx])
genFixedSizeSequenceOfSimplePaymentTransactions :: Int -> Gen (UTxO, [Tx])
generateOneTransfer :: NetworkId -> (UTxO, (VerificationKey PaymentKey, SigningKey PaymentKey), [Tx]) -> Int -> Gen (UTxO, (VerificationKey PaymentKey, SigningKey PaymentKey), [Tx])
genOutput :: forall ctx. VerificationKey PaymentKey -> Gen (TxOut ctx)

-- | Generate an ada-only <a>TxOut</a> payed to an arbitrary public key.
genTxOutAdaOnly :: VerificationKey PaymentKey -> Gen (TxOut ctx)

-- | Generate a fixed size UTxO with ada-only outputs.
genUTxOAdaOnlyOfSize :: Int -> Gen UTxO

-- | Generate <tt>Babbage</tt> era <a>UTxO'</a>, which may contain
--   arbitrary assets in <a>TxOut</a>s addressed to public keys *and*
--   scripts. NOTE: This is not reducing size when generating assets in
--   <a>TxOut</a>s, so will end up regularly with 300+ assets with
--   generator size 30. NOTE: The Arbitrary TxIn instance from the ledger
--   is producing colliding values, so we replace them.
genUTxOAlonzo :: Gen UTxO

-- | Generate a <tt>Babbage</tt> era <a>UTxO'</a> with given number of
--   outputs. See also <a>genTxOut</a>.
genUTxOSized :: Int -> Gen UTxO

-- | Genereate a <a>UTxO'</a> with a single entry using given <a>TxOut</a>
--   generator.
genUTxO1 :: Gen (TxOut CtxUTxO) -> Gen UTxO

-- | Generate a <tt>Babbage</tt> era <a>TxOut</a>, which may contain
--   arbitrary assets addressed to public keys and scripts, as well as
--   datums.
--   
--   NOTE: This generator does * not produce byron addresses as most of the
--   cardano ecosystem dropped support for that (including plutus), * not
--   produce reference scripts as they are not fully "visible" from plutus,
--   * replace stake pointers with null references as nobody uses that.
genTxOut :: Gen (TxOut ctx)

-- | Generate a <a>TxOut</a> with a byron address. This is usually not
--   supported by Hydra or Plutus.
genTxOutByron :: Gen (TxOut ctx)

-- | Generate a <a>TxOut</a> with a reference script. The standard
--   <a>genTxOut</a> is not including reference scripts, use this generator
--   if you are interested in these cases.
genTxOutWithReferenceScript :: Gen (TxOut ctx)

-- | Generate utxos owned by the given cardano key.
genUTxOFor :: VerificationKey PaymentKey -> Gen UTxO

-- | Generate a single UTXO owned by <tt>vk</tt>.
genOneUTxOFor :: VerificationKey PaymentKey -> Gen UTxO

-- | NOTE: See note on <a>mkVkAddress</a> about <a>NetworkId</a>.
genAddressInEra :: NetworkId -> Gen AddressInEra
genValue :: Gen Value

-- | Generate UTXO entries that do not contain any assets. Useful to test /
--   measure cases where
genAdaOnlyUTxO :: Gen UTxO
adaOnly :: TxOut CtxUTxO -> TxOut CtxUTxO

-- | Generate "simplified" UTXO, ie. without some of the complexities
--   required for backward-compatibility and obscure features.
genUTxOWithSimplifiedAddresses :: Gen UTxO
shrinkUTxO :: UTxO -> [UTxO]
shrinkValue :: Value -> [Value]
data ShelleyGenesis c
ShelleyGenesis :: !UTCTime -> !Word32 -> !Network -> !PositiveUnitInterval -> !Word64 -> !EpochSize -> !Word64 -> !Word64 -> !NominalDiffTimeMicro -> !Word64 -> !Word64 -> !PParams (ShelleyEra c) -> !Map (KeyHash 'Genesis c) (GenDelegPair c) -> ListMap (Addr c) Coin -> ShelleyGenesisStaking c -> ShelleyGenesis c
[sgSystemStart] :: ShelleyGenesis c -> !UTCTime
[sgNetworkMagic] :: ShelleyGenesis c -> !Word32
[sgNetworkId] :: ShelleyGenesis c -> !Network
[sgActiveSlotsCoeff] :: ShelleyGenesis c -> !PositiveUnitInterval
[sgSecurityParam] :: ShelleyGenesis c -> !Word64
[sgEpochLength] :: ShelleyGenesis c -> !EpochSize
[sgSlotsPerKESPeriod] :: ShelleyGenesis c -> !Word64
[sgMaxKESEvolutions] :: ShelleyGenesis c -> !Word64
[sgSlotLength] :: ShelleyGenesis c -> !NominalDiffTimeMicro
[sgUpdateQuorum] :: ShelleyGenesis c -> !Word64
[sgMaxLovelaceSupply] :: ShelleyGenesis c -> !Word64
[sgProtocolParams] :: ShelleyGenesis c -> !PParams (ShelleyEra c)
[sgGenDelegs] :: ShelleyGenesis c -> !Map (KeyHash 'Genesis c) (GenDelegPair c)
[sgInitialFunds] :: ShelleyGenesis c -> ListMap (Addr c) Coin
[sgStaking] :: ShelleyGenesis c -> ShelleyGenesisStaking c
type Tx = Tx Era
instance Hydra.Ledger.IsTx Hydra.Cardano.Api.Tx
instance Cardano.Binary.ToCBOR.ToCBOR Hydra.Cardano.Api.Tx
instance Cardano.Binary.FromCBOR.FromCBOR Hydra.Cardano.Api.Tx
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Cardano.Api.Tx
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Cardano.Api.Tx
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Cardano.Api.Tx
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Api.Value.AssetName
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Api.TxIn.TxId
instance Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Cardano.Api.TxOut Cardano.Api.TxBody.CtxUTxO)
instance Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Api.Keys.Class.VerificationKey Cardano.Api.Keys.Shelley.PaymentKey)
instance Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Api.Hash.Hash Cardano.Api.Keys.Shelley.PaymentKey)
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Api.UTxO.UTxO
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Api.UTxO.UTxO
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Api.UTxO.UTxO


-- | A data-type to keep track of reference Hydra scripts published
--   on-chain, and needed to construct transactions leveraging reference
--   inputs.
module Hydra.Chain.Direct.ScriptRegistry

-- | Hydra scripts published as reference scripts at these UTxO.
data ScriptRegistry
ScriptRegistry :: (TxIn, TxOut CtxUTxO) -> (TxIn, TxOut CtxUTxO) -> (TxIn, TxOut CtxUTxO) -> ScriptRegistry
[initialReference] :: ScriptRegistry -> (TxIn, TxOut CtxUTxO)
[commitReference] :: ScriptRegistry -> (TxIn, TxOut CtxUTxO)
[headReference] :: ScriptRegistry -> (TxIn, TxOut CtxUTxO)
genScriptRegistry :: Gen ScriptRegistry
data NewScriptRegistryException
MissingScript :: Text -> ScriptHash -> Set ScriptHash -> NewScriptRegistryException
[scriptName] :: NewScriptRegistryException -> Text
[scriptHash] :: NewScriptRegistryException -> ScriptHash
[discoveredScripts] :: NewScriptRegistryException -> Set ScriptHash

-- | Create a script registry from a UTxO containing outputs with reference
--   scripts. This will return <a>Nothing</a> if one or all of the
--   references could not be found.
newScriptRegistry :: UTxO -> Either NewScriptRegistryException ScriptRegistry

-- | Get the UTxO that corresponds to a script registry.
--   
--   <ul>
--   <li>*Property**:newScriptRegistry (registryUTxO r) === Just r</li>
--   </ul>
registryUTxO :: ScriptRegistry -> UTxO

-- | Query for <a>TxIn</a>s in the search for outputs containing all the
--   reference scripts of the <a>ScriptRegistry</a>.
--   
--   This is implemented by repeated querying until we have all necessary
--   reference scripts as we do only know the transaction id, not the
--   indices.
--   
--   NOTE: This is limited to an upper bound of 10 to not query too much
--   before providing an error.
--   
--   NOTE: If this should change, make sure to update the command line
--   help.
--   
--   Can throw at least <a>NewScriptRegistryException</a> on failure.
queryScriptRegistry :: (MonadIO m, MonadThrow m) => NetworkId -> SocketPath -> TxId -> m ScriptRegistry
publishHydraScripts :: NetworkId -> SocketPath -> SigningKey PaymentKey -> IO TxId
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Chain.Direct.ScriptRegistry.ScriptRegistry
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Chain.Direct.ScriptRegistry.ScriptRegistry
instance GHC.Generics.Generic Hydra.Chain.Direct.ScriptRegistry.ScriptRegistry
instance GHC.Show.Show Hydra.Chain.Direct.ScriptRegistry.ScriptRegistry
instance GHC.Classes.Eq Hydra.Chain.Direct.ScriptRegistry.ScriptRegistry
instance GHC.Show.Show Hydra.Chain.Direct.ScriptRegistry.NewScriptRegistryException
instance GHC.Classes.Eq Hydra.Chain.Direct.ScriptRegistry.NewScriptRegistryException
instance GHC.Exception.Type.Exception Hydra.Chain.Direct.ScriptRegistry.NewScriptRegistryException


-- | Generic Cardano constants for use in testing.
module Hydra.Chain.Direct.Fixture
testNetworkId :: NetworkId
testPolicyId :: PolicyId
testSeedInput :: TxIn

-- | Default environment for the L2 ledger using the fixed L1
--   <a>pparams</a> with zeroed fees and prices. NOTE: This is using still
--   a constant SlotNo = 1.
defaultLedgerEnv :: LedgerEnv LedgerEra
defaultPParams :: PParams LedgerEra
defaultGlobals :: Globals

-- | Current (2023-04-12) mainchain protocol parameters. XXX: Avoid
--   specifiying not required parameters here (e.g. max block units should
--   not matter). XXX: Load and use mainnet parameters from a file which we
--   can easily review to be in sync with mainnet.
pparams :: PParams LedgerEra
systemStart :: SystemStart

-- | An artifical <a>EpochInfo</a> comprised by a single never ending
--   (forking) era, with fixed <a>epochSize</a> and <a>slotLength</a>.
epochInfo :: Monad m => EpochInfo m


-- | Adapter module to the actual logging framework. All Hydra node
--   components implements <i>Structured logging</i> via
--   <a>contra-tracer</a> generic logging framework. All logs are output in
--   <a>JSON</a> in a format which is documented in a <a>JSON-Schema</a>.
module Hydra.Logging
newtype Tracer (m :: Type -> Type) a
Tracer :: (a -> m ()) -> Tracer (m :: Type -> Type) a
[runTracer] :: Tracer (m :: Type -> Type) a -> a -> m ()
natTracer :: (forall x. () => m x -> n x) -> Tracer m s -> Tracer n s
nullTracer :: forall (m :: Type -> Type) a. Applicative m => Tracer m a
traceWith :: Tracer m a -> a -> m ()
class ToObject a
toObject :: ToObject a => TracingVerbosity -> a -> Object
textTransformer :: ToObject a => a -> Object -> Text
data TracingVerbosity
MinimalVerbosity :: TracingVerbosity
NormalVerbosity :: TracingVerbosity
MaximalVerbosity :: TracingVerbosity
data Verbosity
Quiet :: Verbosity
Verbose :: Text -> Verbosity

-- | Provides logging metadata for entries.
data Envelope a
Envelope :: UTCTime -> Int -> Text -> a -> Envelope a
[timestamp] :: Envelope a -> UTCTime
[threadId] :: Envelope a -> Int
[namespace] :: Envelope a -> Text
[message] :: Envelope a -> a

-- | Start logging thread and acquire a <a>Tracer</a>. This tracer will
--   dump all messsages on <tt>stdout</tt>, one message per line, formatted
--   as JSON. This tracer is wrapping <tt>msg</tt> into an <a>Envelope</a>
--   with metadata.
withTracer :: forall m msg a. (MonadIO m, MonadFork m, MonadTime m, ToJSON msg) => Verbosity -> (Tracer m msg -> IO a) -> IO a

-- | Start logging thread acquiring a <a>Tracer</a>, outputting JSON
--   formatted messages to some <a>Handle</a>. This tracer is wrapping
--   <tt>msg</tt> into an <a>Envelope</a> with metadata.
withTracerOutputTo :: forall m msg a. (MonadIO m, MonadFork m, MonadTime m, ToJSON msg) => Handle -> Text -> (Tracer m msg -> IO a) -> IO a

-- | Capture logs and output them to stdout when an exception was raised by
--   the given <tt>action</tt>. This tracer is wrapping <tt>msg</tt> into
--   an <a>Envelope</a> with metadata.
showLogsOnFailure :: (MonadSTM m, MonadCatch m, MonadFork m, MonadTime m, MonadSay m, ToJSON msg) => (Tracer m msg -> m a) -> m a
traceInTVar :: (MonadFork m, MonadTime m, MonadSTM m) => TVar m [Envelope msg] -> Tracer m msg
contramap :: Contravariant f => (a' -> a) -> f a -> f a'
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Logging.Verbosity
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Logging.Verbosity
instance GHC.Generics.Generic Hydra.Logging.Verbosity
instance GHC.Show.Show Hydra.Logging.Verbosity
instance GHC.Classes.Eq Hydra.Logging.Verbosity
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hydra.Logging.Envelope a)
instance GHC.Generics.Generic (Hydra.Logging.Envelope a)
instance GHC.Show.Show a => GHC.Show.Show (Hydra.Logging.Envelope a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hydra.Logging.Envelope a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hydra.Logging.Envelope a)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Logging.Envelope a)


-- | Companion tiny-wallet for the direct chain component. This module
--   provide some useful utilities to tracking the wallet's UTXO, and
--   accessing it
module Hydra.Chain.Direct.Wallet
type Address = Addr StandardCrypto
type TxIn = TxIn StandardCrypto
type TxOut = TxOut LedgerEra

-- | A <a>TinyWallet</a> is a small abstraction of a wallet with basic UTXO
--   management. The wallet is assumed to have only one address, and only
--   one UTXO at that address. It can sign transactions and keeps track of
--   its UTXO behind the scene.
--   
--   The wallet is connecting to the node initially and when asked to
--   <a>$sel:reset:TinyWallet</a>. Otherwise it can be fed blocks via
--   <a>$sel:update:TinyWallet</a> as the chain rolls forward.
data TinyWallet m
TinyWallet :: STM m (Map TxIn TxOut) -> STM m (Maybe TxIn) -> (Tx -> Tx) -> (UTxO -> Tx -> m (Either ErrCoverFee Tx)) -> m () -> (BlockHeader -> [Tx] -> m ()) -> TinyWallet m

-- | Return all known UTxO addressed to this wallet.
[$sel:getUTxO:TinyWallet] :: TinyWallet m -> STM m (Map TxIn TxOut)

-- | Returns the <i>seed input</i> This is the special input needed by
--   <tt>Direct</tt> chain component to initialise a head
[$sel:getSeedInput:TinyWallet] :: TinyWallet m -> STM m (Maybe TxIn)
[$sel:sign:TinyWallet] :: TinyWallet m -> Tx -> Tx
[$sel:coverFee:TinyWallet] :: TinyWallet m -> UTxO -> Tx -> m (Either ErrCoverFee Tx)

-- | Re-initializ wallet against the latest tip of the node and start to
--   ignore <a>$sel:update:TinyWallet</a> calls until reaching that tip.
[$sel:reset:TinyWallet] :: TinyWallet m -> m ()

-- | Update the wallet state given a block and list of txs. May be ignored
--   if wallet is still initializing.
[$sel:update:TinyWallet] :: TinyWallet m -> BlockHeader -> [Tx] -> m ()
data WalletInfoOnChain
WalletInfoOnChain :: Map TxIn TxOut -> PParams LedgerEra -> SystemStart -> EpochInfo (Either Text) -> ChainPoint -> WalletInfoOnChain
[$sel:walletUTxO:WalletInfoOnChain] :: WalletInfoOnChain -> Map TxIn TxOut
[$sel:pparams:WalletInfoOnChain] :: WalletInfoOnChain -> PParams LedgerEra
[$sel:systemStart:WalletInfoOnChain] :: WalletInfoOnChain -> SystemStart
[$sel:epochInfo:WalletInfoOnChain] :: WalletInfoOnChain -> EpochInfo (Either Text)

-- | Latest point on chain the wallet knows of.
[$sel:tip:WalletInfoOnChain] :: WalletInfoOnChain -> ChainPoint
type ChainQuery m = QueryPoint -> Address ShelleyAddr -> m WalletInfoOnChain
watchUTxOUntil :: (Map TxIn TxOut -> Bool) -> TinyWallet IO -> IO (Map TxIn TxOut)

-- | Create a new tiny wallet handle.
newTinyWallet :: Tracer IO TinyWalletLog -> NetworkId -> (VerificationKey PaymentKey, SigningKey PaymentKey) -> ChainQuery IO -> IO (EpochInfo (Either Text)) -> IO (TinyWallet IO)

-- | Apply a block to our wallet. Does nothing if the transaction does not
--   modify the UTXO set, or else, remove consumed utxos and add produced
--   ones.
--   
--   To determine whether a produced output is ours, we apply the given
--   function checking the output's address.
applyTxs :: [Tx] -> (Address -> Bool) -> Map TxIn TxOut -> Map TxIn TxOut
getTxId :: (HashAlgorithm (HASH crypto), HashAnnotated (TxBody (era crypto)) EraIndependentTxBody crypto) => AlonzoTx (era crypto) -> TxId crypto

-- | This are all the error that can happen during coverFee.
data ErrCoverFee
ErrNotEnoughFunds :: ChangeError -> ErrCoverFee
ErrNoFuelUTxOFound :: ErrCoverFee
ErrUnknownInput :: TxIn -> ErrCoverFee
[$sel:input:ErrNotEnoughFunds] :: ErrCoverFee -> TxIn
ErrScriptExecutionFailed :: (RdmrPtr, TransactionScriptFailure LedgerEra) -> ErrCoverFee
[$sel:scriptFailure:ErrNotEnoughFunds] :: ErrCoverFee -> (RdmrPtr, TransactionScriptFailure LedgerEra)
ErrTranslationError :: TranslationError StandardCrypto -> ErrCoverFee
data ChangeError
ChangeError :: Coin -> Coin -> ChangeError
[$sel:inputBalance:ChangeError] :: ChangeError -> Coin
[$sel:outputBalance:ChangeError] :: ChangeError -> Coin

-- | Cover fee for a transaction body using the given UTXO set. This
--   calculate necessary fees and augments inputs <i> outputs </i>
--   collateral accordingly to cover for the transaction cost and get the
--   change back.
--   
--   TODO: The fee calculation is currently very dumb and static. XXX: All
--   call sites of this function use cardano-api types
coverFee_ :: PParams LedgerEra -> SystemStart -> EpochInfo (Either Text) -> Map TxIn TxOut -> Map TxIn TxOut -> AlonzoTx LedgerEra -> Either ErrCoverFee (AlonzoTx LedgerEra)
findLargestUTxO :: Map TxIn TxOut -> Maybe (TxIn, TxOut)

-- | Estimate cost of script executions on the transaction. This is only an
--   estimates because the transaction isn't sealed at this point and
--   adding new elements to it like change outputs or script integrity hash
--   may increase that cost a little.
estimateScriptsCost :: PParams LedgerEra -> SystemStart -> EpochInfo (Either Text) -> Map TxIn TxOut -> AlonzoTx LedgerEra -> Either ErrCoverFee (Map RdmrPtr ExUnits)
data TinyWalletLog
BeginInitialize :: TinyWalletLog
EndInitialize :: UTxO -> ChainPoint -> TinyWalletLog
[$sel:initialUTxO:BeginInitialize] :: TinyWalletLog -> UTxO
[$sel:tip:BeginInitialize] :: TinyWalletLog -> ChainPoint
BeginUpdate :: ChainPoint -> TinyWalletLog
[$sel:point:BeginInitialize] :: TinyWalletLog -> ChainPoint
EndUpdate :: UTxO -> TinyWalletLog
[$sel:newUTxO:BeginInitialize] :: TinyWalletLog -> UTxO
SkipUpdate :: ChainPoint -> TinyWalletLog
[$sel:point:BeginInitialize] :: TinyWalletLog -> ChainPoint
instance GHC.Show.Show Hydra.Chain.Direct.Wallet.ChangeError
instance GHC.Show.Show Hydra.Chain.Direct.Wallet.ErrCoverFee
instance GHC.Show.Show Hydra.Chain.Direct.Wallet.TinyWalletLog
instance GHC.Generics.Generic Hydra.Chain.Direct.Wallet.TinyWalletLog
instance GHC.Classes.Eq Hydra.Chain.Direct.Wallet.TinyWalletLog
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Chain.Direct.Wallet.TinyWalletLog
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Chain.Direct.Wallet.TinyWalletLog
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Chain.Direct.Wallet.TinyWalletLog


-- | Asynchronous messaging interface to the Hydra Network, e.g to other
--   Hydra nodes.
--   
--   Concrete implementations are provided by submodules. Import those
--   instead of this one if interested in actually configuring and running
--   a real network layer.
--   
--   Incoming and outgoing messages are modelled as <tt>Message</tt> data
--   type.
module Hydra.Network

-- | Handle to interface with the hydra network and send messages "off
--   chain".
newtype Network m msg
Network :: (msg -> m ()) -> Network m msg

-- | Send a <tt>msg</tt> to the whole hydra network.
[broadcast] :: Network m msg -> msg -> m ()

-- | A type tying both inbound and outbound messages sending in a single
--   <i>Component</i>.
type NetworkComponent m msg a = NetworkCallback msg m -> (Network m msg -> m a) -> m a

-- | Handle to interface for inbound messages.
type NetworkCallback msg m = msg -> m ()
data IP
data Host
Host :: Text -> PortNumber -> Host
[hostname] :: Host -> Text
[port] :: Host -> PortNumber
newtype NodeId
NodeId :: Text -> NodeId
[nodeId] :: NodeId -> Text
showHost :: Host -> String
readHost :: MonadFail m => String -> m Host
data PortNumber
readPort :: MonadFail m => String -> m PortNumber
close :: Socket -> IO ()
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Network.NodeId
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Network.NodeId
instance GHC.Classes.Ord Hydra.Network.NodeId
instance GHC.Read.Read Hydra.Network.NodeId
instance Data.String.IsString Hydra.Network.NodeId
instance GHC.Show.Show Hydra.Network.NodeId
instance GHC.Classes.Eq Hydra.Network.NodeId
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Network.Host
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Network.Host
instance GHC.Classes.Eq Hydra.Network.Host
instance GHC.Generics.Generic Hydra.Network.Host
instance GHC.Classes.Ord Hydra.Network.Host
instance Data.Aeson.Types.ToJSON.ToJSON Data.IP.Addr.IP
instance Data.Aeson.Types.FromJSON.FromJSON Data.IP.Addr.IP
instance GHC.Show.Show Hydra.Network.Host
instance GHC.Read.Read Hydra.Network.Host
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Network.Host
instance Cardano.Binary.ToCBOR.ToCBOR Hydra.Network.Host
instance Cardano.Binary.FromCBOR.FromCBOR Hydra.Network.Host
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Network.NodeId
instance Cardano.Binary.FromCBOR.FromCBOR Hydra.Network.NodeId
instance Cardano.Binary.ToCBOR.ToCBOR Hydra.Network.NodeId
instance Data.Functor.Contravariant.Contravariant (Hydra.Network.Network m)
instance Data.Aeson.Types.ToJSON.ToJSON Network.Socket.Types.PortNumber
instance Data.Aeson.Types.FromJSON.FromJSON Network.Socket.Types.PortNumber
instance Test.QuickCheck.Arbitrary.Arbitrary Network.Socket.Types.PortNumber
instance Cardano.Binary.ToCBOR.ToCBOR Network.Socket.Types.PortNumber
instance Cardano.Binary.FromCBOR.FromCBOR Network.Socket.Types.PortNumber

module Hydra.API.APIServerLog
data APIServerLog
APIServerStarted :: PortNumber -> APIServerLog
[listeningPort] :: APIServerLog -> PortNumber
NewAPIConnection :: APIServerLog
APIOutputSent :: Value -> APIServerLog
[sentOutput] :: APIServerLog -> Value
APIInputReceived :: Value -> APIServerLog
[receivedInput] :: APIServerLog -> Value
APIInvalidInput :: String -> Text -> APIServerLog
[reason] :: APIServerLog -> String
[inputReceived] :: APIServerLog -> Text
APIConnectionError :: String -> APIServerLog
[reason] :: APIServerLog -> String
APIHTTPRequestReceived :: Method -> PathInfo -> APIServerLog
[method] :: APIServerLog -> Method
[path] :: APIServerLog -> PathInfo

-- | New type wrapper to define JSON instances.
newtype PathInfo
PathInfo :: ByteString -> PathInfo

-- | New type wrapper to define JSON instances.
--   
--   NOTE: We are not using http-types <tt>StdMethod</tt> as we do not want
--   to be constrained in terms of logging and accept any method in a
--   <tt>Request</tt>.
newtype Method
Method :: ByteString -> Method
instance GHC.Show.Show Hydra.API.APIServerLog.PathInfo
instance GHC.Classes.Eq Hydra.API.APIServerLog.PathInfo
instance GHC.Show.Show Hydra.API.APIServerLog.Method
instance GHC.Classes.Eq Hydra.API.APIServerLog.Method
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.API.APIServerLog.APIServerLog
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.API.APIServerLog.APIServerLog
instance GHC.Generics.Generic Hydra.API.APIServerLog.APIServerLog
instance GHC.Show.Show Hydra.API.APIServerLog.APIServerLog
instance GHC.Classes.Eq Hydra.API.APIServerLog.APIServerLog
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.API.APIServerLog.APIServerLog
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.API.APIServerLog.Method
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.API.APIServerLog.Method
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.API.APIServerLog.Method
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.API.APIServerLog.PathInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.API.APIServerLog.PathInfo
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.API.APIServerLog.PathInfo

module Hydra.Network.Ouroboros.Type

-- | TODO explain Protocol
--   
--   It is used both as a type level tag for the protocol and as the kind
--   of the types of the states in the protocol state machine. That is
--   <tt>FireForget</tt> is a kind, and <tt>StIdle</tt> is a type of that
--   kind.
data FireForget msg
[StIdle] :: FireForget msg
[StDone] :: FireForget msg
codecFireForget :: forall a m. (MonadST m, ToCBOR a, FromCBOR a) => Codec (FireForget a) DeserialiseFailure m LByteString
instance forall msg (from :: Hydra.Network.Ouroboros.Type.FireForget msg) (to :: Hydra.Network.Ouroboros.Type.FireForget msg). GHC.Show.Show msg => GHC.Show.Show (Network.TypedProtocol.Core.Message (Hydra.Network.Ouroboros.Type.FireForget msg) from to)
instance forall msg (from :: Hydra.Network.Ouroboros.Type.FireForget msg) (to :: Hydra.Network.Ouroboros.Type.FireForget msg). GHC.Classes.Eq msg => GHC.Classes.Eq (Network.TypedProtocol.Core.Message (Hydra.Network.Ouroboros.Type.FireForget msg) from to)
instance forall k (msg :: k). Ouroboros.Network.Util.ShowProxy.ShowProxy (Hydra.Network.Ouroboros.Type.FireForget msg)
instance forall k (msg :: k). Network.TypedProtocol.Core.Protocol (Hydra.Network.Ouroboros.Type.FireForget msg)
instance forall k (msg :: k) (st :: Hydra.Network.Ouroboros.Type.FireForget msg). GHC.Show.Show (Network.TypedProtocol.Core.ClientHasAgency st)
instance forall k (msg :: k) (st :: Hydra.Network.Ouroboros.Type.FireForget msg). GHC.Show.Show (Network.TypedProtocol.Core.ServerHasAgency st)

module Hydra.Network.Ouroboros.Server
data FireForgetServer msg m a
FireForgetServer :: (msg -> m (FireForgetServer msg m a)) -> m a -> FireForgetServer msg m a

-- | The client sent us a message. There is no response and we must have
--   effects.
[recvMsg] :: FireForgetServer msg m a -> msg -> m (FireForgetServer msg m a)

-- | The client terminated. Here we have a pure return value, but we could
--   have done another action in <tt>m</tt> if we wanted to.
[recvMsgDone] :: FireForgetServer msg m a -> m a
fireForgetServerPeer :: Monad m => FireForgetServer msg m a -> Peer (FireForget msg) 'AsServer 'StIdle m a

module Hydra.Network.Ouroboros.Client
data FireForgetClient msg m a
[Idle] :: m (FireForgetClient msg m a) -> FireForgetClient msg m a
[SendMsg] :: msg -> m (FireForgetClient msg m a) -> FireForgetClient msg m a
[SendDone] :: m a -> FireForgetClient msg m a
fireForgetClientPeer :: Monad m => FireForgetClient msg m a -> Peer (FireForget msg) 'AsClient 'StIdle m a


-- | Ouroboros-based implementation of <a>Network</a> interface. This
--   implements a dumb <a>FireForget</a> protocol and maintains one
--   connection to each peer. Contrary to other protocols implemented in
--   Ouroboros, this is a push-based protocol.
module Hydra.Network.Ouroboros
withOuroborosNetwork :: forall msg. (ToCBOR msg, FromCBOR msg) => Tracer IO (WithHost (TraceOuroborosNetwork msg)) -> Host -> [Host] -> NetworkCallback msg IO -> (Network IO msg -> IO ()) -> IO ()
withIOManager :: WithIOManager
data TraceOuroborosNetwork msg
data PortNumber
data Host
Host :: Text -> PortNumber -> Host
[hostname] :: Host -> Text
[port] :: Host -> PortNumber

-- | A type tying both inbound and outbound messages sending in a single
--   <i>Component</i>.
type NetworkComponent m msg a = NetworkCallback msg m -> (Network m msg -> m a) -> m a

-- | Handle to interface for inbound messages.
type NetworkCallback msg m = msg -> m ()

-- | Handle to interface with the hydra network and send messages "off
--   chain".
newtype Network m msg
Network :: (msg -> m ()) -> Network m msg

-- | Send a <tt>msg</tt> to the whole hydra network.
[broadcast] :: Network m msg -> msg -> m ()
encodeTraceSendRecvFireForget :: forall msg. ToJSON msg => TraceSendRecv (FireForget msg) -> [Pair]
instance GHC.Show.Show Hydra.Network.Ouroboros.NetworkServerListenException
instance GHC.Show.Show trace => GHC.Show.Show (Hydra.Network.Ouroboros.WithHost trace)
instance GHC.Generics.Generic (Hydra.Network.Ouroboros.TraceOuroborosNetwork msg)
instance GHC.Show.Show msg => GHC.Show.Show (Hydra.Network.Ouroboros.TraceOuroborosNetwork msg)
instance Data.Aeson.Types.ToJSON.ToJSON msg => Data.Aeson.Types.ToJSON.ToJSON (Hydra.Network.Ouroboros.TraceOuroborosNetwork msg)
instance Data.Aeson.Types.ToJSON.ToJSON trace => Data.Aeson.Types.ToJSON.ToJSON (Hydra.Network.Ouroboros.WithHost trace)
instance Data.Aeson.Types.FromJSON.FromJSON trace => Data.Aeson.Types.FromJSON.FromJSON (Hydra.Network.Ouroboros.WithHost trace)
instance GHC.Exception.Type.Exception Hydra.Network.Ouroboros.NetworkServerListenException


-- | The general event queue from which the Hydra head is fed with events.
module Hydra.Node.EventQueue

-- | The single, required queue in the system from which a hydra head is
--   "fed". NOTE(SN): this probably should be bounded and include proper
--   logging NOTE(SN): handle pattern, but likely not required as there is
--   no need for an alternative implementation
data EventQueue m e
EventQueue :: (e -> m ()) -> (DiffTime -> Queued e -> m ()) -> m (Queued e) -> m Bool -> EventQueue m e
[putEvent] :: EventQueue m e -> e -> m ()
[putEventAfter] :: EventQueue m e -> DiffTime -> Queued e -> m ()
[nextEvent] :: EventQueue m e -> m (Queued e)
[isEmpty] :: EventQueue m e -> m Bool
data Queued e
Queued :: Word64 -> e -> Queued e
[eventId] :: Queued e -> Word64
[queuedEvent] :: Queued e -> e
createEventQueue :: (MonadDelay m, MonadAsync m, MonadLabelledSTM m) => m (EventQueue m e)


-- | Types and functions revolving around a Hydra <a>Party</a>. That is, a
--   participant in a Hydra Head, which signs transactions or snapshots in
--   the Hydra protocol.
module Hydra.Party

-- | Identifies a party in a Hydra head by it's <a>VerificationKey</a>.
newtype Party
Party :: VerificationKey HydraKey -> Party
[vkey] :: Party -> VerificationKey HydraKey

-- | Get the <a>Party</a> given some Hydra <a>SigningKey</a>.
deriveParty :: SigningKey HydraKey -> Party

-- | Convert "high-level" <a>Party</a> to the "low-level" representation as
--   used on-chain. See <a>Party</a> for an explanation why this is a
--   distinct type.
partyToChain :: Party -> Party

-- | Retrieve the "high-level" 'Party from the "low-level" on-chain
--   representation. This can fail because of the lower type-safety used
--   on-chain and a non-guaranteed verification key length. See
--   <a>Party</a> for an explanation why this is a distinct type.
partyFromChain :: MonadFail m => Party -> m Party
instance Data.Aeson.Types.ToJSON.ToJSONKey Hydra.Party.Party
instance Data.Aeson.Types.FromJSON.FromJSONKey Hydra.Party.Party
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Party.Party
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Party.Party
instance GHC.Generics.Generic Hydra.Party.Party
instance GHC.Show.Show Hydra.Party.Party
instance GHC.Classes.Eq Hydra.Party.Party
instance GHC.Classes.Ord Hydra.Party.Party
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Party.Party
instance Cardano.Binary.FromCBOR.FromCBOR Hydra.Party.Party
instance Cardano.Binary.ToCBOR.ToCBOR Hydra.Party.Party

module Hydra.Network.Authenticate

-- | Represents a signed message over the network. Becomes valid once its
--   receivers verify it against its other peers verification keys.
--   Messages are signed and turned into authenticated messages before
--   broadcasting them to other peers.
data Signed msg
Signed :: msg -> Signature msg -> Party -> Signed msg
[$sel:payload:Signed] :: Signed msg -> msg
[$sel:signature:Signed] :: Signed msg -> Signature msg
[$sel:party:Signed] :: Signed msg -> Party
data Authenticated msg
Authenticated :: msg -> Party -> Authenticated msg
[$sel:payload:Authenticated] :: Authenticated msg -> msg
[$sel:party:Authenticated] :: Authenticated msg -> Party

-- | Middleware used to sign messages before broadcasting them to other
--   peers and verify signed messages upon receiving. Only verified
--   messages are pushed downstream to the internal network for the node to
--   consume and process. Non-verified messages get discarded.
withAuthentication :: (SignableRepresentation msg, ToJSON msg) => Tracer m AuthLog -> SigningKey HydraKey -> [Party] -> NetworkComponent m (Signed msg) a -> NetworkComponent m (Authenticated msg) a

-- | Smart constructor for <a>MessageDropped</a>
mkAuthLog :: (ToJSON msg, Show signature) => msg -> signature -> Party -> AuthLog
data AuthLog
MessageDropped :: Text -> Text -> Party -> AuthLog
[$sel:message:MessageDropped] :: AuthLog -> Text
[$sel:signature:MessageDropped] :: AuthLog -> Text
[$sel:party:MessageDropped] :: AuthLog -> Party
instance Data.Aeson.Types.FromJSON.FromJSON msg => Data.Aeson.Types.FromJSON.FromJSON (Hydra.Network.Authenticate.Signed msg)
instance Data.Aeson.Types.ToJSON.ToJSON msg => Data.Aeson.Types.ToJSON.ToJSON (Hydra.Network.Authenticate.Signed msg)
instance GHC.Generics.Generic (Hydra.Network.Authenticate.Signed msg)
instance GHC.Show.Show msg => GHC.Show.Show (Hydra.Network.Authenticate.Signed msg)
instance GHC.Classes.Eq msg => GHC.Classes.Eq (Hydra.Network.Authenticate.Signed msg)
instance Data.Aeson.Types.FromJSON.FromJSON msg => Data.Aeson.Types.FromJSON.FromJSON (Hydra.Network.Authenticate.Authenticated msg)
instance Data.Aeson.Types.ToJSON.ToJSON msg => Data.Aeson.Types.ToJSON.ToJSON (Hydra.Network.Authenticate.Authenticated msg)
instance GHC.Generics.Generic (Hydra.Network.Authenticate.Authenticated msg)
instance GHC.Show.Show msg => GHC.Show.Show (Hydra.Network.Authenticate.Authenticated msg)
instance GHC.Classes.Eq msg => GHC.Classes.Eq (Hydra.Network.Authenticate.Authenticated msg)
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Network.Authenticate.AuthLog
instance GHC.Generics.Generic Hydra.Network.Authenticate.AuthLog
instance GHC.Show.Show Hydra.Network.Authenticate.AuthLog
instance GHC.Classes.Eq Hydra.Network.Authenticate.AuthLog
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Network.Authenticate.AuthLog
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Network.Authenticate.AuthLog
instance (Test.QuickCheck.Arbitrary.Arbitrary msg, Cardano.Crypto.Util.SignableRepresentation msg) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Network.Authenticate.Signed msg)
instance Cardano.Binary.ToCBOR.ToCBOR msg => Cardano.Binary.ToCBOR.ToCBOR (Hydra.Network.Authenticate.Signed msg)
instance Cardano.Binary.FromCBOR.FromCBOR msg => Cardano.Binary.FromCBOR.FromCBOR (Hydra.Network.Authenticate.Signed msg)


-- | Handles to save/load files across the hydra-node. We use a simple JSON
--   encoding and two modes of operation to store things: Full and
--   Incremental.
module Hydra.Persistence
newtype PersistenceException
PersistenceException :: String -> PersistenceException

-- | Handle to save and load files to/from disk using JSON encoding.
data Persistence a m
Persistence :: (ToJSON a => a -> m ()) -> (FromJSON a => m (Maybe a)) -> Persistence a m
[save] :: Persistence a m -> ToJSON a => a -> m ()
[load] :: Persistence a m -> FromJSON a => m (Maybe a)

-- | Initialize persistence handle for given type <tt>a</tt> at given file
--   path.
createPersistence :: (MonadIO m, MonadThrow m) => FilePath -> m (Persistence a m)

-- | Handle to save incrementally and load files to/from disk using JSON
--   encoding.
data PersistenceIncremental a m
PersistenceIncremental :: (ToJSON a => a -> m ()) -> (FromJSON a => m [a]) -> PersistenceIncremental a m
[append] :: PersistenceIncremental a m -> ToJSON a => a -> m ()
[loadAll] :: PersistenceIncremental a m -> FromJSON a => m [a]

-- | Initialize persistence handle for given type <tt>a</tt> at given file
--   path.
createPersistenceIncremental :: (MonadIO m, MonadThrow m) => FilePath -> m (PersistenceIncremental a m)
instance GHC.Show.Show Hydra.Persistence.PersistenceException
instance GHC.Classes.Eq Hydra.Persistence.PersistenceException
instance GHC.Exception.Type.Exception Hydra.Persistence.PersistenceException

module Hydra.Snapshot
newtype SnapshotNumber
UnsafeSnapshotNumber :: Natural -> SnapshotNumber
data Snapshot tx
Snapshot :: SnapshotNumber -> UTxOType tx -> [TxIdType tx] -> Snapshot tx
[number] :: Snapshot tx -> SnapshotNumber
[utxo] :: Snapshot tx -> UTxOType tx

-- | The set of transactions that lead to <a>utxo</a>
[confirmed] :: Snapshot tx -> [TxIdType tx]

-- | A snapshot that can be used to close a head with. Either the initial
--   one, or when it was signed by all parties, i.e. it is confirmed.
data ConfirmedSnapshot tx
InitialSnapshot :: UTxOType tx -> ConfirmedSnapshot tx
[initialUTxO] :: ConfirmedSnapshot tx -> UTxOType tx
ConfirmedSnapshot :: Snapshot tx -> MultiSignature (Snapshot tx) -> ConfirmedSnapshot tx
[snapshot] :: ConfirmedSnapshot tx -> Snapshot tx
[signatures] :: ConfirmedSnapshot tx -> MultiSignature (Snapshot tx)

-- | Safely get a <a>Snapshot</a> from a confirmed snapshot.
getSnapshot :: ConfirmedSnapshot tx -> Snapshot tx

-- | Tell whether a snapshot is the initial snapshot coming from the
--   collect-com transaction.
isInitialSnapshot :: ConfirmedSnapshot tx -> Bool
genConfirmedSnapshot :: IsTx tx => SnapshotNumber -> UTxOType tx -> [SigningKey HydraKey] -> Gen (ConfirmedSnapshot tx)
fromChainSnapshot :: SnapshotNumber -> SnapshotNumber
instance GHC.Real.Integral Hydra.Snapshot.SnapshotNumber
instance GHC.Enum.Enum Hydra.Snapshot.SnapshotNumber
instance GHC.Num.Num Hydra.Snapshot.SnapshotNumber
instance GHC.Real.Real Hydra.Snapshot.SnapshotNumber
instance Cardano.Binary.FromCBOR.FromCBOR Hydra.Snapshot.SnapshotNumber
instance Cardano.Binary.ToCBOR.ToCBOR Hydra.Snapshot.SnapshotNumber
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Snapshot.SnapshotNumber
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Snapshot.SnapshotNumber
instance GHC.Show.Show Hydra.Snapshot.SnapshotNumber
instance GHC.Generics.Generic Hydra.Snapshot.SnapshotNumber
instance GHC.Classes.Ord Hydra.Snapshot.SnapshotNumber
instance GHC.Classes.Eq Hydra.Snapshot.SnapshotNumber
instance GHC.Generics.Generic (Hydra.Snapshot.Snapshot tx)
instance Hydra.Ledger.IsTx tx => Data.Aeson.Types.FromJSON.FromJSON (Hydra.Snapshot.ConfirmedSnapshot tx)
instance Hydra.Ledger.IsTx tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.Snapshot.ConfirmedSnapshot tx)
instance Hydra.Ledger.IsTx tx => GHC.Show.Show (Hydra.Snapshot.ConfirmedSnapshot tx)
instance Hydra.Ledger.IsTx tx => GHC.Classes.Eq (Hydra.Snapshot.ConfirmedSnapshot tx)
instance GHC.Generics.Generic (Hydra.Snapshot.ConfirmedSnapshot tx)
instance Hydra.Ledger.IsTx tx => GHC.Classes.Eq (Hydra.Snapshot.Snapshot tx)
instance Hydra.Ledger.IsTx tx => GHC.Show.Show (Hydra.Snapshot.Snapshot tx)
instance Hydra.Ledger.IsTx tx => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Snapshot.ConfirmedSnapshot tx)
instance (Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Ledger.TxIdType tx), Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Ledger.UTxOType tx)) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Snapshot.Snapshot tx)
instance Hydra.Ledger.IsTx tx => Cardano.Crypto.Util.SignableRepresentation (Hydra.Snapshot.Snapshot tx)
instance Hydra.Ledger.IsTx tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.Snapshot.Snapshot tx)
instance Hydra.Ledger.IsTx tx => Data.Aeson.Types.FromJSON.FromJSON (Hydra.Snapshot.Snapshot tx)
instance (Data.Typeable.Internal.Typeable tx, Cardano.Binary.ToCBOR.ToCBOR (Hydra.Ledger.UTxOType tx), Cardano.Binary.ToCBOR.ToCBOR (Hydra.Ledger.TxIdType tx)) => Cardano.Binary.ToCBOR.ToCBOR (Hydra.Snapshot.Snapshot tx)
instance (Data.Typeable.Internal.Typeable tx, Cardano.Binary.FromCBOR.FromCBOR (Hydra.Ledger.UTxOType tx), Cardano.Binary.FromCBOR.FromCBOR (Hydra.Ledger.TxIdType tx)) => Cardano.Binary.FromCBOR.FromCBOR (Hydra.Snapshot.Snapshot tx)
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Snapshot.SnapshotNumber

module Hydra.Network.Message
data Connectivity
Connected :: NodeId -> Connectivity
[nodeId] :: Connectivity -> NodeId
Disconnected :: NodeId -> Connectivity
[nodeId] :: Connectivity -> NodeId
data Message tx
ReqTx :: tx -> Message tx
[transaction] :: Message tx -> tx
ReqSn :: SnapshotNumber -> [TxIdType tx] -> Message tx
[snapshotNumber] :: Message tx -> SnapshotNumber
[transactionIds] :: Message tx -> [TxIdType tx]
AckSn :: Signature (Snapshot tx) -> SnapshotNumber -> Message tx
[signed] :: Message tx -> Signature (Snapshot tx)
[snapshotNumber] :: Message tx -> SnapshotNumber
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Network.Message.Connectivity
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Network.Message.Connectivity
instance GHC.Show.Show Hydra.Network.Message.Connectivity
instance GHC.Classes.Eq Hydra.Network.Message.Connectivity
instance GHC.Generics.Generic Hydra.Network.Message.Connectivity
instance GHC.Generics.Generic (Hydra.Network.Message.Message tx)
instance Hydra.Ledger.IsTx tx => GHC.Classes.Eq (Hydra.Network.Message.Message tx)
instance Hydra.Ledger.IsTx tx => GHC.Show.Show (Hydra.Network.Message.Message tx)
instance Hydra.Ledger.IsTx tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.Network.Message.Message tx)
instance Hydra.Ledger.IsTx tx => Data.Aeson.Types.FromJSON.FromJSON (Hydra.Network.Message.Message tx)
instance Hydra.Ledger.IsTx tx => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Network.Message.Message tx)
instance (Cardano.Binary.ToCBOR.ToCBOR tx, Cardano.Binary.ToCBOR.ToCBOR (Hydra.Ledger.UTxOType tx), Cardano.Binary.ToCBOR.ToCBOR (Hydra.Ledger.TxIdType tx)) => Cardano.Binary.ToCBOR.ToCBOR (Hydra.Network.Message.Message tx)
instance (Cardano.Binary.FromCBOR.FromCBOR tx, Cardano.Binary.FromCBOR.FromCBOR (Hydra.Ledger.UTxOType tx), Cardano.Binary.FromCBOR.FromCBOR (Hydra.Ledger.TxIdType tx)) => Cardano.Binary.FromCBOR.FromCBOR (Hydra.Network.Message.Message tx)
instance Hydra.Ledger.IsTx tx => Cardano.Crypto.Util.SignableRepresentation (Hydra.Network.Message.Message tx)


-- | An implementation of an application-level failure detector. This
--   module exposes a <i>Component</i> <a>withHeartbeat</a> than can be
--   used to wrap another <a>NetworkComponent</a> and piggy-back on it to
--   send and propagate <a>Heartbeat</a> messages and detect other parties'
--   liveness.
--   
--   It is inspired by the <i>Increasing timeout</i> algorithms from the
--   book <a>Introduction to Reliable and Secure Distributed
--   Programming</a> by <i>Cachin et al.</i> which is an <i>Eventually
--   Perfect Failure Detector</i> suitable for partially synchronous
--   network settings. It has the following behaviour:
--   
--   <ul>
--   <li>It broadcasts a <a>Ping</a> to other parties through the
--   underlying <a>Network</a> implementation if the last message has been
--   sent more than 3s ago</li>
--   <li>When receiving messages from other parties, it records reception
--   time and notifies underlying node with a <a>Connected</a> message</li>
--   <li>If new messages are received from <a>alive</a> parties before 3s
--   timeout expires no new <a>Connected</a> message is sent * If main
--   thread detects that a formerly <a>alive</a> party has not been seen
--   for more than 3s, it is marked as <a>suspected</a> and a
--   <a>Disconnected</a> message is sent to the node.</li>
--   </ul>
module Hydra.Network.Heartbeat
data HeartbeatState
HeartbeatState :: Map NodeId Time -> Set NodeId -> Maybe Time -> HeartbeatState

-- | The map of known <a>Connected</a> parties with the last time they've
--   been "seen". This is updated when we see a message from another node
[alive] :: HeartbeatState -> Map NodeId Time

-- | The set of known parties which might be <a>Disconnected</a> This is
--   updated after some time no message has been received from a node.
[suspected] :: HeartbeatState -> Set NodeId

-- | The timestamp of the last sent message.
[lastSent] :: HeartbeatState -> Maybe Time
initialHeartbeatState :: HeartbeatState
data Heartbeat msg
Data :: NodeId -> msg -> Heartbeat msg
Ping :: NodeId -> Heartbeat msg

-- | Delay between each heartbeat check.
heartbeatDelay :: DiffTime

-- | Maximal delay between expected and sent heartbeats.
livenessDelay :: DiffTime
type ConnectionMessages m = Connectivity -> m ()

-- | Wrap a <a>NetworkComponent</a> and handle sending/receiving of
--   heartbeats.
withHeartbeat :: (MonadAsync m, MonadDelay m) => NodeId -> ConnectionMessages m -> NetworkComponent m (Heartbeat msg) a -> NetworkComponent m msg a
updateStateFromIncomingMessages :: (MonadSTM m, MonadMonotonicTime m) => TVar m HeartbeatState -> ConnectionMessages m -> NetworkCallback msg m -> NetworkCallback (Heartbeat msg) m
updateStateFromOutgoingMessages :: (MonadSTM m, MonadMonotonicTime m) => NodeId -> TVar m HeartbeatState -> Network m (Heartbeat msg) -> Network m msg
updateLastSent :: MonadSTM m => TVar m HeartbeatState -> Time -> m ()
checkHeartbeatState :: (MonadDelay m, MonadSTM m) => NodeId -> TVar m HeartbeatState -> Network m (Heartbeat msg) -> m ()
shouldSendHeartbeat :: Time -> HeartbeatState -> Bool
checkRemoteParties :: (MonadDelay m, MonadSTM m) => TVar m HeartbeatState -> ConnectionMessages m -> m ()
updateSuspected :: MonadSTM m => TVar m HeartbeatState -> Time -> m (Set NodeId)
checkTimeout :: (DiffTime -> DiffTime) -> Time -> Time -> Bool
instance GHC.Classes.Eq Hydra.Network.Heartbeat.HeartbeatState
instance Data.Aeson.Types.FromJSON.FromJSON msg => Data.Aeson.Types.FromJSON.FromJSON (Hydra.Network.Heartbeat.Heartbeat msg)
instance Data.Aeson.Types.ToJSON.ToJSON msg => Data.Aeson.Types.ToJSON.ToJSON (Hydra.Network.Heartbeat.Heartbeat msg)
instance GHC.Generics.Generic (Hydra.Network.Heartbeat.Heartbeat msg)
instance GHC.Show.Show msg => GHC.Show.Show (Hydra.Network.Heartbeat.Heartbeat msg)
instance GHC.Classes.Eq msg => GHC.Classes.Eq (Hydra.Network.Heartbeat.Heartbeat msg)
instance Cardano.Binary.ToCBOR.ToCBOR msg => Cardano.Binary.ToCBOR.ToCBOR (Hydra.Network.Heartbeat.Heartbeat msg)
instance Cardano.Binary.FromCBOR.FromCBOR msg => Cardano.Binary.FromCBOR.FromCBOR (Hydra.Network.Heartbeat.Heartbeat msg)
instance Cardano.Binary.ToCBOR.ToCBOR msg => Cardano.Crypto.Util.SignableRepresentation (Hydra.Network.Heartbeat.Heartbeat msg)


-- | Specifies the <i>Head-Chain Interaction</i> part of the protocol
--   
--   Incoming and outgoing on-chain transactions are modelled respectively
--   as <a>OnChainTx</a> and <a>PostChainTx</a> which are data type that
--   abstracts away the details of the structure of the transaction.
module Hydra.Chain

-- | Hardcoded limit for commit tx on mainnet
maxMainnetLovelace :: Lovelace

-- | Hardcoded limit for maximum number of parties in a head protocol The
--   value is obtained from calculating the costs of running the scripts
--   and on-chan validators (see <tt>computeCollectComCost</tt>
--   <tt>computeAbortCost</tt>)
maximumNumberOfParties :: Int

-- | Contains the head's parameters as established in the initial
--   transaction.
data HeadParameters
HeadParameters :: ContestationPeriod -> [Party] -> HeadParameters
[$sel:contestationPeriod:HeadParameters] :: HeadParameters -> ContestationPeriod
[$sel:parties:HeadParameters] :: HeadParameters -> [Party]

-- | Data type used to post transactions on chain. It holds everything to
--   construct corresponding Head protocol transactions.
data PostChainTx tx
InitTx :: HeadParameters -> PostChainTx tx
[$sel:headParameters:InitTx] :: PostChainTx tx -> HeadParameters
AbortTx :: UTxOType tx -> PostChainTx tx
[$sel:utxo:InitTx] :: PostChainTx tx -> UTxOType tx
CollectComTx :: UTxOType tx -> PostChainTx tx
[$sel:utxo:InitTx] :: PostChainTx tx -> UTxOType tx
CloseTx :: ConfirmedSnapshot tx -> PostChainTx tx
[$sel:confirmedSnapshot:InitTx] :: PostChainTx tx -> ConfirmedSnapshot tx
ContestTx :: ConfirmedSnapshot tx -> PostChainTx tx
[$sel:confirmedSnapshot:InitTx] :: PostChainTx tx -> ConfirmedSnapshot tx
FanoutTx :: UTxOType tx -> UTCTime -> PostChainTx tx
[$sel:utxo:InitTx] :: PostChainTx tx -> UTxOType tx
[$sel:contestationDeadline:InitTx] :: PostChainTx tx -> UTCTime

-- | Uniquely identifies a Hydra Head.
newtype HeadId
HeadId :: ByteString -> HeadId

-- | Describes transactions as seen on chain. Holds as minimal information
--   as possible to simplify observing the chain.
data OnChainTx tx
OnInitTx :: HeadId -> ContestationPeriod -> [Party] -> OnChainTx tx
[$sel:headId:OnInitTx] :: OnChainTx tx -> HeadId
[$sel:contestationPeriod:OnInitTx] :: OnChainTx tx -> ContestationPeriod
[$sel:parties:OnInitTx] :: OnChainTx tx -> [Party]
OnCommitTx :: Party -> UTxOType tx -> OnChainTx tx
[$sel:party:OnInitTx] :: OnChainTx tx -> Party
[$sel:committed:OnInitTx] :: OnChainTx tx -> UTxOType tx
OnAbortTx :: OnChainTx tx
OnCollectComTx :: OnChainTx tx
OnCloseTx :: HeadId -> SnapshotNumber -> UTCTime -> OnChainTx tx
[$sel:headId:OnInitTx] :: OnChainTx tx -> HeadId
[$sel:snapshotNumber:OnInitTx] :: OnChainTx tx -> SnapshotNumber
[$sel:contestationDeadline:OnInitTx] :: OnChainTx tx -> UTCTime
OnContestTx :: SnapshotNumber -> OnChainTx tx
[$sel:snapshotNumber:OnInitTx] :: OnChainTx tx -> SnapshotNumber
OnFanoutTx :: OnChainTx tx

-- | Exceptions thrown by <a>$sel:postTx:Chain</a>.
data PostTxError tx
NoSeedInput :: PostTxError tx
CannotFindOwnInitial :: UTxOType tx -> PostTxError tx
[$sel:knownUTxO:NoSeedInput] :: PostTxError tx -> UTxOType tx

-- | Comitting byron addresses is not supported.
UnsupportedLegacyOutput :: Address ByronAddr -> PostTxError tx
[$sel:byronAddress:NoSeedInput] :: PostTxError tx -> Address ByronAddr

-- | Comitting reference scripts is not supported right now.
CannotCommitReferenceScript :: PostTxError tx
InvalidStateToPost :: PostChainTx tx -> ChainStateType tx -> PostTxError tx
[$sel:txTried:NoSeedInput] :: PostTxError tx -> PostChainTx tx
[$sel:chainState:NoSeedInput] :: PostTxError tx -> ChainStateType tx
NotEnoughFuel :: PostTxError tx
NoFuelUTXOFound :: PostTxError tx

-- | Script execution failed when finalizing a transaction in the wallet.
--   XXX: Ideally we want a cardano-api type with corresonding JSON
--   instance here. But the wallet still uses ledger types and we don't
--   want to copy the conversion from ledger
--   <tt>TransactionScriptFailure</tt> to the cardano-api
--   <tt>ScriptExecutionError</tt> type.
ScriptFailedInWallet :: Text -> Text -> PostTxError tx
[$sel:redeemerPtr:NoSeedInput] :: PostTxError tx -> Text
[$sel:failureReason:NoSeedInput] :: PostTxError tx -> Text

-- | A generic error happened when finalizing a transction in the wallet.
InternalWalletError :: UTxOType tx -> Text -> tx -> PostTxError tx
[$sel:headUTxO:NoSeedInput] :: PostTxError tx -> UTxOType tx
[$sel:reason:NoSeedInput] :: PostTxError tx -> Text
[$sel:tx:NoSeedInput] :: PostTxError tx -> tx

-- | An error occurred when submitting a transaction to the cardano-node.
FailedToPostTx :: Text -> PostTxError tx
[$sel:failureReason:NoSeedInput] :: PostTxError tx -> Text

-- | A plutus script failed in a transaction submitted to the cardano-node.
--   NOTE: PlutusDebugInfo does not have much available instances so we put
--   it in Text form but it's lame
PlutusValidationFailed :: Text -> Text -> PostTxError tx
[$sel:plutusFailure:NoSeedInput] :: PostTxError tx -> Text
[$sel:plutusDebugInfo:NoSeedInput] :: PostTxError tx -> Text

-- | User tried to commit more than <a>maxMainnetLovelace</a> hardcoded
--   limit on mainnet we keep track of both the hardcoded limit and what
--   the user originally tried to commit
CommittedTooMuchADAForMainnet :: Lovelace -> Lovelace -> PostTxError tx
[$sel:userCommittedLovelace:NoSeedInput] :: PostTxError tx -> Lovelace
[$sel:mainnetLimitLovelace:NoSeedInput] :: PostTxError tx -> Lovelace

-- | We can only draft commit tx for the user when in Initializing state
FailedToDraftTxNotInitializing :: PostTxError tx

-- | Committing UTxO addressed to the internal wallet is forbidden.
SpendingNodeUtxoForbidden :: PostTxError tx

-- | A non empty sequence of chain states that can be rolled back. This is
--   expected to be constructed by using the smart constructor
--   <a>initHistory</a>.
data ChainStateHistory tx
UnsafeChainStateHistory :: NonEmpty (ChainStateType tx) -> ChainStateType tx -> ChainStateHistory tx
[$sel:history:UnsafeChainStateHistory] :: ChainStateHistory tx -> NonEmpty (ChainStateType tx)
[$sel:defaultChainState:UnsafeChainStateHistory] :: ChainStateHistory tx -> ChainStateType tx
currentState :: ChainStateHistory tx -> ChainStateType tx
pushNewState :: ChainStateType tx -> ChainStateHistory tx -> ChainStateHistory tx
initHistory :: ChainStateType tx -> ChainStateHistory tx
rollbackHistory :: IsChainState tx => ChainSlot -> ChainStateHistory tx -> ChainStateHistory tx

-- | Interface available from a chain state. Expected to be instantiated by
--   all 'ChainStateType tx'.
class (IsTx tx, Eq (ChainStateType tx), Show (ChainStateType tx), FromJSON (ChainStateType tx), ToJSON (ChainStateType tx)) => IsChainState tx where {
    
    -- | Types of what to keep as L1 chain state.
    type ChainStateType tx = c | c -> tx;
}

-- | Get the chain slot for a chain state. NOTE: For any sequence of
--   <tt>a</tt> encountered, we assume monotonically increasing slots.
chainStateSlot :: IsChainState tx => ChainStateType tx -> ChainSlot

-- | Handle to interface with the main chain network
data Chain tx m
Chain :: (MonadThrow m => PostChainTx tx -> m ()) -> (MonadThrow m => UTxO' (TxOut CtxUTxO, Witness WitCtxTxIn) -> m (Either (PostTxError Tx) Tx)) -> (MonadThrow m => Tx -> m ()) -> Chain tx m

-- | Construct and send a transaction to the main chain corresponding to
--   the given <a>PostChainTx</a> description. This function is not
--   expected to block, so it is only responsible for submitting, but it
--   should validate the created transaction against a reasonable local
--   view of the chain and throw an exception when invalid.
--   
--   Does at least throw <a>PostTxError</a>.
[$sel:postTx:Chain] :: Chain tx m -> MonadThrow m => PostChainTx tx -> m ()

-- | Create a commit transaction using user provided utxos (zero or many)
--   and information to spend from a script. Errors are handled at the call
--   site.
[$sel:draftCommitTx:Chain] :: Chain tx m -> MonadThrow m => UTxO' (TxOut CtxUTxO, Witness WitCtxTxIn) -> m (Either (PostTxError Tx) Tx)

-- | Submit a cardano transaction.
--   
--   Throws at least <a>PostTxError</a>.
--   
--   XXX: While technically they could be any of 'PostTxError tx', only
--   <a>FailedToPostTx</a> errors are expected here.
[$sel:submitTx:Chain] :: Chain tx m -> MonadThrow m => Tx -> m ()
data ChainEvent tx
Observation :: OnChainTx tx -> ChainStateType tx -> ChainEvent tx
[$sel:observedTx:Observation] :: ChainEvent tx -> OnChainTx tx
[$sel:newChainState:Observation] :: ChainEvent tx -> ChainStateType tx
Rollback :: ChainStateType tx -> ChainEvent tx
[$sel:rolledBackChainState:Observation] :: ChainEvent tx -> ChainStateType tx

-- | Indicate time has advanced on the chain.
--   
--   NOTE: While the type does not guarantee that the UTCTime and ChainSlot
--   are consistent the alternative would be provide the means to do the
--   conversion. For Cardano, this would be a systemStart and eraHistory..
--   which is annoying and if it's kept in the chain layer, it would mean
--   another round trip / state to keep there.
Tick :: UTCTime -> ChainSlot -> ChainEvent tx
[$sel:chainTime:Observation] :: ChainEvent tx -> UTCTime
[$sel:chainSlot:Observation] :: ChainEvent tx -> ChainSlot

-- | A callback indicating a 'ChainEvent tx' happened. Most importantly the
--   <a>Observation</a> of a relevant Hydra transaction.
type ChainCallback tx m = ChainEvent tx -> m ()

-- | A type tying both posting and observing transactions into a single
--   <i>Component</i>.
type ChainComponent tx m a = ChainCallback tx m -> (Chain tx m -> m a) -> m a
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Chain.HeadParameters
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Chain.HeadParameters
instance GHC.Generics.Generic Hydra.Chain.HeadParameters
instance GHC.Show.Show Hydra.Chain.HeadParameters
instance GHC.Classes.Eq Hydra.Chain.HeadParameters
instance GHC.Generics.Generic (Hydra.Chain.PostChainTx tx)
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Chain.HeadId
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Chain.HeadId
instance GHC.Generics.Generic Hydra.Chain.HeadId
instance GHC.Classes.Ord Hydra.Chain.HeadId
instance GHC.Classes.Eq Hydra.Chain.HeadId
instance GHC.Show.Show Hydra.Chain.HeadId
instance GHC.Generics.Generic (Hydra.Chain.OnChainTx tx)
instance GHC.Generics.Generic (Hydra.Chain.ChainStateHistory tx)
instance GHC.Generics.Generic (Hydra.Chain.PostTxError tx)
instance GHC.Generics.Generic (Hydra.Chain.ChainEvent tx)
instance Hydra.Ledger.IsTx tx => GHC.Classes.Eq (Hydra.Chain.PostChainTx tx)
instance Hydra.Ledger.IsTx tx => GHC.Show.Show (Hydra.Chain.PostChainTx tx)
instance Hydra.Ledger.IsTx tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.Chain.PostChainTx tx)
instance Hydra.Ledger.IsTx tx => Data.Aeson.Types.FromJSON.FromJSON (Hydra.Chain.PostChainTx tx)
instance Hydra.Ledger.IsTx tx => GHC.Classes.Eq (Hydra.Chain.OnChainTx tx)
instance Hydra.Ledger.IsTx tx => GHC.Show.Show (Hydra.Chain.OnChainTx tx)
instance Hydra.Ledger.IsTx tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.Chain.OnChainTx tx)
instance Hydra.Ledger.IsTx tx => Data.Aeson.Types.FromJSON.FromJSON (Hydra.Chain.OnChainTx tx)
instance Hydra.Chain.IsChainState tx => GHC.Classes.Eq (Hydra.Chain.PostTxError tx)
instance Hydra.Chain.IsChainState tx => GHC.Show.Show (Hydra.Chain.PostTxError tx)
instance Hydra.Chain.IsChainState tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.Chain.PostTxError tx)
instance Hydra.Chain.IsChainState tx => Data.Aeson.Types.FromJSON.FromJSON (Hydra.Chain.PostTxError tx)
instance GHC.Classes.Eq (Hydra.Chain.ChainStateType tx) => GHC.Classes.Eq (Hydra.Chain.ChainStateHistory tx)
instance GHC.Show.Show (Hydra.Chain.ChainStateType tx) => GHC.Show.Show (Hydra.Chain.ChainStateHistory tx)
instance Data.Aeson.Types.ToJSON.ToJSON (Hydra.Chain.ChainStateType tx) => Data.Aeson.Types.ToJSON.ToJSON (Hydra.Chain.ChainStateHistory tx)
instance Data.Aeson.Types.FromJSON.FromJSON (Hydra.Chain.ChainStateType tx) => Data.Aeson.Types.FromJSON.FromJSON (Hydra.Chain.ChainStateHistory tx)
instance (Hydra.Ledger.IsTx tx, GHC.Classes.Eq (Hydra.Chain.ChainStateType tx)) => GHC.Classes.Eq (Hydra.Chain.ChainEvent tx)
instance (Hydra.Ledger.IsTx tx, GHC.Show.Show (Hydra.Chain.ChainStateType tx)) => GHC.Show.Show (Hydra.Chain.ChainEvent tx)
instance (Hydra.Ledger.IsTx tx, Data.Aeson.Types.ToJSON.ToJSON (Hydra.Chain.ChainStateType tx)) => Data.Aeson.Types.ToJSON.ToJSON (Hydra.Chain.ChainEvent tx)
instance (Hydra.Ledger.IsTx tx, Data.Aeson.Types.FromJSON.FromJSON (Hydra.Chain.ChainStateType tx)) => Data.Aeson.Types.FromJSON.FromJSON (Hydra.Chain.ChainEvent tx)
instance (Test.QuickCheck.Arbitrary.Arbitrary tx, Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Ledger.UTxOType tx), Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Ledger.TxIdType tx), Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Chain.ChainStateType tx)) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Chain.ChainEvent tx)
instance Hydra.Chain.IsChainState tx => GHC.Exception.Type.Exception (Hydra.Chain.PostTxError tx)
instance (Hydra.Ledger.IsTx tx, Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Chain.ChainStateType tx)) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Chain.PostTxError tx)
instance Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Chain.ChainStateType tx) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Chain.ChainStateHistory tx)
instance (Test.QuickCheck.Arbitrary.Arbitrary tx, Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Ledger.UTxOType tx)) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Chain.OnChainTx tx)
instance Cardano.Api.SerialiseRaw.SerialiseAsRawBytes Hydra.Chain.HeadId
instance Cardano.Api.HasTypeProxy.HasTypeProxy Hydra.Chain.HeadId
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Chain.HeadId
instance Hydra.Ledger.IsTx tx => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Chain.PostChainTx tx)
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Chain.HeadParameters
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Api.Value.Lovelace


-- | A mock implementation of a ledger using very simple UTxO transactions.
--   
--   These transactions have a very simplified representation of unspent
--   transaction outputs being just integers, but already have inputs and
--   outputs. Transactions are validated against the current state of the
--   ledger, so that one transaction could at some point be invalid, then
--   becomes valid because some inputs it consumes are now available.
--   
--   NOTE: There is no notion of time in this ledger, so transactions
--   validation will never depend on the L1 slot.
module Hydra.Ledger.Simple

-- | Simple transaction. A transaction is a <a>SimpleId</a>, a list of
--   inputs and a list of outputs, and it has no time validity.
data SimpleTx
SimpleTx :: SimpleId -> UTxOType SimpleTx -> UTxOType SimpleTx -> SimpleTx
[txSimpleId] :: SimpleTx -> SimpleId
[txInputs] :: SimpleTx -> UTxOType SimpleTx
[txOutputs] :: SimpleTx -> UTxOType SimpleTx
type SimpleId = Integer
newtype SimpleChainState
SimpleChainState :: ChainSlot -> SimpleChainState
[slot] :: SimpleChainState -> ChainSlot

-- | An identifier for a single output of a <a>SimpleTx</a>.
newtype SimpleTxIn
SimpleTxIn :: Integer -> SimpleTxIn
[unSimpleTxIn] :: SimpleTxIn -> Integer
simpleLedger :: Ledger SimpleTx
utxoRef :: Integer -> UTxOType SimpleTx
utxoRefs :: [Integer] -> UTxOType SimpleTx
aValidTx :: Integer -> SimpleTx
listOfCommittedUTxOs :: Integer -> Gen [UTxOType SimpleTx]
genSequenceOfValidTransactions :: UTxOType SimpleTx -> Gen [SimpleTx]
instance GHC.Show.Show Hydra.Ledger.Simple.SimpleTx
instance GHC.Generics.Generic Hydra.Ledger.Simple.SimpleTx
instance GHC.Classes.Ord Hydra.Ledger.Simple.SimpleTx
instance GHC.Classes.Eq Hydra.Ledger.Simple.SimpleTx
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Ledger.Simple.SimpleChainState
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Ledger.Simple.SimpleChainState
instance GHC.Generics.Generic Hydra.Ledger.Simple.SimpleChainState
instance GHC.Show.Show Hydra.Ledger.Simple.SimpleChainState
instance GHC.Classes.Eq Hydra.Ledger.Simple.SimpleChainState
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Ledger.Simple.SimpleTxIn
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Ledger.Simple.SimpleTxIn
instance GHC.Num.Num Hydra.Ledger.Simple.SimpleTxIn
instance GHC.Show.Show Hydra.Ledger.Simple.SimpleTxIn
instance GHC.Classes.Ord Hydra.Ledger.Simple.SimpleTxIn
instance GHC.Classes.Eq Hydra.Ledger.Simple.SimpleTxIn
instance GHC.Generics.Generic Hydra.Ledger.Simple.SimpleTxIn
instance Hydra.Ledger.IsTx Hydra.Ledger.Simple.SimpleTx
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Ledger.Simple.SimpleTxIn
instance Cardano.Binary.ToCBOR.ToCBOR Hydra.Ledger.Simple.SimpleTxIn
instance Cardano.Binary.FromCBOR.FromCBOR Hydra.Ledger.Simple.SimpleTxIn
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Ledger.Simple.SimpleChainState
instance Hydra.Chain.IsChainState Hydra.Ledger.Simple.SimpleTx
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Ledger.Simple.SimpleTx
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Ledger.Simple.SimpleTx
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Ledger.Simple.SimpleTx
instance Cardano.Binary.ToCBOR.ToCBOR Hydra.Ledger.Simple.SimpleTx
instance Cardano.Binary.FromCBOR.FromCBOR Hydra.Ledger.Simple.SimpleTx

module Hydra.HeadLogic.State
data Environment
Environment :: Party -> SigningKey HydraKey -> [Party] -> ContestationPeriod -> Environment

-- | This is the p_i from the paper
[$sel:party:Environment] :: Environment -> Party
[$sel:signingKey:Environment] :: Environment -> SigningKey HydraKey
[$sel:otherParties:Environment] :: Environment -> [Party]
[$sel:contestationPeriod:Environment] :: Environment -> ContestationPeriod

-- | The main state of the Hydra protocol state machine. It holds both, the
--   overall protocol state, but also the off-chain
--   <a>CoordinatedHeadState</a>.
--   
--   Each of the sub-types (InitialState, OpenState, etc.) contain
--   black-box <a>IdleState</a> corresponding to <tt>OnChainEvent</tt> that
--   has been observed leading to the state.
--   
--   Note that rollbacks are currently not fully handled in the head logic
--   and only this internal chain state gets replaced with the "rolled back
--   to" version.
data HeadState tx
Idle :: IdleState tx -> HeadState tx
Initial :: InitialState tx -> HeadState tx
Open :: OpenState tx -> HeadState tx
Closed :: ClosedState tx -> HeadState tx

-- | Update the chain state in any <a>HeadState</a>.
setChainState :: ChainStateType tx -> HeadState tx -> HeadState tx

-- | Get the head parameters in any <a>HeadState</a>.
getHeadParameters :: HeadState tx -> Maybe HeadParameters

-- | An <a>Idle</a> head only having a chain state with things seen on
--   chain so far.
newtype IdleState tx
IdleState :: ChainStateType tx -> IdleState tx
[$sel:chainState:IdleState] :: IdleState tx -> ChainStateType tx

-- | An <a>Initial</a> head which already has an identity and is collecting
--   commits.
data InitialState tx
InitialState :: HeadParameters -> PendingCommits -> Committed tx -> ChainStateType tx -> HeadId -> InitialState tx
[$sel:parameters:InitialState] :: InitialState tx -> HeadParameters
[$sel:pendingCommits:InitialState] :: InitialState tx -> PendingCommits
[$sel:committed:InitialState] :: InitialState tx -> Committed tx
[$sel:chainState:InitialState] :: InitialState tx -> ChainStateType tx
[$sel:headId:InitialState] :: InitialState tx -> HeadId
type PendingCommits = Set Party
type Committed tx = Map Party (UTxOType tx)

-- | An <a>Open</a> head with a <a>CoordinatedHeadState</a> tracking
--   off-chain transactions.
data OpenState tx
OpenState :: HeadParameters -> CoordinatedHeadState tx -> ChainStateType tx -> HeadId -> ChainSlot -> OpenState tx
[$sel:parameters:OpenState] :: OpenState tx -> HeadParameters
[$sel:coordinatedHeadState:OpenState] :: OpenState tx -> CoordinatedHeadState tx
[$sel:chainState:OpenState] :: OpenState tx -> ChainStateType tx
[$sel:headId:OpenState] :: OpenState tx -> HeadId
[$sel:currentSlot:OpenState] :: OpenState tx -> ChainSlot

-- | Off-chain state of the Coordinated Head protocol.
data CoordinatedHeadState tx
CoordinatedHeadState :: UTxOType tx -> [tx] -> Map (TxIdType tx) tx -> ConfirmedSnapshot tx -> SeenSnapshot tx -> CoordinatedHeadState tx

-- | The latest UTxO resulting from applying
--   <a>$sel:localTxs:CoordinatedHeadState</a> to
--   <a>CoordinatedHeadState</a>. Spec: L̂
[$sel:localUTxO:CoordinatedHeadState] :: CoordinatedHeadState tx -> UTxOType tx

-- | List of transactions applied locally and pending inclusion in a
--   snapshot. Spec: T̂
[$sel:localTxs:CoordinatedHeadState] :: CoordinatedHeadState tx -> [tx]

-- | Map containing all the transactions ever seen by this node and not yet
--   included in a snapshot. Spec: Tall
[$sel:allTxs:CoordinatedHeadState] :: CoordinatedHeadState tx -> Map (TxIdType tx) tx

-- | The latest confirmed snapshot. Spec: U̅, s̅ and σ̅
[$sel:confirmedSnapshot:CoordinatedHeadState] :: CoordinatedHeadState tx -> ConfirmedSnapshot tx

-- | Last seen snapshot and signatures accumulator. Spec: Û, ŝ and Σ̂
[$sel:seenSnapshot:CoordinatedHeadState] :: CoordinatedHeadState tx -> SeenSnapshot tx

-- | Data structure to help in tracking whether we have seen or requested a
--   ReqSn already and if seen, the signatures we collected already.
data SeenSnapshot tx

-- | Never saw a ReqSn.
NoSeenSnapshot :: SeenSnapshot tx

-- | No snapshot in flight with last seen snapshot number as given.
LastSeenSnapshot :: SnapshotNumber -> SeenSnapshot tx
[$sel:lastSeen:NoSeenSnapshot] :: SeenSnapshot tx -> SnapshotNumber

-- | ReqSn was sent out and it should be considered already in flight.
RequestedSnapshot :: SnapshotNumber -> SnapshotNumber -> SeenSnapshot tx
[$sel:lastSeen:NoSeenSnapshot] :: SeenSnapshot tx -> SnapshotNumber
[$sel:requested:NoSeenSnapshot] :: SeenSnapshot tx -> SnapshotNumber

-- | ReqSn for given snapshot was received.
SeenSnapshot :: Snapshot tx -> Map Party (Signature (Snapshot tx)) -> SeenSnapshot tx
[$sel:snapshot:NoSeenSnapshot] :: SeenSnapshot tx -> Snapshot tx

-- | Collected signatures and so far.
[$sel:signatories:NoSeenSnapshot] :: SeenSnapshot tx -> Map Party (Signature (Snapshot tx))

-- | Get the last seen snapshot number given a <a>SeenSnapshot</a>.
seenSnapshotNumber :: SeenSnapshot tx -> SnapshotNumber

-- | An <a>Closed</a> head with an current candidate
--   <a>ConfirmedSnapshot</a>, which may be contested before the
--   <a>$sel:contestationDeadline:ClosedState</a>.
data ClosedState tx
ClosedState :: HeadParameters -> ConfirmedSnapshot tx -> UTCTime -> Bool -> ChainStateType tx -> HeadId -> ClosedState tx
[$sel:parameters:ClosedState] :: ClosedState tx -> HeadParameters
[$sel:confirmedSnapshot:ClosedState] :: ClosedState tx -> ConfirmedSnapshot tx
[$sel:contestationDeadline:ClosedState] :: ClosedState tx -> UTCTime

-- | Tracks whether we have informed clients already about being
--   <tt>ReadyToFanout</tt>.
[$sel:readyToFanoutSent:ClosedState] :: ClosedState tx -> Bool
[$sel:chainState:ClosedState] :: ClosedState tx -> ChainStateType tx
[$sel:headId:ClosedState] :: ClosedState tx -> HeadId
instance GHC.Show.Show Hydra.HeadLogic.State.Environment
instance GHC.Generics.Generic (Hydra.HeadLogic.State.IdleState tx)
instance GHC.Generics.Generic (Hydra.HeadLogic.State.InitialState tx)
instance GHC.Generics.Generic (Hydra.HeadLogic.State.SeenSnapshot tx)
instance GHC.Generics.Generic (Hydra.HeadLogic.State.CoordinatedHeadState tx)
instance GHC.Generics.Generic (Hydra.HeadLogic.State.OpenState tx)
instance GHC.Generics.Generic (Hydra.HeadLogic.State.ClosedState tx)
instance GHC.Generics.Generic (Hydra.HeadLogic.State.HeadState tx)
instance (Hydra.Ledger.IsTx tx, GHC.Classes.Eq (Hydra.Chain.ChainStateType tx)) => GHC.Classes.Eq (Hydra.HeadLogic.State.HeadState tx)
instance (Hydra.Ledger.IsTx tx, GHC.Show.Show (Hydra.Chain.ChainStateType tx)) => GHC.Show.Show (Hydra.HeadLogic.State.HeadState tx)
instance (Hydra.Ledger.IsTx tx, Data.Aeson.Types.ToJSON.ToJSON (Hydra.Chain.ChainStateType tx)) => Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.State.HeadState tx)
instance (Hydra.Ledger.IsTx tx, Data.Aeson.Types.FromJSON.FromJSON (Hydra.Chain.ChainStateType tx)) => Data.Aeson.Types.FromJSON.FromJSON (Hydra.HeadLogic.State.HeadState tx)
instance GHC.Classes.Eq (Hydra.Chain.ChainStateType tx) => GHC.Classes.Eq (Hydra.HeadLogic.State.IdleState tx)
instance GHC.Show.Show (Hydra.Chain.ChainStateType tx) => GHC.Show.Show (Hydra.HeadLogic.State.IdleState tx)
instance Data.Aeson.Types.ToJSON.ToJSON (Hydra.Chain.ChainStateType tx) => Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.State.IdleState tx)
instance Data.Aeson.Types.FromJSON.FromJSON (Hydra.Chain.ChainStateType tx) => Data.Aeson.Types.FromJSON.FromJSON (Hydra.HeadLogic.State.IdleState tx)
instance (Hydra.Ledger.IsTx tx, GHC.Classes.Eq (Hydra.Chain.ChainStateType tx)) => GHC.Classes.Eq (Hydra.HeadLogic.State.InitialState tx)
instance (Hydra.Ledger.IsTx tx, GHC.Show.Show (Hydra.Chain.ChainStateType tx)) => GHC.Show.Show (Hydra.HeadLogic.State.InitialState tx)
instance (Hydra.Ledger.IsTx tx, Data.Aeson.Types.ToJSON.ToJSON (Hydra.Chain.ChainStateType tx)) => Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.State.InitialState tx)
instance (Hydra.Ledger.IsTx tx, Data.Aeson.Types.FromJSON.FromJSON (Hydra.Chain.ChainStateType tx)) => Data.Aeson.Types.FromJSON.FromJSON (Hydra.HeadLogic.State.InitialState tx)
instance (Hydra.Ledger.IsTx tx, GHC.Classes.Eq (Hydra.Chain.ChainStateType tx)) => GHC.Classes.Eq (Hydra.HeadLogic.State.OpenState tx)
instance (Hydra.Ledger.IsTx tx, GHC.Show.Show (Hydra.Chain.ChainStateType tx)) => GHC.Show.Show (Hydra.HeadLogic.State.OpenState tx)
instance (Hydra.Ledger.IsTx tx, Data.Aeson.Types.ToJSON.ToJSON (Hydra.Chain.ChainStateType tx)) => Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.State.OpenState tx)
instance (Hydra.Ledger.IsTx tx, Data.Aeson.Types.FromJSON.FromJSON (Hydra.Chain.ChainStateType tx)) => Data.Aeson.Types.FromJSON.FromJSON (Hydra.HeadLogic.State.OpenState tx)
instance Hydra.Ledger.IsTx tx => GHC.Classes.Eq (Hydra.HeadLogic.State.CoordinatedHeadState tx)
instance Hydra.Ledger.IsTx tx => GHC.Show.Show (Hydra.HeadLogic.State.CoordinatedHeadState tx)
instance Hydra.Ledger.IsTx tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.State.CoordinatedHeadState tx)
instance Hydra.Ledger.IsTx tx => Data.Aeson.Types.FromJSON.FromJSON (Hydra.HeadLogic.State.CoordinatedHeadState tx)
instance Hydra.Ledger.IsTx tx => GHC.Classes.Eq (Hydra.HeadLogic.State.SeenSnapshot tx)
instance Hydra.Ledger.IsTx tx => GHC.Show.Show (Hydra.HeadLogic.State.SeenSnapshot tx)
instance Hydra.Ledger.IsTx tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.State.SeenSnapshot tx)
instance Hydra.Ledger.IsTx tx => Data.Aeson.Types.FromJSON.FromJSON (Hydra.HeadLogic.State.SeenSnapshot tx)
instance (Hydra.Ledger.IsTx tx, GHC.Classes.Eq (Hydra.Chain.ChainStateType tx)) => GHC.Classes.Eq (Hydra.HeadLogic.State.ClosedState tx)
instance (Hydra.Ledger.IsTx tx, GHC.Show.Show (Hydra.Chain.ChainStateType tx)) => GHC.Show.Show (Hydra.HeadLogic.State.ClosedState tx)
instance (Hydra.Ledger.IsTx tx, Data.Aeson.Types.ToJSON.ToJSON (Hydra.Chain.ChainStateType tx)) => Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.State.ClosedState tx)
instance (Hydra.Ledger.IsTx tx, Data.Aeson.Types.FromJSON.FromJSON (Hydra.Chain.ChainStateType tx)) => Data.Aeson.Types.FromJSON.FromJSON (Hydra.HeadLogic.State.ClosedState tx)
instance (Hydra.Ledger.IsTx tx, Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Chain.ChainStateType tx)) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.HeadLogic.State.HeadState tx)
instance (Hydra.Ledger.IsTx tx, Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Chain.ChainStateType tx)) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.HeadLogic.State.ClosedState tx)
instance (Hydra.Ledger.IsTx tx, Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Chain.ChainStateType tx)) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.HeadLogic.State.OpenState tx)
instance Hydra.Ledger.IsTx tx => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.HeadLogic.State.CoordinatedHeadState tx)
instance Hydra.Ledger.IsTx tx => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.HeadLogic.State.SeenSnapshot tx)
instance (Hydra.Ledger.IsTx tx, Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Chain.ChainStateType tx)) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.HeadLogic.State.InitialState tx)
instance Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Chain.ChainStateType tx) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.HeadLogic.State.IdleState tx)
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.HeadLogic.State.Environment

module Hydra.HeadLogic.SnapshotOutcome
data SnapshotOutcome tx
ShouldSnapshot :: SnapshotNumber -> [tx] -> SnapshotOutcome tx
ShouldNotSnapshot :: NoSnapshotReason -> SnapshotOutcome tx
data NoSnapshotReason
NotLeader :: SnapshotNumber -> NoSnapshotReason
SnapshotInFlight :: SnapshotNumber -> NoSnapshotReason
NoTransactionsToSnapshot :: NoSnapshotReason
isLeader :: HeadParameters -> Party -> SnapshotNumber -> Bool
instance GHC.Generics.Generic Hydra.HeadLogic.SnapshotOutcome.NoSnapshotReason
instance GHC.Show.Show Hydra.HeadLogic.SnapshotOutcome.NoSnapshotReason
instance GHC.Classes.Eq Hydra.HeadLogic.SnapshotOutcome.NoSnapshotReason
instance GHC.Generics.Generic (Hydra.HeadLogic.SnapshotOutcome.SnapshotOutcome tx)
instance GHC.Show.Show tx => GHC.Show.Show (Hydra.HeadLogic.SnapshotOutcome.SnapshotOutcome tx)
instance GHC.Classes.Eq tx => GHC.Classes.Eq (Hydra.HeadLogic.SnapshotOutcome.SnapshotOutcome tx)

module Hydra.HeadLogic.Event
type TTL = Natural

-- | The different events which are processed by the head logic (the
--   "core"). Corresponding to each of the "shell" layers, we distinguish
--   between events from the client, the network and the chain.
data Event tx

-- | Event received from clients via the <a>Hydra.API</a>.
ClientEvent :: ClientInput tx -> Event tx
[clientInput] :: Event tx -> ClientInput tx

-- | Event received from peers via a <a>Hydra.Network</a>.
--   
--   <ul>
--   <li><a>ttl</a> is a simple counter that's decreased every time the
--   event is reenqueued due to a wait. It's default value is
--   <tt>defaultTTL</tt></li>
--   </ul>
NetworkEvent :: TTL -> Party -> Message tx -> Event tx
[ttl] :: Event tx -> TTL
[party] :: Event tx -> Party
[message] :: Event tx -> Message tx

-- | Event received from the chain via a <a>Hydra.Chain</a>.
OnChainEvent :: ChainEvent tx -> Event tx
[chainEvent] :: Event tx -> ChainEvent tx

-- | Event to re-ingest errors from <tt>postTx</tt> for further processing.
PostTxError :: PostChainTx tx -> PostTxError tx -> Event tx
[postChainTx] :: Event tx -> PostChainTx tx
[postTxError] :: Event tx -> PostTxError tx
instance GHC.Generics.Generic (Hydra.HeadLogic.Event.Event tx)
instance Hydra.Chain.IsChainState tx => GHC.Classes.Eq (Hydra.HeadLogic.Event.Event tx)
instance Hydra.Chain.IsChainState tx => GHC.Show.Show (Hydra.HeadLogic.Event.Event tx)
instance Hydra.Chain.IsChainState tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.Event.Event tx)
instance Hydra.Chain.IsChainState tx => Data.Aeson.Types.FromJSON.FromJSON (Hydra.HeadLogic.Event.Event tx)
instance (Hydra.Ledger.IsTx tx, Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Chain.ChainStateType tx)) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.HeadLogic.Event.Event tx)

module Hydra.HeadLogic.Error

-- | Preliminary type for collecting errors occurring during
--   <tt>update</tt>. TODO: Try to merge this (back) into <tt>Outcome</tt>.
data LogicError tx
InvalidEvent :: Event tx -> HeadState tx -> LogicError tx
RequireFailed :: RequirementFailure tx -> LogicError tx
NotOurHead :: HeadId -> HeadId -> LogicError tx
[ourHeadId] :: LogicError tx -> HeadId
[otherHeadId] :: LogicError tx -> HeadId
data RequirementFailure tx
ReqSnNumberInvalid :: SnapshotNumber -> SnapshotNumber -> RequirementFailure tx
[requestedSn] :: RequirementFailure tx -> SnapshotNumber
[lastSeenSn] :: RequirementFailure tx -> SnapshotNumber
ReqSnNotLeader :: SnapshotNumber -> Party -> RequirementFailure tx
[requestedSn] :: RequirementFailure tx -> SnapshotNumber
[leader] :: RequirementFailure tx -> Party
InvalidMultisignature :: Text -> [VerificationKey HydraKey] -> RequirementFailure tx
[multisig] :: RequirementFailure tx -> Text
[vkeys] :: RequirementFailure tx -> [VerificationKey HydraKey]
SnapshotAlreadySigned :: [Party] -> Party -> RequirementFailure tx
[knownSignatures] :: RequirementFailure tx -> [Party]
[receivedSignature] :: RequirementFailure tx -> Party
AckSnNumberInvalid :: SnapshotNumber -> SnapshotNumber -> RequirementFailure tx
[requestedSn] :: RequirementFailure tx -> SnapshotNumber
[lastSeenSn] :: RequirementFailure tx -> SnapshotNumber
SnapshotDoesNotApply :: SnapshotNumber -> TxIdType tx -> ValidationError -> RequirementFailure tx
[requestedSn] :: RequirementFailure tx -> SnapshotNumber
[txid] :: RequirementFailure tx -> TxIdType tx
[error] :: RequirementFailure tx -> ValidationError
instance GHC.Generics.Generic (Hydra.HeadLogic.Error.RequirementFailure tx)
instance GHC.Generics.Generic (Hydra.HeadLogic.Error.LogicError tx)
instance (GHC.Classes.Eq (Hydra.HeadLogic.State.HeadState tx), GHC.Classes.Eq (Hydra.HeadLogic.Event.Event tx), GHC.Classes.Eq (Hydra.HeadLogic.Error.RequirementFailure tx)) => GHC.Classes.Eq (Hydra.HeadLogic.Error.LogicError tx)
instance (GHC.Show.Show (Hydra.HeadLogic.State.HeadState tx), GHC.Show.Show (Hydra.HeadLogic.Event.Event tx), GHC.Show.Show (Hydra.HeadLogic.Error.RequirementFailure tx)) => GHC.Show.Show (Hydra.HeadLogic.Error.LogicError tx)
instance (Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.State.HeadState tx), Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.Event.Event tx), Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.Error.RequirementFailure tx)) => Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.Error.LogicError tx)
instance (Data.Aeson.Types.FromJSON.FromJSON (Hydra.HeadLogic.State.HeadState tx), Data.Aeson.Types.FromJSON.FromJSON (Hydra.HeadLogic.Event.Event tx), Data.Aeson.Types.FromJSON.FromJSON (Hydra.HeadLogic.Error.RequirementFailure tx)) => Data.Aeson.Types.FromJSON.FromJSON (Hydra.HeadLogic.Error.LogicError tx)
instance GHC.Classes.Eq (Hydra.Ledger.TxIdType tx) => GHC.Classes.Eq (Hydra.HeadLogic.Error.RequirementFailure tx)
instance GHC.Show.Show (Hydra.Ledger.TxIdType tx) => GHC.Show.Show (Hydra.HeadLogic.Error.RequirementFailure tx)
instance Data.Aeson.Types.ToJSON.ToJSON (Hydra.Ledger.TxIdType tx) => Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.Error.RequirementFailure tx)
instance Data.Aeson.Types.FromJSON.FromJSON (Hydra.Ledger.TxIdType tx) => Data.Aeson.Types.FromJSON.FromJSON (Hydra.HeadLogic.Error.RequirementFailure tx)
instance (Data.Typeable.Internal.Typeable tx, GHC.Show.Show (Hydra.HeadLogic.Event.Event tx), GHC.Show.Show (Hydra.HeadLogic.State.HeadState tx), GHC.Show.Show (Hydra.HeadLogic.Error.RequirementFailure tx)) => GHC.Exception.Type.Exception (Hydra.HeadLogic.Error.LogicError tx)
instance (Test.QuickCheck.Arbitrary.Arbitrary (Hydra.HeadLogic.Event.Event tx), Test.QuickCheck.Arbitrary.Arbitrary (Hydra.HeadLogic.State.HeadState tx), Test.QuickCheck.Arbitrary.Arbitrary (Hydra.HeadLogic.Error.RequirementFailure tx)) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.HeadLogic.Error.LogicError tx)
instance Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Ledger.TxIdType tx) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.HeadLogic.Error.RequirementFailure tx)


-- | Smart constructors for creating Hydra protocol transactions to be used
--   in the <a>Direct</a> way of talking to the main-chain.
--   
--   This module also encapsulates the transaction format used when talking
--   to the cardano-node, which is currently different from the
--   <a>Cardano</a>, thus we have not yet "reached" <tt>isomorphism</tt>.
module Hydra.Chain.Direct.Tx

-- | Needed on-chain data to create Head transactions.
type UTxOWithScript = (TxIn, TxOut CtxUTxO, HashableScriptData)
newtype UTxOHash
UTxOHash :: ByteString -> UTxOHash

-- | Representation of the Head output after an Init transaction.
data InitialThreadOutput
InitialThreadOutput :: UTxOWithScript -> ContestationPeriod -> [Party] -> InitialThreadOutput
[$sel:initialThreadUTxO:InitialThreadOutput] :: InitialThreadOutput -> UTxOWithScript
[$sel:initialContestationPeriod:InitialThreadOutput] :: InitialThreadOutput -> ContestationPeriod
[$sel:initialParties:InitialThreadOutput] :: InitialThreadOutput -> [Party]

-- | Representation of the Head output after a CollectCom transaction.
data OpenThreadOutput
OpenThreadOutput :: UTxOWithScript -> ContestationPeriod -> [Party] -> OpenThreadOutput
[$sel:openThreadUTxO:OpenThreadOutput] :: OpenThreadOutput -> UTxOWithScript
[$sel:openContestationPeriod:OpenThreadOutput] :: OpenThreadOutput -> ContestationPeriod
[$sel:openParties:OpenThreadOutput] :: OpenThreadOutput -> [Party]
data ClosedThreadOutput
ClosedThreadOutput :: UTxOWithScript -> [Party] -> POSIXTime -> [PubKeyHash] -> ClosedThreadOutput
[$sel:closedThreadUTxO:ClosedThreadOutput] :: ClosedThreadOutput -> UTxOWithScript
[$sel:closedParties:ClosedThreadOutput] :: ClosedThreadOutput -> [Party]
[$sel:closedContestationDeadline:ClosedThreadOutput] :: ClosedThreadOutput -> POSIXTime
[$sel:closedContesters:ClosedThreadOutput] :: ClosedThreadOutput -> [PubKeyHash]
hydraHeadV1AssetName :: AssetName
headValue :: Value

-- | Create the init transaction from some <a>HeadParameters</a> and a
--   single TxIn which will be used as unique parameter for minting NFTs.
initTx :: NetworkId -> [VerificationKey PaymentKey] -> HeadParameters -> TxIn -> Tx
mkHeadOutput :: NetworkId -> PolicyId -> TxOutDatum ctx -> TxOut ctx
mkHeadOutputInitial :: NetworkId -> TxIn -> HeadParameters -> TxOut CtxTx
mkInitialOutput :: NetworkId -> TxIn -> VerificationKey PaymentKey -> TxOut CtxTx

-- | Craft a commit transaction which includes the "committed" utxo as a
--   datum.
commitTx :: NetworkId -> ScriptRegistry -> HeadId -> Party -> UTxO' (TxOut CtxUTxO, Witness WitCtxTxIn) -> (TxIn, TxOut CtxUTxO, Hash PaymentKey) -> Tx
mkCommitDatum :: Party -> UTxO -> CurrencySymbol -> Datum

-- | Create a transaction collecting all "committed" utxo and opening a
--   Head, i.e. driving the Head script state.
collectComTx :: NetworkId -> ScriptRegistry -> VerificationKey PaymentKey -> InitialThreadOutput -> Map TxIn (TxOut CtxUTxO, HashableScriptData) -> HeadId -> Tx

-- | Low-level data type of a snapshot to close the head with. This is
--   different to the <tt>ConfirmedSnasphot</tt>, which is provided to
--   <tt>CloseTx</tt> as it also contains relevant chain state like the
--   <a>$sel:openUtxoHash:CloseWithInitialSnapshot</a>.
data ClosingSnapshot
CloseWithInitialSnapshot :: UTxOHash -> ClosingSnapshot
[$sel:openUtxoHash:CloseWithInitialSnapshot] :: ClosingSnapshot -> UTxOHash
CloseWithConfirmedSnapshot :: SnapshotNumber -> UTxOHash -> MultiSignature (Snapshot Tx) -> ClosingSnapshot
[$sel:snapshotNumber:CloseWithInitialSnapshot] :: ClosingSnapshot -> SnapshotNumber
[$sel:closeUtxoHash:CloseWithInitialSnapshot] :: ClosingSnapshot -> UTxOHash
[$sel:signatures:CloseWithInitialSnapshot] :: ClosingSnapshot -> MultiSignature (Snapshot Tx)

-- | Create a transaction closing a head with either the initial snapshot
--   or with a multi-signed confirmed snapshot.
closeTx :: ScriptRegistry -> VerificationKey PaymentKey -> ClosingSnapshot -> SlotNo -> PointInTime -> OpenThreadOutput -> HeadId -> Tx
contestTx :: ScriptRegistry -> VerificationKey PaymentKey -> Snapshot Tx -> MultiSignature (Snapshot Tx) -> PointInTime -> ClosedThreadOutput -> HeadId -> ContestationPeriod -> Tx

-- | Create the fanout transaction, which distributes the closed state
--   accordingly. The head validator allows fanout only &gt; deadline, so
--   we need to set the lower bound to be deadline + 1 slot.
fanoutTx :: ScriptRegistry -> UTxO -> UTxOWithScript -> SlotNo -> PlutusScript -> Tx
data AbortTxError
OverlappingInputs :: AbortTxError

-- | Create transaction which aborts a head by spending the Head output and
--   all other "initial" outputs.
abortTx :: UTxO -> ScriptRegistry -> VerificationKey PaymentKey -> (TxIn, TxOut CtxUTxO, HashableScriptData) -> PlutusScript -> Map TxIn (TxOut CtxUTxO, HashableScriptData) -> Map TxIn (TxOut CtxUTxO, HashableScriptData) -> Either AbortTxError Tx
data InitObservation
InitObservation :: InitialThreadOutput -> [UTxOWithScript] -> [UTxOWithScript] -> HeadId -> TxIn -> ContestationPeriod -> [Party] -> InitObservation

-- | The state machine UTxO produced by the Init transaction This output
--   should always be present and <tt>threaded</tt> across all
--   transactions. NOTE(SN): The Head's identifier is somewhat encoded in
--   the TxOut's address XXX(SN): Data and [OnChain.Party] are overlapping
[$sel:threadOutput:InitObservation] :: InitObservation -> InitialThreadOutput
[$sel:initials:InitObservation] :: InitObservation -> [UTxOWithScript]
[$sel:commits:InitObservation] :: InitObservation -> [UTxOWithScript]
[$sel:headId:InitObservation] :: InitObservation -> HeadId
[$sel:seedTxIn:InitObservation] :: InitObservation -> TxIn
[$sel:contestationPeriod:InitObservation] :: InitObservation -> ContestationPeriod
[$sel:parties:InitObservation] :: InitObservation -> [Party]
data NotAnInitReason
NotAHeadPolicy :: NotAnInitReason
NoHeadOutput :: NotAnInitReason
NotAHeadDatum :: NotAnInitReason
NoSTFound :: NotAnInitReason
PartiesMismatch :: NotAnInitReason
OwnPartyMissing :: NotAnInitReason
CPMismatch :: NotAnInitReason
PTsNotMintedCorrectly :: NotAnInitReason
observeInitTx :: NetworkId -> [VerificationKey PaymentKey] -> ContestationPeriod -> Party -> [Party] -> Tx -> Either NotAnInitReason InitObservation
data CommitObservation
CommitObservation :: UTxOWithScript -> Party -> UTxO -> CommitObservation
[$sel:commitOutput:CommitObservation] :: CommitObservation -> UTxOWithScript
[$sel:party:CommitObservation] :: CommitObservation -> Party
[$sel:committed:CommitObservation] :: CommitObservation -> UTxO

-- | Identify a commit tx by:
--   
--   <ul>
--   <li>Find which <tt>initial</tt> tx input is being consumed,</li>
--   <li>Find the redeemer corresponding to that <tt>initial</tt>, which
--   contains the tx input of the committed utxo,</li>
--   <li>Find the outputs which pays to the commit validator,</li>
--   <li>Using the datum of that output, deserialize the committed
--   output,</li>
--   <li>Reconstruct the committed UTxO from both values (tx input and
--   output).</li>
--   </ul>
observeCommitTx :: NetworkId -> [TxIn] -> Tx -> Maybe CommitObservation
data CollectComObservation
CollectComObservation :: OpenThreadOutput -> HeadId -> UTxOHash -> CollectComObservation
[$sel:threadOutput:CollectComObservation] :: CollectComObservation -> OpenThreadOutput
[$sel:headId:CollectComObservation] :: CollectComObservation -> HeadId
[$sel:utxoHash:CollectComObservation] :: CollectComObservation -> UTxOHash

-- | Identify a collectCom tx by lookup up the input spending the Head
--   output and decoding its redeemer.
observeCollectComTx :: UTxO -> Tx -> Maybe CollectComObservation
data CloseObservation
CloseObservation :: ClosedThreadOutput -> HeadId -> SnapshotNumber -> CloseObservation
[$sel:threadOutput:CloseObservation] :: CloseObservation -> ClosedThreadOutput
[$sel:headId:CloseObservation] :: CloseObservation -> HeadId
[$sel:snapshotNumber:CloseObservation] :: CloseObservation -> SnapshotNumber

-- | Identify a close tx by lookup up the input spending the Head output
--   and decoding its redeemer.
observeCloseTx :: UTxO -> Tx -> Maybe CloseObservation
data ContestObservation
ContestObservation :: (TxIn, TxOut CtxUTxO, HashableScriptData) -> HeadId -> SnapshotNumber -> [PubKeyHash] -> ContestObservation
[$sel:contestedThreadOutput:ContestObservation] :: ContestObservation -> (TxIn, TxOut CtxUTxO, HashableScriptData)
[$sel:headId:ContestObservation] :: ContestObservation -> HeadId
[$sel:snapshotNumber:ContestObservation] :: ContestObservation -> SnapshotNumber
[$sel:contesters:ContestObservation] :: ContestObservation -> [PubKeyHash]

-- | Identify a close tx by lookup up the input spending the Head output
--   and decoding its redeemer.
observeContestTx :: UTxO -> Tx -> Maybe ContestObservation
data FanoutObservation
FanoutObservation :: FanoutObservation

-- | Identify a fanout tx by lookup up the input spending the Head output
--   and decoding its redeemer.
observeFanoutTx :: UTxO -> Tx -> Maybe FanoutObservation
data AbortObservation
AbortObservation :: AbortObservation

-- | Identify an abort tx by looking up the input spending the Head output
--   and decoding its redeemer. FIXME: Add headId to AbortObservation to
--   allow "upper layers" to determine we are seeing an abort of "our head"
observeAbortTx :: UTxO -> Tx -> Maybe AbortObservation
mkHeadId :: PolicyId -> HeadId
headIdToCurrencySymbol :: HeadId -> CurrencySymbol
headTokensFromValue :: PlutusScript -> Value -> [(AssetName, Quantity)]
assetNameFromVerificationKey :: VerificationKey PaymentKey -> AssetName

-- | Find first occurrence including a transformation.
findFirst :: Foldable t => (a -> Maybe b) -> t a -> Maybe b
findHeadAssetId :: TxOut ctx -> Maybe (PolicyId, AssetName)

-- | Find (if it exists) the head identifier contained in given
--   <a>TxOut</a>.
findStateToken :: TxOut ctx -> Maybe HeadId
instance GHC.Generics.Generic Hydra.Chain.Direct.Tx.UTxOHash
instance GHC.Show.Show Hydra.Chain.Direct.Tx.UTxOHash
instance GHC.Classes.Eq Hydra.Chain.Direct.Tx.UTxOHash
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Chain.Direct.Tx.InitialThreadOutput
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Chain.Direct.Tx.InitialThreadOutput
instance GHC.Generics.Generic Hydra.Chain.Direct.Tx.InitialThreadOutput
instance GHC.Show.Show Hydra.Chain.Direct.Tx.InitialThreadOutput
instance GHC.Classes.Eq Hydra.Chain.Direct.Tx.InitialThreadOutput
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Chain.Direct.Tx.OpenThreadOutput
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Chain.Direct.Tx.OpenThreadOutput
instance GHC.Generics.Generic Hydra.Chain.Direct.Tx.OpenThreadOutput
instance GHC.Show.Show Hydra.Chain.Direct.Tx.OpenThreadOutput
instance GHC.Classes.Eq Hydra.Chain.Direct.Tx.OpenThreadOutput
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Chain.Direct.Tx.ClosedThreadOutput
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Chain.Direct.Tx.ClosedThreadOutput
instance GHC.Generics.Generic Hydra.Chain.Direct.Tx.ClosedThreadOutput
instance GHC.Show.Show Hydra.Chain.Direct.Tx.ClosedThreadOutput
instance GHC.Classes.Eq Hydra.Chain.Direct.Tx.ClosedThreadOutput
instance GHC.Show.Show Hydra.Chain.Direct.Tx.AbortTxError
instance GHC.Classes.Eq Hydra.Chain.Direct.Tx.InitObservation
instance GHC.Show.Show Hydra.Chain.Direct.Tx.InitObservation
instance GHC.Classes.Eq Hydra.Chain.Direct.Tx.NotAnInitReason
instance GHC.Show.Show Hydra.Chain.Direct.Tx.NotAnInitReason
instance GHC.Classes.Eq Hydra.Chain.Direct.Tx.CollectComObservation
instance GHC.Show.Show Hydra.Chain.Direct.Tx.CollectComObservation
instance GHC.Classes.Eq Hydra.Chain.Direct.Tx.CloseObservation
instance GHC.Show.Show Hydra.Chain.Direct.Tx.CloseObservation
instance GHC.Classes.Eq Hydra.Chain.Direct.Tx.ContestObservation
instance GHC.Show.Show Hydra.Chain.Direct.Tx.ContestObservation
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Chain.Direct.Tx.UTxOHash
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Chain.Direct.Tx.UTxOHash


-- | Contains the a state-ful interface to transaction construction and
--   observation.
--   
--   It defines the 'ChainStateType tx' to be used in the <a>Direct</a>
--   layer and it's constituents.
module Hydra.Chain.Direct.State

-- | A class for accessing the known <a>UTxO'</a> set in a type. This is
--   useful to get all the relevant UTxO for resolving transaction inputs.
class HasKnownUTxO a
getKnownUTxO :: HasKnownUTxO a => a -> UTxO

-- | The chain state used by the Hydra.Chain.Direct implementation. It
--   records the actual <a>ChainState</a> paired with a <a>ChainSlot</a>
--   (used to know up to which point to rewind on rollbacks).
data ChainStateAt
ChainStateAt :: ChainState -> Maybe ChainPoint -> ChainStateAt
[$sel:chainState:ChainStateAt] :: ChainStateAt -> ChainState
[$sel:recordedAt:ChainStateAt] :: ChainStateAt -> Maybe ChainPoint

-- | Get a generic <a>ChainSlot</a> from a Cardano <a>ChainPoint</a>. Slot
--   0 is used for the genesis point.
chainSlotFromPoint :: ChainPoint -> ChainSlot

-- | A definition of all transitions between <a>ChainState</a>s. Enumerable
--   and bounded to be used as labels for checking coverage.
data ChainTransition
Init :: ChainTransition
Commit :: ChainTransition
Collect :: ChainTransition
Close :: ChainTransition
Contest :: ChainTransition
Fanout :: ChainTransition

-- | An enumeration of all possible on-chain states of a Hydra Head, where
--   each case stores the relevant information to construct &amp; observe
--   transactions to other states.
data ChainState

-- | The idle state does not contain any head-specific information and
--   exists to be used as a starting and terminal state.
Idle :: ChainState
Initial :: InitialState -> ChainState
Open :: OpenState -> ChainState
Closed :: ClosedState -> ChainState

-- | Defines the starting state of the direct chain layer.
initialChainState :: ChainStateType Tx

-- | Read-only chain-specific data. This is different to
--   <a>HydraContext</a> as it only contains data known to single peer.
data ChainContext
ChainContext :: NetworkId -> [VerificationKey PaymentKey] -> VerificationKey PaymentKey -> Party -> [Party] -> ScriptRegistry -> ContestationPeriod -> ChainContext
[$sel:networkId:ChainContext] :: ChainContext -> NetworkId
[$sel:peerVerificationKeys:ChainContext] :: ChainContext -> [VerificationKey PaymentKey]
[$sel:ownVerificationKey:ChainContext] :: ChainContext -> VerificationKey PaymentKey
[$sel:ownParty:ChainContext] :: ChainContext -> Party
[$sel:otherParties:ChainContext] :: ChainContext -> [Party]
[$sel:scriptRegistry:ChainContext] :: ChainContext -> ScriptRegistry
[$sel:contestationPeriod:ChainContext] :: ChainContext -> ContestationPeriod

-- | Get all cardano verification keys available in the chain context.
allVerificationKeys :: ChainContext -> [VerificationKey PaymentKey]
data InitialState
InitialState :: InitialThreadOutput -> [UTxOWithScript] -> [UTxOWithScript] -> HeadId -> TxIn -> InitialState
[$sel:initialThreadOutput:InitialState] :: InitialState -> InitialThreadOutput
[$sel:initialInitials:InitialState] :: InitialState -> [UTxOWithScript]
[$sel:initialCommits:InitialState] :: InitialState -> [UTxOWithScript]
[$sel:headId:InitialState] :: InitialState -> HeadId
[$sel:seedTxIn:InitialState] :: InitialState -> TxIn
data OpenState
OpenState :: OpenThreadOutput -> HeadId -> TxIn -> UTxOHash -> OpenState
[$sel:openThreadOutput:OpenState] :: OpenState -> OpenThreadOutput
[$sel:headId:OpenState] :: OpenState -> HeadId
[$sel:seedTxIn:OpenState] :: OpenState -> TxIn
[$sel:openUtxoHash:OpenState] :: OpenState -> UTxOHash
data ClosedState
ClosedState :: ClosedThreadOutput -> HeadId -> TxIn -> ClosedState
[$sel:closedThreadOutput:ClosedState] :: ClosedState -> ClosedThreadOutput
[$sel:headId:ClosedState] :: ClosedState -> HeadId
[$sel:seedTxIn:ClosedState] :: ClosedState -> TxIn

-- | Construct an init transaction given some general <a>ChainContext</a>,
--   the <a>HeadParameters</a> and a seed <a>TxIn</a> which will be spent.
initialize :: ChainContext -> HeadParameters -> TxIn -> Tx

-- | Construct a commit transaction based on the <a>InitialState</a>. This
--   does look for "our initial output" to spend and check the given
--   <a>UTxO'</a> to be compatible. Hence, this function does fail if
--   already committed.
--   
--   NOTE: This version of <a>commit</a> does only commit outputs which are
--   held by payment keys. For a variant which supports committing scripts,
--   see <a>commit</a>`.
commit :: ChainContext -> InitialState -> UTxO' (TxOut CtxUTxO) -> Either (PostTxError Tx) Tx

-- | Construct a commit transaction base on the <a>InitialState</a> and
--   some arbitrary UTxOs to commit.
--   
--   NOTE: A simpler variant only supporting pubkey outputs is
--   <a>commit</a>.
commit' :: ChainContext -> InitialState -> UTxO' (TxOut CtxUTxO, Witness WitCtxTxIn) -> Either (PostTxError Tx) Tx
ownInitial :: ChainContext -> InitialState -> Maybe (TxIn, TxOut CtxUTxO, Hash PaymentKey)
hasMatchingPT :: InitialState -> Hash PaymentKey -> Value -> Bool
rejectByronAddress :: UTxO -> Either (PostTxError Tx) ()
rejectReferenceScripts :: UTxO -> Either (PostTxError Tx) ()
rejectMoreThanMainnetLimit :: NetworkId -> UTxO -> Either (PostTxError Tx) ()

-- | Construct a collect transaction based on the <a>InitialState</a>. This
--   will reimburse all the already committed outputs.
abort :: HasCallStack => ChainContext -> InitialState -> UTxO -> Tx

-- | Construct a collect transaction based on the <a>InitialState</a>. This
--   will know collect all the committed outputs.
collect :: ChainContext -> InitialState -> Tx

-- | Construct a close transaction based on the <a>OpenState</a> and a
--   confirmed snapshot. - <a>SlotNo</a> parameter will be used as the
--   <a>Tx</a> lower bound. - <a>PointInTime</a> parameter will be used as
--   an upper validity bound and will define the start of the contestation
--   period. NB: lower and upper bound slot difference should not exceed
--   contestation period
close :: ChainContext -> OpenState -> ConfirmedSnapshot Tx -> SlotNo -> PointInTime -> Tx

-- | Construct a contest transaction based on the <a>ClosedState</a> and a
--   confirmed snapshot. The given <a>PointInTime</a> will be used as an
--   upper validity bound and needs to be before the deadline.
contest :: ChainContext -> ClosedState -> ConfirmedSnapshot Tx -> PointInTime -> Tx

-- | Construct a fanout transaction based on the <a>ClosedState</a> and
--   off-chain agreed <a>UTxO'</a> set to fan out.
fanout :: ChainContext -> ClosedState -> UTxO -> SlotNo -> Tx

-- | Observe a transition without knowing the starting or ending state.
--   This function should try to observe all relevant transitions given
--   some <a>ChainState</a>.
observeSomeTx :: ChainContext -> ChainState -> Tx -> Maybe (OnChainTx Tx, ChainState)

-- | Observe an init transition using a <a>InitialState</a> and
--   <a>observeInitTx</a>.
observeInit :: ChainContext -> Tx -> Either NotAnInitReason (OnChainTx Tx, InitialState)

-- | Observe an commit transition using a <a>InitialState</a> and
--   <a>observeCommitTx</a>.
observeCommit :: ChainContext -> InitialState -> Tx -> Maybe (OnChainTx Tx, InitialState)

-- | Observe an collect transition using a <a>InitialState</a> and
--   <a>observeCollectComTx</a>. This function checks the head id and
--   ignores if not relevant.
observeCollect :: InitialState -> Tx -> Maybe (OnChainTx Tx, OpenState)

-- | Observe an abort transition using a <a>InitialState</a> and
--   <a>observeAbortTx</a>.
observeAbort :: InitialState -> Tx -> Maybe (OnChainTx Tx)

-- | Observe a close transition using a <a>OpenState</a> and
--   <a>observeCloseTx</a>. This function checks the head id and ignores if
--   not relevant.
observeClose :: OpenState -> Tx -> Maybe (OnChainTx Tx, ClosedState)

-- | Observe a fanout transition using a <a>ClosedState</a> and
--   <a>observeContestTx</a>. This function checks the head id and ignores
--   if not relevant.
observeContest :: ClosedState -> Tx -> Maybe (OnChainTx Tx, ClosedState)

-- | Observe a fanout transition using a <a>ClosedState</a> and
--   <a>observeFanoutTx</a>.
observeFanout :: ClosedState -> Tx -> Maybe (OnChainTx Tx)

-- | Maximum number of parties used in the generators.
maxGenParties :: Int

-- | Maximum number of assets (ADA or other tokens) used in the generators.
maxGenAssets :: Int

-- | Generate a <a>ChainState</a> within known limits above.
genChainState :: Gen ChainState

-- | Generate a <a>ChainContext</a> and <a>ChainState</a> within the known
--   limits above, along with a transaction that results in a transition
--   away from it.
genChainStateWithTx :: Gen (ChainContext, ChainState, Tx, ChainTransition)

-- | Define some <tt>global</tt> context from which generators can pick
--   values for generation. This allows to write fairly independent
--   generators which however still make sense with one another within the
--   context of a head.
--   
--   For example, one can generate a head's _party_ from that global list,
--   whereas other functions may rely on all parties and thus, we need both
--   generation to be coherent.
--   
--   Do not use this in production code, but only for generating test data.
data HydraContext
HydraContext :: [VerificationKey PaymentKey] -> [SigningKey HydraKey] -> NetworkId -> ContestationPeriod -> ScriptRegistry -> HydraContext
[$sel:ctxVerificationKeys:HydraContext] :: HydraContext -> [VerificationKey PaymentKey]
[$sel:ctxHydraSigningKeys:HydraContext] :: HydraContext -> [SigningKey HydraKey]
[$sel:ctxNetworkId:HydraContext] :: HydraContext -> NetworkId
[$sel:ctxContestationPeriod:HydraContext] :: HydraContext -> ContestationPeriod
[$sel:ctxScriptRegistry:HydraContext] :: HydraContext -> ScriptRegistry
ctxParties :: HydraContext -> [Party]
ctxHeadParameters :: HydraContext -> HeadParameters

-- | Generate a <a>HydraContext</a> for a arbitrary number of parties,
--   bounded by given maximum.
genHydraContext :: Int -> Gen HydraContext

-- | Generate a <a>HydraContext</a> for a given number of parties.
genHydraContextFor :: Int -> Gen HydraContext

-- | Get all peer-specific <a>ChainContext</a>s from a <a>HydraContext</a>.
--   NOTE: This assumes that <a>HydraContext</a> has same length
--   <a>$sel:ctxVerificationKeys:HydraContext</a> and
--   <a>$sel:ctxHydraSigningKeys:HydraContext</a>. XXX: This is actually a
--   non-monadic function.
deriveChainContexts :: HydraContext -> Gen [ChainContext]

-- | Pick one of the participants and derive the peer-specific
--   <a>ChainContext</a> from a <a>HydraContext</a>. NOTE: This assumes
--   that <a>HydraContext</a> has same length
--   <a>$sel:ctxVerificationKeys:HydraContext</a> and
--   <a>$sel:ctxHydraSigningKeys:HydraContext</a>.
pickChainContext :: HydraContext -> Gen ChainContext
genStInitial :: HydraContext -> Gen (ChainContext, InitialState)
genInitTx :: HydraContext -> Gen Tx
genCommits :: HydraContext -> Tx -> Gen [Tx]
genCommits' :: Gen UTxO -> HydraContext -> Tx -> Gen [Tx]
genCommit :: Gen UTxO
genCollectComTx :: Gen (ChainContext, [UTxO], InitialState, Tx)
genCloseTx :: Int -> Gen (ChainContext, OpenState, Tx, ConfirmedSnapshot Tx)
genContestTx :: Gen (HydraContext, PointInTime, ClosedState, Tx)
genFanoutTx :: Int -> Int -> Gen (HydraContext, ClosedState, Tx)
getContestationDeadline :: ClosedState -> UTCTime
genStOpen :: HydraContext -> Gen (UTxO, OpenState)
genStClosed :: HydraContext -> UTxO -> Gen (SnapshotNumber, UTxO, ClosedState)
unsafeCommit :: HasCallStack => ChainContext -> InitialState -> UTxO -> Tx
unsafeObserveInit :: HasCallStack => ChainContext -> Tx -> InitialState
unsafeObserveInitAndCommits :: HasCallStack => ChainContext -> Tx -> [Tx] -> ([UTxO], InitialState)
instance GHC.Enum.Bounded Hydra.Chain.Direct.State.ChainTransition
instance GHC.Enum.Enum Hydra.Chain.Direct.State.ChainTransition
instance GHC.Show.Show Hydra.Chain.Direct.State.ChainTransition
instance GHC.Classes.Eq Hydra.Chain.Direct.State.ChainTransition
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Chain.Direct.State.ChainContext
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Chain.Direct.State.ChainContext
instance GHC.Generics.Generic Hydra.Chain.Direct.State.ChainContext
instance GHC.Show.Show Hydra.Chain.Direct.State.ChainContext
instance GHC.Classes.Eq Hydra.Chain.Direct.State.ChainContext
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Chain.Direct.State.InitialState
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Chain.Direct.State.InitialState
instance GHC.Generics.Generic Hydra.Chain.Direct.State.InitialState
instance GHC.Show.Show Hydra.Chain.Direct.State.InitialState
instance GHC.Classes.Eq Hydra.Chain.Direct.State.InitialState
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Chain.Direct.State.OpenState
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Chain.Direct.State.OpenState
instance GHC.Generics.Generic Hydra.Chain.Direct.State.OpenState
instance GHC.Show.Show Hydra.Chain.Direct.State.OpenState
instance GHC.Classes.Eq Hydra.Chain.Direct.State.OpenState
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Chain.Direct.State.ClosedState
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Chain.Direct.State.ClosedState
instance GHC.Generics.Generic Hydra.Chain.Direct.State.ClosedState
instance GHC.Show.Show Hydra.Chain.Direct.State.ClosedState
instance GHC.Classes.Eq Hydra.Chain.Direct.State.ClosedState
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Chain.Direct.State.ChainState
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Chain.Direct.State.ChainState
instance GHC.Generics.Generic Hydra.Chain.Direct.State.ChainState
instance GHC.Show.Show Hydra.Chain.Direct.State.ChainState
instance GHC.Classes.Eq Hydra.Chain.Direct.State.ChainState
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Chain.Direct.State.ChainStateAt
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Chain.Direct.State.ChainStateAt
instance GHC.Generics.Generic Hydra.Chain.Direct.State.ChainStateAt
instance GHC.Show.Show Hydra.Chain.Direct.State.ChainStateAt
instance GHC.Classes.Eq Hydra.Chain.Direct.State.ChainStateAt
instance GHC.Show.Show Hydra.Chain.Direct.State.HydraContext
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Chain.Direct.State.ChainStateAt
instance Hydra.Chain.IsChainState Hydra.Cardano.Api.Tx
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Chain.Direct.State.ChainState
instance Hydra.Chain.Direct.State.HasKnownUTxO Hydra.Chain.Direct.State.ChainState
instance Hydra.Chain.Direct.State.HasKnownUTxO Hydra.Chain.Direct.State.ClosedState
instance Hydra.Chain.Direct.State.HasKnownUTxO Hydra.Chain.Direct.State.OpenState
instance Hydra.Chain.Direct.State.HasKnownUTxO Hydra.Chain.Direct.State.InitialState
instance Hydra.Chain.Direct.State.HasKnownUTxO Hydra.Chain.Direct.State.ChainContext
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Chain.Direct.State.ChainContext


-- | Provide infrastructure-independent "handlers" for posting transactions
--   and following the chain.
--   
--   This module encapsulates the transformation logic between cardano
--   transactions and <tt>HydraNode</tt> abstractions <a>PostChainTx</a>
--   and <tt>OnChainTx</tt>, and maintainance of on-chain relevant state.
module Hydra.Chain.Direct.Handlers

-- | Handle of a mutable local chain state that is kept in the direct chain
--   layer.
data LocalChainState m tx
LocalChainState :: STM m (ChainStateType tx) -> (ChainStateType tx -> STM m ()) -> (ChainSlot -> STM m (ChainStateType tx)) -> STM m (ChainStateHistory tx) -> LocalChainState m tx
[$sel:getLatest:LocalChainState] :: LocalChainState m tx -> STM m (ChainStateType tx)
[$sel:pushNew:LocalChainState] :: LocalChainState m tx -> ChainStateType tx -> STM m ()
[$sel:rollback:LocalChainState] :: LocalChainState m tx -> ChainSlot -> STM m (ChainStateType tx)
[$sel:history:LocalChainState] :: LocalChainState m tx -> STM m (ChainStateHistory tx)

-- | Initialize a new local chain state from a given chain state history.
newLocalChainState :: (MonadSTM m, IsChainState tx) => ChainStateHistory tx -> m (LocalChainState m tx)

-- | A callback used to actually submit a transaction to the chain.
type SubmitTx m = Tx -> m ()

-- | A way to acquire a <a>TimeHandle</a>
type GetTimeHandle m = m TimeHandle

-- | Create a <a>Chain</a> component for posting "real" cardano
--   transactions.
--   
--   This component does not actually interact with a cardano-node, but
--   creates cardano transactions from <a>PostChainTx</a> transactions
--   emitted by a <tt>HydraNode</tt>, balancing and signing them using
--   given <a>TinyWallet</a>, before handing it off to the given
--   <a>SubmitTx</a> callback. There is also a <tt>draftTx</tt> option for
--   drafting a commit tx on behalf of the user using their selected utxo.
--   
--   NOTE: Given the constraints on <tt>m</tt> this function should work
--   within <tt>IOSim</tt> and does not require any actual <a>IO</a> to
--   happen which makes it highly suitable for simulations and testing.
mkChain :: (MonadSTM m, MonadThrow (STM m)) => Tracer m DirectChainLog -> GetTimeHandle m -> TinyWallet m -> ChainContext -> LocalChainState m Tx -> SubmitTx m -> Chain Tx m

-- | Balance and sign the given partial transaction.
finalizeTx :: MonadThrow m => TinyWallet m -> ChainContext -> ChainStateType Tx -> UTxO -> Tx -> m Tx

-- | A <i>handler</i> that takes care of following the chain.
data ChainSyncHandler m
ChainSyncHandler :: (BlockHeader -> [Tx] -> m ()) -> (ChainPoint -> m ()) -> ChainSyncHandler m
[$sel:onRollForward:ChainSyncHandler] :: ChainSyncHandler m -> BlockHeader -> [Tx] -> m ()
[$sel:onRollBackward:ChainSyncHandler] :: ChainSyncHandler m -> ChainPoint -> m ()

-- | Conversion of a slot number to a time failed. This can be usually be
--   considered an internal error and may be happening because the used era
--   history is too old.
data TimeConversionException
TimeConversionException :: SlotNo -> Text -> TimeConversionException
[$sel:slotNo:TimeConversionException] :: TimeConversionException -> SlotNo
[$sel:reason:TimeConversionException] :: TimeConversionException -> Text

-- | Creates a <a>ChainSyncHandler</a> that can notify the given
--   <tt>callback</tt> of events happening on-chain.
--   
--   This forms the other half of a <tt>ChainComponent</tt> along with
--   <a>mkChain</a> but is decoupled from actual interactions with the
--   chain.
--   
--   A <a>TimeHandle</a> is needed to do `SlotNo -&gt; POSIXTime`
--   conversions for <a>Tick</a> events.
--   
--   Throws <a>TimeConversionException</a> when a received block's
--   <a>SlotNo</a> cannot be converted to a <a>UTCTime</a> with the given
--   <a>TimeHandle</a>.
chainSyncHandler :: forall m. (MonadSTM m, MonadThrow m) => Tracer m DirectChainLog -> ChainCallback Tx m -> GetTimeHandle m -> ChainContext -> LocalChainState m Tx -> ChainSyncHandler m
prepareTxToPost :: (MonadSTM m, MonadThrow (STM m)) => TimeHandle -> TinyWallet m -> ChainContext -> ChainStateType Tx -> PostChainTx Tx -> STM m Tx

-- | Maximum delay we put on the upper bound of transactions to fit into a
--   block. NOTE: This is highly depending on the network. If the security
--   parameter and epoch length result in a short horizon, this is
--   problematic.
maxGraceTime :: NominalDiffTime
data DirectChainLog
ToPost :: PostChainTx Tx -> DirectChainLog
[$sel:toPost:ToPost] :: DirectChainLog -> PostChainTx Tx
PostingTx :: TxId -> DirectChainLog
[$sel:txId:ToPost] :: DirectChainLog -> TxId
PostedTx :: TxId -> DirectChainLog
[$sel:txId:ToPost] :: DirectChainLog -> TxId
PostingFailed :: Tx -> PostTxError Tx -> DirectChainLog
[$sel:tx:ToPost] :: DirectChainLog -> Tx
[$sel:postTxError:ToPost] :: DirectChainLog -> PostTxError Tx
RolledForward :: ChainPoint -> [TxId] -> DirectChainLog
[$sel:point:ToPost] :: DirectChainLog -> ChainPoint
[$sel:receivedTxIds:ToPost] :: DirectChainLog -> [TxId]
RolledBackward :: ChainPoint -> DirectChainLog
[$sel:point:ToPost] :: DirectChainLog -> ChainPoint
Wallet :: TinyWalletLog -> DirectChainLog
instance GHC.Exception.Type.Exception Hydra.Chain.Direct.Handlers.TimeConversionException
instance GHC.Show.Show Hydra.Chain.Direct.Handlers.TimeConversionException
instance GHC.Classes.Eq Hydra.Chain.Direct.Handlers.TimeConversionException
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Chain.Direct.Handlers.DirectChainLog
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Chain.Direct.Handlers.DirectChainLog
instance GHC.Generics.Generic Hydra.Chain.Direct.Handlers.DirectChainLog
instance GHC.Show.Show Hydra.Chain.Direct.Handlers.DirectChainLog
instance GHC.Classes.Eq Hydra.Chain.Direct.Handlers.DirectChainLog
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Chain.Direct.Handlers.DirectChainLog

module Hydra.API.HTTPServer
newtype DraftCommitTxResponse
DraftCommitTxResponse :: Tx -> DraftCommitTxResponse
[commitTx] :: DraftCommitTxResponse -> Tx
data ScriptInfo
ScriptInfo :: HashableScriptData -> Maybe HashableScriptData -> PlutusScript -> ScriptInfo
[redeemer] :: ScriptInfo -> HashableScriptData
[datum] :: ScriptInfo -> Maybe HashableScriptData
[plutusV2Script] :: ScriptInfo -> PlutusScript
data TxOutWithWitness
TxOutWithWitness :: TxOut CtxUTxO -> Maybe ScriptInfo -> TxOutWithWitness
[txOut] :: TxOutWithWitness -> TxOut CtxUTxO
[witness] :: TxOutWithWitness -> Maybe ScriptInfo
newtype DraftCommitTxRequest
DraftCommitTxRequest :: UTxO' TxOutWithWitness -> DraftCommitTxRequest
[utxoToCommit] :: DraftCommitTxRequest -> UTxO' TxOutWithWitness
newtype SubmitTxRequest
SubmitTxRequest :: Tx -> SubmitTxRequest
[txToSubmit] :: SubmitTxRequest -> Tx
data TransactionSubmitted
TransactionSubmitted :: TransactionSubmitted

-- | Hydra HTTP server
httpApp :: Tracer IO APIServerLog -> Chain tx IO -> PParams LedgerEra -> Application

-- | Handle request to obtain a draft commit tx.
--   
--   Users can decide to commit a public key as well as script outputs.
--   
--   <h4><b>Request body examples:</b></h4>
--   
--   <pre>
--   // Committing public key output
--   
--   {
--    "0406060506030602040508060506060306050406020207000508040704040203#89": {
--       "address": "addr_test1vz66ue36465w2qq40005h2hadad6pnjht8mu6sgplsfj74q9pm4f4",
--       "value": {
--         "lovelace": 7620669
--       }
--   }
--   </pre>
--   
--   <pre>
--   // Committing a script output
--   
--   {
--    "6f066e0f6ba373c0ea7d8b47aefd7e14d1a781698cd052d0254afe65e039b083#0": {
--     "address": "addr_test1wqv4z4hc0u5e2c3sppfdu8ckn82hfegpkjagsm4t8ttvlycg9mkca",
--     "datum": null,
--     "datumhash": "bb30a42c1e62f0afda5f0a4e8a562f7a13a24cea00ee81917b86b89e801314aa",
--     "inlineDatum": null,
--     "referenceScript": null,
--     "value": {
--       "lovelace": 1034400
--     },
--     "witness": {
--       "datum": "02",
--       "plutusV2Script": {
--         "cborHex": "484701000022200101",
--         "description": "",
--         "type": <a>PlutusScriptV2</a>
--       },
--       "redeemer": "01"
--     }
--   }
--   </pre>
--   
--   <pre>
--   // Committing a script output using inline datum
--   
--   {
--   
--   "87a0c1e14be2cd8c385b6fe5a40b024b7201da9df375542029d91ccaba01ac82#0": {
--       "address": "addr_test1wqv4z4hc0u5e2c3sppfdu8ckn82hfegpkjagsm4t8ttvlycg9mkca",
--       "datum": null,
--       "inlineDatum": {
--         "int": 2
--       },
--       "inlineDatumhash": "bb30a42c1e62f0afda5f0a4e8a562f7a13a24cea00ee81917b86b89e801314aa",
--       "referenceScript": null,
--       "value": {
--         "lovelace": 905100
--       },
--       "witness": {
--         "datum": null,
--         "plutusV2Script": {
--           "cborHex": "484701000022200101",
--           "description": "",
--           "type": <a>PlutusScriptV2</a>
--         },
--         "redeemer": "01"
--       }
--     }
--     
--   </pre>
handleDraftCommitUtxo :: Chain tx IO -> ByteString -> IO Response

-- | Handle request to submit a cardano transaction.
handleSubmitUserTx :: Chain tx IO -> ByteString -> IO Response
return400 :: IsChainState tx => PostTxError tx -> Response
instance GHC.Generics.Generic Hydra.API.HTTPServer.DraftCommitTxResponse
instance GHC.Show.Show Hydra.API.HTTPServer.DraftCommitTxResponse
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.API.HTTPServer.ScriptInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.API.HTTPServer.ScriptInfo
instance GHC.Generics.Generic Hydra.API.HTTPServer.ScriptInfo
instance GHC.Classes.Eq Hydra.API.HTTPServer.ScriptInfo
instance GHC.Show.Show Hydra.API.HTTPServer.ScriptInfo
instance GHC.Generics.Generic Hydra.API.HTTPServer.TxOutWithWitness
instance GHC.Classes.Eq Hydra.API.HTTPServer.TxOutWithWitness
instance GHC.Show.Show Hydra.API.HTTPServer.TxOutWithWitness
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.API.HTTPServer.DraftCommitTxRequest
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.API.HTTPServer.DraftCommitTxRequest
instance GHC.Generics.Generic Hydra.API.HTTPServer.DraftCommitTxRequest
instance GHC.Show.Show Hydra.API.HTTPServer.DraftCommitTxRequest
instance GHC.Classes.Eq Hydra.API.HTTPServer.DraftCommitTxRequest
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.API.HTTPServer.SubmitTxRequest
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.API.HTTPServer.SubmitTxRequest
instance GHC.Generics.Generic Hydra.API.HTTPServer.SubmitTxRequest
instance GHC.Show.Show Hydra.API.HTTPServer.SubmitTxRequest
instance GHC.Classes.Eq Hydra.API.HTTPServer.SubmitTxRequest
instance GHC.Generics.Generic Hydra.API.HTTPServer.TransactionSubmitted
instance GHC.Show.Show Hydra.API.HTTPServer.TransactionSubmitted
instance GHC.Classes.Eq Hydra.API.HTTPServer.TransactionSubmitted
instance Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Api.UTxO.UTxO' Hydra.API.HTTPServer.TxOutWithWitness)
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.API.HTTPServer.TransactionSubmitted
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.API.HTTPServer.TransactionSubmitted
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.API.HTTPServer.TransactionSubmitted
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.API.HTTPServer.SubmitTxRequest
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.API.HTTPServer.DraftCommitTxRequest
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.API.HTTPServer.TxOutWithWitness
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.API.HTTPServer.TxOutWithWitness
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.API.HTTPServer.TxOutWithWitness
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.API.HTTPServer.ScriptInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.API.HTTPServer.DraftCommitTxResponse
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.API.HTTPServer.DraftCommitTxResponse
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.API.HTTPServer.DraftCommitTxResponse

module Hydra.API.ServerOutput

-- | The type of messages sent to clients by the <a>Server</a>.
data TimedServerOutput tx
TimedServerOutput :: ServerOutput tx -> Natural -> UTCTime -> TimedServerOutput tx
[output] :: TimedServerOutput tx -> ServerOutput tx
[seq] :: TimedServerOutput tx -> Natural
[time] :: TimedServerOutput tx -> UTCTime

-- | Generate a random timed server output given a normal server output.
genTimedServerOutput :: ServerOutput tx -> Gen (TimedServerOutput tx)

-- | Individual server output messages as produced by the <a>HeadLogic</a>
--   in the <tt>ClientEffect</tt>.
data ServerOutput tx
PeerConnected :: NodeId -> ServerOutput tx
[peer] :: ServerOutput tx -> NodeId
PeerDisconnected :: NodeId -> ServerOutput tx
[peer] :: ServerOutput tx -> NodeId
HeadIsInitializing :: HeadId -> Set Party -> ServerOutput tx
[headId] :: ServerOutput tx -> HeadId
[parties] :: ServerOutput tx -> Set Party
Committed :: HeadId -> Party -> UTxOType tx -> ServerOutput tx
[headId] :: ServerOutput tx -> HeadId
[party] :: ServerOutput tx -> Party
[utxo] :: ServerOutput tx -> UTxOType tx
HeadIsOpen :: HeadId -> UTxOType tx -> ServerOutput tx
[headId] :: ServerOutput tx -> HeadId
[utxo] :: ServerOutput tx -> UTxOType tx
HeadIsClosed :: HeadId -> SnapshotNumber -> UTCTime -> ServerOutput tx
[headId] :: ServerOutput tx -> HeadId
[snapshotNumber] :: ServerOutput tx -> SnapshotNumber

-- | Nominal deadline until which contest can be submitted and after which
--   fanout is possible. NOTE: Use this only for informational purpose and
--   wait for <a>ReadyToFanout</a> instead before sending <a>Fanout</a> as
--   the ledger of our cardano-node might not have progressed sufficiently
--   in time yet and we do not re-submit transactions (yet).
[contestationDeadline] :: ServerOutput tx -> UTCTime
HeadIsContested :: HeadId -> SnapshotNumber -> ServerOutput tx
[headId] :: ServerOutput tx -> HeadId
[snapshotNumber] :: ServerOutput tx -> SnapshotNumber
ReadyToFanout :: HeadId -> ServerOutput tx
[headId] :: ServerOutput tx -> HeadId
HeadIsAborted :: HeadId -> UTxOType tx -> ServerOutput tx
[headId] :: ServerOutput tx -> HeadId
[utxo] :: ServerOutput tx -> UTxOType tx
HeadIsFinalized :: HeadId -> UTxOType tx -> ServerOutput tx
[headId] :: ServerOutput tx -> HeadId
[utxo] :: ServerOutput tx -> UTxOType tx
CommandFailed :: ClientInput tx -> ServerOutput tx
[clientInput] :: ServerOutput tx -> ClientInput tx

-- | Given transaction has been seen as valid in the Head. It is expected
--   to eventually be part of a <a>SnapshotConfirmed</a>.
TxValid :: HeadId -> tx -> ServerOutput tx
[headId] :: ServerOutput tx -> HeadId
[transaction] :: ServerOutput tx -> tx

-- | Given transaction was not not applicable to the given UTxO in time and
--   has been dropped.
TxInvalid :: HeadId -> UTxOType tx -> tx -> ValidationError -> ServerOutput tx
[headId] :: ServerOutput tx -> HeadId
[utxo] :: ServerOutput tx -> UTxOType tx
[transaction] :: ServerOutput tx -> tx
[validationError] :: ServerOutput tx -> ValidationError

-- | Given snapshot was confirmed and included transactions can be
--   considered final.
SnapshotConfirmed :: HeadId -> Snapshot tx -> MultiSignature (Snapshot tx) -> ServerOutput tx
[headId] :: ServerOutput tx -> HeadId
[snapshot] :: ServerOutput tx -> Snapshot tx
[signatures] :: ServerOutput tx -> MultiSignature (Snapshot tx)
GetUTxOResponse :: HeadId -> UTxOType tx -> ServerOutput tx
[headId] :: ServerOutput tx -> HeadId
[utxo] :: ServerOutput tx -> UTxOType tx
InvalidInput :: String -> Text -> ServerOutput tx
[reason] :: ServerOutput tx -> String
[input] :: ServerOutput tx -> Text

-- | A friendly welcome message which tells a client something about the
--   node. Currently used for knowing what signing key the server uses (it
--   only knows one), <a>HeadStatus</a> and optionally (if
--   <a>HeadIsOpen</a> or <a>SnapshotConfirmed</a> message is emitted)
--   UTxO's present in the Hydra Head.
Greetings :: Party -> HeadStatus -> Maybe (UTxOType tx) -> String -> ServerOutput tx
[me] :: ServerOutput tx -> Party
[headStatus] :: ServerOutput tx -> HeadStatus
[snapshotUtxo] :: ServerOutput tx -> Maybe (UTxOType tx)
[hydraNodeVersion] :: ServerOutput tx -> String
PostTxOnChainFailed :: PostChainTx tx -> PostTxError tx -> ServerOutput tx
[postChainTx] :: ServerOutput tx -> PostChainTx tx
[postTxError] :: ServerOutput tx -> PostTxError tx

-- | Possible transaction formats in the api server output
data OutputFormat
OutputCBOR :: OutputFormat
OutputJSON :: OutputFormat

-- | Whether or not to include full UTxO in server outputs.
data WithUTxO
WithUTxO :: WithUTxO
WithoutUTxO :: WithUTxO
data ServerOutputConfig
ServerOutputConfig :: OutputFormat -> WithUTxO -> ServerOutputConfig
[txOutputFormat] :: ServerOutputConfig -> OutputFormat
[utxoInSnapshot] :: ServerOutputConfig -> WithUTxO

-- | Replaces the json encoded tx field with it's cbor representation.
--   
--   NOTE: we deliberately pattern match on all <a>ServerOutput</a>
--   constructors in <tt>handleTxOutput</tt> so that we don't forget to
--   update this function if they change.
prepareServerOutput :: IsChainState tx => ServerOutputConfig -> TimedServerOutput tx -> ByteString

-- | All possible Hydra states displayed in the API server outputs.
data HeadStatus
Idle :: HeadStatus
Initializing :: HeadStatus
Open :: HeadStatus
Closed :: HeadStatus
FanoutPossible :: HeadStatus
Final :: HeadStatus

-- | Projection function related to <a>headStatus</a> field in
--   <a>Greetings</a> message.
projectHeadStatus :: HeadStatus -> ServerOutput tx -> HeadStatus

-- | Projection function related to <a>snapshotUtxo</a> field in
--   <a>Greetings</a> message.
projectSnapshotUtxo :: Maybe (UTxOType tx) -> ServerOutput tx -> Maybe (UTxOType tx)
instance GHC.Show.Show Hydra.API.ServerOutput.OutputFormat
instance GHC.Classes.Eq Hydra.API.ServerOutput.OutputFormat
instance GHC.Show.Show Hydra.API.ServerOutput.WithUTxO
instance GHC.Classes.Eq Hydra.API.ServerOutput.WithUTxO
instance GHC.Show.Show Hydra.API.ServerOutput.ServerOutputConfig
instance GHC.Classes.Eq Hydra.API.ServerOutput.ServerOutputConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.API.ServerOutput.HeadStatus
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.API.ServerOutput.HeadStatus
instance GHC.Generics.Generic Hydra.API.ServerOutput.HeadStatus
instance GHC.Show.Show Hydra.API.ServerOutput.HeadStatus
instance GHC.Classes.Eq Hydra.API.ServerOutput.HeadStatus
instance GHC.Generics.Generic (Hydra.API.ServerOutput.ServerOutput tx)
instance GHC.Generics.Generic (Hydra.API.ServerOutput.TimedServerOutput tx)
instance Hydra.Chain.IsChainState tx => GHC.Show.Show (Hydra.API.ServerOutput.TimedServerOutput tx)
instance Hydra.Chain.IsChainState tx => GHC.Classes.Eq (Hydra.API.ServerOutput.TimedServerOutput tx)
instance Hydra.Chain.IsChainState tx => GHC.Classes.Eq (Hydra.API.ServerOutput.ServerOutput tx)
instance Hydra.Chain.IsChainState tx => GHC.Show.Show (Hydra.API.ServerOutput.ServerOutput tx)
instance Test.QuickCheck.Arbitrary.Arbitrary (Hydra.API.ServerOutput.ServerOutput tx) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.API.ServerOutput.TimedServerOutput tx)
instance Hydra.Chain.IsChainState tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.API.ServerOutput.TimedServerOutput tx)
instance Hydra.Chain.IsChainState tx => Data.Aeson.Types.FromJSON.FromJSON (Hydra.API.ServerOutput.TimedServerOutput tx)
instance Hydra.Chain.IsChainState tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.API.ServerOutput.ServerOutput tx)
instance Hydra.Chain.IsChainState tx => Data.Aeson.Types.FromJSON.FromJSON (Hydra.API.ServerOutput.ServerOutput tx)
instance (Hydra.Ledger.IsTx tx, Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Chain.ChainStateType tx)) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.API.ServerOutput.ServerOutput tx)
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.API.ServerOutput.HeadStatus

module Hydra.HeadLogic.Outcome

-- | Analogous to events, the pure head logic "core" can have effects
--   emited to the "shell" layers and we distinguish the same: effects onto
--   the client, the network and the chain.
data Effect tx

-- | Effect to be handled by the <a>Hydra.API</a>, results in sending this
--   <a>ServerOutput</a>.
ClientEffect :: ServerOutput tx -> Effect tx
[$sel:serverOutput:ClientEffect] :: Effect tx -> ServerOutput tx

-- | Effect to be handled by a <a>Hydra.Network</a>, results in a
--   <a>broadcast</a>.
NetworkEffect :: Message tx -> Effect tx
[$sel:message:ClientEffect] :: Effect tx -> Message tx

-- | Effect to be handled by a <a>Hydra.Chain</a>, results in a
--   <a>postTx</a>.
OnChainEffect :: PostChainTx tx -> Effect tx
[$sel:postChainTx:ClientEffect] :: Effect tx -> PostChainTx tx

-- | Head state changed event. These events represent all the internal
--   state changes, get persisted and processed in an event sourcing
--   manner.
data StateChanged tx
HeadInitialized :: HeadParameters -> ChainStateType tx -> HeadId -> StateChanged tx
[$sel:parameters:HeadInitialized] :: StateChanged tx -> HeadParameters
[$sel:chainState:HeadInitialized] :: StateChanged tx -> ChainStateType tx
[$sel:headId:HeadInitialized] :: StateChanged tx -> HeadId
CommittedUTxO :: Party -> UTxOType tx -> ChainStateType tx -> StateChanged tx
[$sel:party:HeadInitialized] :: StateChanged tx -> Party
[$sel:committedUTxO:HeadInitialized] :: StateChanged tx -> UTxOType tx
[$sel:chainState:HeadInitialized] :: StateChanged tx -> ChainStateType tx
HeadAborted :: ChainStateType tx -> StateChanged tx
[$sel:chainState:HeadInitialized] :: StateChanged tx -> ChainStateType tx
HeadOpened :: ChainStateType tx -> UTxOType tx -> StateChanged tx
[$sel:chainState:HeadInitialized] :: StateChanged tx -> ChainStateType tx
[$sel:initialUTxO:HeadInitialized] :: StateChanged tx -> UTxOType tx
TransactionAppliedToLocalUTxO :: tx -> UTxOType tx -> StateChanged tx
[$sel:tx:HeadInitialized] :: StateChanged tx -> tx
[$sel:newLocalUTxO:HeadInitialized] :: StateChanged tx -> UTxOType tx
SnapshotRequestDecided :: SnapshotNumber -> StateChanged tx
[$sel:snapshotNumber:HeadInitialized] :: StateChanged tx -> SnapshotNumber

-- | A snapshot was requested by some party. NOTE: We deliberately already
--   include an updated local ledger state to not need a ledger to
--   interpret this event.
SnapshotRequested :: Snapshot tx -> [TxIdType tx] -> UTxOType tx -> [tx] -> StateChanged tx
[$sel:snapshot:HeadInitialized] :: StateChanged tx -> Snapshot tx
[$sel:requestedTxIds:HeadInitialized] :: StateChanged tx -> [TxIdType tx]
[$sel:newLocalUTxO:HeadInitialized] :: StateChanged tx -> UTxOType tx
[$sel:newLocalTxs:HeadInitialized] :: StateChanged tx -> [tx]
TransactionReceived :: tx -> StateChanged tx
[$sel:tx:HeadInitialized] :: StateChanged tx -> tx
PartySignedSnapshot :: Snapshot tx -> Party -> Signature (Snapshot tx) -> StateChanged tx
[$sel:snapshot:HeadInitialized] :: StateChanged tx -> Snapshot tx
[$sel:party:HeadInitialized] :: StateChanged tx -> Party
[$sel:signature:HeadInitialized] :: StateChanged tx -> Signature (Snapshot tx)
SnapshotConfirmed :: Snapshot tx -> MultiSignature (Snapshot tx) -> StateChanged tx
[$sel:snapshot:HeadInitialized] :: StateChanged tx -> Snapshot tx
[$sel:signatures:HeadInitialized] :: StateChanged tx -> MultiSignature (Snapshot tx)
HeadClosed :: ChainStateType tx -> UTCTime -> StateChanged tx
[$sel:chainState:HeadInitialized] :: StateChanged tx -> ChainStateType tx
[$sel:contestationDeadline:HeadInitialized] :: StateChanged tx -> UTCTime
HeadIsReadyToFanout :: StateChanged tx
HeadFannedOut :: ChainStateType tx -> StateChanged tx
[$sel:chainState:HeadInitialized] :: StateChanged tx -> ChainStateType tx
ChainRolledBack :: ChainStateType tx -> StateChanged tx
[$sel:chainState:HeadInitialized] :: StateChanged tx -> ChainStateType tx
TickObserved :: ChainSlot -> StateChanged tx
[$sel:chainSlot:HeadInitialized] :: StateChanged tx -> ChainSlot
data Outcome tx
Effects :: [Effect tx] -> Outcome tx
[$sel:effects:Effects] :: Outcome tx -> [Effect tx]
StateChanged :: StateChanged tx -> Outcome tx
[$sel:event:Effects] :: Outcome tx -> StateChanged tx
Wait :: WaitReason tx -> Outcome tx
[$sel:reason:Effects] :: Outcome tx -> WaitReason tx
Error :: LogicError tx -> Outcome tx
[$sel:error:Effects] :: Outcome tx -> LogicError tx
Combined :: Outcome tx -> Outcome tx -> Outcome tx
[$sel:left:Effects] :: Outcome tx -> Outcome tx
[$sel:right:Effects] :: Outcome tx -> Outcome tx
collectEffects :: Outcome tx -> [Effect tx]
collectWaits :: Outcome tx -> [WaitReason tx]
data WaitReason tx
WaitOnNotApplicableTx :: ValidationError -> WaitReason tx
[$sel:validationError:WaitOnNotApplicableTx] :: WaitReason tx -> ValidationError
WaitOnSnapshotNumber :: SnapshotNumber -> WaitReason tx
[$sel:waitingFor:WaitOnNotApplicableTx] :: WaitReason tx -> SnapshotNumber
WaitOnSeenSnapshot :: WaitReason tx
WaitOnTxs :: [TxIdType tx] -> WaitReason tx
[$sel:waitingForTxIds:WaitOnNotApplicableTx] :: WaitReason tx -> [TxIdType tx]
WaitOnContestationDeadline :: WaitReason tx
instance GHC.Generics.Generic (Hydra.HeadLogic.Outcome.Effect tx)
instance GHC.Generics.Generic (Hydra.HeadLogic.Outcome.StateChanged tx)
instance GHC.Generics.Generic (Hydra.HeadLogic.Outcome.WaitReason tx)
instance GHC.Generics.Generic (Hydra.HeadLogic.Outcome.Outcome tx)
instance Hydra.Chain.IsChainState tx => GHC.Classes.Eq (Hydra.HeadLogic.Outcome.Effect tx)
instance Hydra.Chain.IsChainState tx => GHC.Show.Show (Hydra.HeadLogic.Outcome.Effect tx)
instance Hydra.Chain.IsChainState tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.Outcome.Effect tx)
instance Hydra.Chain.IsChainState tx => Data.Aeson.Types.FromJSON.FromJSON (Hydra.HeadLogic.Outcome.Effect tx)
instance (Hydra.Ledger.IsTx tx, GHC.Classes.Eq (Hydra.HeadLogic.State.HeadState tx), GHC.Classes.Eq (Hydra.Chain.ChainStateType tx)) => GHC.Classes.Eq (Hydra.HeadLogic.Outcome.StateChanged tx)
instance (Hydra.Ledger.IsTx tx, GHC.Show.Show (Hydra.HeadLogic.State.HeadState tx), GHC.Show.Show (Hydra.Chain.ChainStateType tx)) => GHC.Show.Show (Hydra.HeadLogic.Outcome.StateChanged tx)
instance (Hydra.Ledger.IsTx tx, Data.Aeson.Types.ToJSON.ToJSON (Hydra.Chain.ChainStateType tx)) => Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.Outcome.StateChanged tx)
instance (Hydra.Ledger.IsTx tx, Data.Aeson.Types.FromJSON.FromJSON (Hydra.HeadLogic.State.HeadState tx), Data.Aeson.Types.FromJSON.FromJSON (Hydra.Chain.ChainStateType tx)) => Data.Aeson.Types.FromJSON.FromJSON (Hydra.HeadLogic.Outcome.StateChanged tx)
instance Hydra.Chain.IsChainState tx => GHC.Classes.Eq (Hydra.HeadLogic.Outcome.Outcome tx)
instance Hydra.Chain.IsChainState tx => GHC.Show.Show (Hydra.HeadLogic.Outcome.Outcome tx)
instance Hydra.Chain.IsChainState tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.Outcome.Outcome tx)
instance Hydra.Chain.IsChainState tx => Data.Aeson.Types.FromJSON.FromJSON (Hydra.HeadLogic.Outcome.Outcome tx)
instance Hydra.Ledger.IsTx tx => GHC.Classes.Eq (Hydra.HeadLogic.Outcome.WaitReason tx)
instance Hydra.Ledger.IsTx tx => GHC.Show.Show (Hydra.HeadLogic.Outcome.WaitReason tx)
instance Hydra.Ledger.IsTx tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.Outcome.WaitReason tx)
instance Hydra.Ledger.IsTx tx => Data.Aeson.Types.FromJSON.FromJSON (Hydra.HeadLogic.Outcome.WaitReason tx)
instance GHC.Base.Semigroup (Hydra.HeadLogic.Outcome.Outcome tx)
instance (Hydra.Ledger.IsTx tx, Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Chain.ChainStateType tx)) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.HeadLogic.Outcome.Outcome tx)
instance Hydra.Ledger.IsTx tx => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.HeadLogic.Outcome.WaitReason tx)
instance (Hydra.Ledger.IsTx tx, Test.QuickCheck.Arbitrary.Arbitrary (Hydra.HeadLogic.State.HeadState tx), Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Chain.ChainStateType tx)) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.HeadLogic.Outcome.StateChanged tx)
instance (Hydra.Ledger.IsTx tx, Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Chain.ChainStateType tx)) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.HeadLogic.Outcome.Effect tx)


-- | Implements the Head Protocol's <i>state machine</i> as <i>pure
--   functions</i> in an event sourced manner.
--   
--   More specifically, the <a>update</a> will handle incoming <a>Event</a>
--   (or rather "commands" in event sourcing speak) and convert that into a
--   set of side-<a>Effect</a>s and internal <a>StateChanged</a> events,
--   which in turn are <a>aggregate</a>d into a single <a>HeadState</a>.
--   
--   As the specification is using a more imperative way of specifying the
--   protocl behavior, one would find the decision logic in <a>update</a>
--   while state updates can be found in the corresponding <a>aggregate</a>
--   branch.
module Hydra.HeadLogic
defaultTTL :: TTL

-- | Client request to init the head. This leads to an init transaction on
--   chain, containing the head parameters.
--   
--   <b>Transition</b>: <a>IdleState</a> → <a>IdleState</a>
onIdleClientInit :: Environment -> Outcome tx

-- | Observe an init transaction, initialize parameters in an
--   <a>InitialState</a> and notify clients that they can now commit.
--   
--   <b>Transition</b>: <a>IdleState</a> → <a>InitialState</a>
onIdleChainInitTx :: ChainStateType tx -> [Party] -> ContestationPeriod -> HeadId -> Outcome tx

-- | Observe a commit transaction and record the committed UTxO in the
--   state. Also, if this is the last commit to be observed, post a
--   collect-com transaction on-chain.
--   
--   <b>Transition</b>: <a>InitialState</a> → <a>InitialState</a>
onInitialChainCommitTx :: Monoid (UTxOType tx) => InitialState tx -> ChainStateType tx -> Party -> UTxOType tx -> Outcome tx

-- | Client request to abort the head. This leads to an abort transaction
--   on chain, reimbursing already committed UTxOs.
--   
--   <b>Transition</b>: <a>InitialState</a> → <a>InitialState</a>
onInitialClientAbort :: Monoid (UTxOType tx) => InitialState tx -> Outcome tx

-- | Observe an abort transaction by switching the state and notifying
--   clients about it.
--   
--   <b>Transition</b>: <a>InitialState</a> → <a>IdleState</a>
onInitialChainAbortTx :: Monoid (UTxOType tx) => ChainStateType tx -> Committed tx -> HeadId -> Outcome tx

-- | Observe a collectCom transaction. We initialize the <a>OpenState</a>
--   using the head parameters from <a>IdleState</a> and construct an
--   <a>InitialSnapshot</a> holding <tt>u0</tt> from the committed UTxOs.
--   
--   <b>Transition</b>: <a>InitialState</a> → <a>OpenState</a>
onInitialChainCollectTx :: IsChainState tx => InitialState tx -> ChainStateType tx -> Outcome tx

-- | Client request to ingest a new transaction into the head.
--   
--   <b>Transition</b>: <a>OpenState</a> → <a>OpenState</a>
onOpenClientNewTx :: tx -> Outcome tx

-- | Process a transaction request (<a>ReqTx</a>) from a party.
--   
--   We apply this transaction to the seen utxo (ledger state). If not
--   applicable, we wait and retry later. If it applies, this yields an
--   updated seen ledger state. Then, we check whether we are the leader
--   for the next snapshot and emit a snapshot request <a>ReqSn</a>
--   including this transaction if needed.
--   
--   <b>Transition</b>: <a>OpenState</a> → <a>OpenState</a>
onOpenNetworkReqTx :: IsTx tx => Environment -> Ledger tx -> OpenState tx -> TTL -> tx -> Outcome tx

-- | Process a snapshot request (<a>ReqSn</a>) from party.
--   
--   This checks that s is the next snapshot number and that the party is
--   responsible for leading that snapshot. Then, we potentially wait until
--   the previous snapshot is confirmed (no snapshot is in flight), before
--   we apply (or wait until applicable) the requested transactions to the
--   last confirmed snapshot. Only then, we start tracking this new "seen"
--   snapshot, compute a signature of it and send the corresponding
--   <a>AckSn</a> to all parties. Finally, the pending transaction set gets
--   pruned to only contain still applicable transactions.
--   
--   <b>Transition</b>: <a>OpenState</a> → <a>OpenState</a>
onOpenNetworkReqSn :: IsTx tx => Environment -> Ledger tx -> OpenState tx -> Party -> SnapshotNumber -> [TxIdType tx] -> Outcome tx

-- | Process a snapshot acknowledgement (<a>AckSn</a>) from a party.
--   
--   We do require that the is from the last seen or next expected
--   snapshot, and potentially wait wait for the corresponding <a>ReqSn</a>
--   before proceeding. If the party hasn't sent us a signature yet, we
--   store it. Once a signature from each party has been collected, we
--   aggregate a multi-signature and verify it is correct. If everything is
--   fine, the snapshot can be considered as the latest confirmed one.
--   Similar to processing a <a>ReqTx</a>, we check whether we are leading
--   the next snapshot and craft a corresponding <a>ReqSn</a> if needed.
--   
--   <b>Transition</b>: <a>OpenState</a> → <a>OpenState</a>
onOpenNetworkAckSn :: IsTx tx => Environment -> OpenState tx -> Party -> Signature (Snapshot tx) -> SnapshotNumber -> Outcome tx

-- | Client request to close the head. This leads to a close transaction on
--   chain using the latest confirmed snaphshot of the <a>OpenState</a>.
--   
--   <b>Transition</b>: <a>OpenState</a> → <a>OpenState</a>
onOpenClientClose :: OpenState tx -> Outcome tx

-- | Observe a close transaction. If the closed snapshot number is smaller
--   than our last confirmed, we post a contest transaction. Also, we do
--   schedule a notification for clients to fanout at the deadline.
--   
--   <b>Transition</b>: <a>OpenState</a> → <a>ClosedState</a>
onOpenChainCloseTx :: OpenState tx -> ChainStateType tx -> SnapshotNumber -> UTCTime -> Outcome tx

-- | Observe a contest transaction. If the contested snapshot number is
--   smaller than our last confirmed snapshot, we post a contest
--   transaction.
--   
--   <b>Transition</b>: <a>ClosedState</a> → <a>ClosedState</a>
onClosedChainContestTx :: ClosedState tx -> SnapshotNumber -> Outcome tx

-- | Client request to fanout leads to a fanout transaction on chain using
--   the latest confirmed snapshot from <a>ClosedState</a>.
--   
--   <b>Transition</b>: <a>ClosedState</a> → <a>ClosedState</a>
onClosedClientFanout :: ClosedState tx -> Outcome tx

-- | Observe a fanout transaction by finalize the head state and notifying
--   clients about it.
--   
--   <b>Transition</b>: <a>ClosedState</a> → <a>IdleState</a>
onClosedChainFanoutTx :: ClosedState tx -> ChainStateType tx -> Outcome tx

-- | Handles commands and converts them into internal <a>StateChanged</a>
--   events along with <a>Effect</a>s, in case it is processed succesfully.
--   Later, the Node will <a>aggregate</a> the events, resulting in a new
--   <a>HeadState</a>.
update :: IsChainState tx => Environment -> Ledger tx -> HeadState tx -> Event tx -> Outcome tx

-- | Reflect <a>StateChanged</a> events onto the <a>HeadState</a>
--   aggregate.
aggregate :: IsChainState tx => HeadState tx -> StateChanged tx -> HeadState tx
aggregateState :: IsChainState tx => HeadState tx -> Outcome tx -> HeadState tx
recoverChainStateHistory :: (Foldable t, IsChainState tx) => ChainStateType tx -> t (StateChanged tx) -> ChainStateHistory tx
recoverState :: (Foldable t, IsChainState tx) => HeadState tx -> t (StateChanged tx) -> HeadState tx

-- | The different events which are processed by the head logic (the
--   "core"). Corresponding to each of the "shell" layers, we distinguish
--   between events from the client, the network and the chain.
data Event tx

-- | Event received from clients via the <a>Hydra.API</a>.
ClientEvent :: ClientInput tx -> Event tx
[clientInput] :: Event tx -> ClientInput tx

-- | Event received from peers via a <a>Hydra.Network</a>.
--   
--   <ul>
--   <li><a>ttl</a> is a simple counter that's decreased every time the
--   event is reenqueued due to a wait. It's default value is
--   <tt>defaultTTL</tt></li>
--   </ul>
NetworkEvent :: TTL -> Party -> Message tx -> Event tx
[ttl] :: Event tx -> TTL
[party] :: Event tx -> Party
[message] :: Event tx -> Message tx

-- | Event received from the chain via a <a>Hydra.Chain</a>.
OnChainEvent :: ChainEvent tx -> Event tx
[chainEvent] :: Event tx -> ChainEvent tx

-- | Event to re-ingest errors from <tt>postTx</tt> for further processing.
PostTxError :: PostChainTx tx -> PostTxError tx -> Event tx
[postChainTx] :: Event tx -> PostChainTx tx
[postTxError] :: Event tx -> PostTxError tx
type TTL = Natural
data RequirementFailure tx
ReqSnNumberInvalid :: SnapshotNumber -> SnapshotNumber -> RequirementFailure tx
[requestedSn] :: RequirementFailure tx -> SnapshotNumber
[lastSeenSn] :: RequirementFailure tx -> SnapshotNumber
ReqSnNotLeader :: SnapshotNumber -> Party -> RequirementFailure tx
[requestedSn] :: RequirementFailure tx -> SnapshotNumber
[leader] :: RequirementFailure tx -> Party
InvalidMultisignature :: Text -> [VerificationKey HydraKey] -> RequirementFailure tx
[multisig] :: RequirementFailure tx -> Text
[vkeys] :: RequirementFailure tx -> [VerificationKey HydraKey]
SnapshotAlreadySigned :: [Party] -> Party -> RequirementFailure tx
[knownSignatures] :: RequirementFailure tx -> [Party]
[receivedSignature] :: RequirementFailure tx -> Party
AckSnNumberInvalid :: SnapshotNumber -> SnapshotNumber -> RequirementFailure tx
[requestedSn] :: RequirementFailure tx -> SnapshotNumber
[lastSeenSn] :: RequirementFailure tx -> SnapshotNumber
SnapshotDoesNotApply :: SnapshotNumber -> TxIdType tx -> ValidationError -> RequirementFailure tx
[requestedSn] :: RequirementFailure tx -> SnapshotNumber
[txid] :: RequirementFailure tx -> TxIdType tx
[error] :: RequirementFailure tx -> ValidationError

-- | Preliminary type for collecting errors occurring during
--   <tt>update</tt>. TODO: Try to merge this (back) into <tt>Outcome</tt>.
data LogicError tx
InvalidEvent :: Event tx -> HeadState tx -> LogicError tx
RequireFailed :: RequirementFailure tx -> LogicError tx
NotOurHead :: HeadId -> HeadId -> LogicError tx
[ourHeadId] :: LogicError tx -> HeadId
[otherHeadId] :: LogicError tx -> HeadId

-- | An <a>Closed</a> head with an current candidate
--   <a>ConfirmedSnapshot</a>, which may be contested before the
--   <a>$sel:contestationDeadline:ClosedState</a>.
data ClosedState tx
ClosedState :: HeadParameters -> ConfirmedSnapshot tx -> UTCTime -> Bool -> ChainStateType tx -> HeadId -> ClosedState tx
[$sel:parameters:ClosedState] :: ClosedState tx -> HeadParameters
[$sel:confirmedSnapshot:ClosedState] :: ClosedState tx -> ConfirmedSnapshot tx
[$sel:contestationDeadline:ClosedState] :: ClosedState tx -> UTCTime

-- | Tracks whether we have informed clients already about being
--   <tt>ReadyToFanout</tt>.
[$sel:readyToFanoutSent:ClosedState] :: ClosedState tx -> Bool
[$sel:chainState:ClosedState] :: ClosedState tx -> ChainStateType tx
[$sel:headId:ClosedState] :: ClosedState tx -> HeadId

-- | Data structure to help in tracking whether we have seen or requested a
--   ReqSn already and if seen, the signatures we collected already.
data SeenSnapshot tx

-- | Never saw a ReqSn.
NoSeenSnapshot :: SeenSnapshot tx

-- | No snapshot in flight with last seen snapshot number as given.
LastSeenSnapshot :: SnapshotNumber -> SeenSnapshot tx
[$sel:lastSeen:NoSeenSnapshot] :: SeenSnapshot tx -> SnapshotNumber

-- | ReqSn was sent out and it should be considered already in flight.
RequestedSnapshot :: SnapshotNumber -> SnapshotNumber -> SeenSnapshot tx
[$sel:lastSeen:NoSeenSnapshot] :: SeenSnapshot tx -> SnapshotNumber
[$sel:requested:NoSeenSnapshot] :: SeenSnapshot tx -> SnapshotNumber

-- | ReqSn for given snapshot was received.
SeenSnapshot :: Snapshot tx -> Map Party (Signature (Snapshot tx)) -> SeenSnapshot tx
[$sel:snapshot:NoSeenSnapshot] :: SeenSnapshot tx -> Snapshot tx

-- | Collected signatures and so far.
[$sel:signatories:NoSeenSnapshot] :: SeenSnapshot tx -> Map Party (Signature (Snapshot tx))

-- | Off-chain state of the Coordinated Head protocol.
data CoordinatedHeadState tx
CoordinatedHeadState :: UTxOType tx -> [tx] -> Map (TxIdType tx) tx -> ConfirmedSnapshot tx -> SeenSnapshot tx -> CoordinatedHeadState tx

-- | The latest UTxO resulting from applying
--   <a>$sel:localTxs:CoordinatedHeadState</a> to
--   <a>CoordinatedHeadState</a>. Spec: L̂
[$sel:localUTxO:CoordinatedHeadState] :: CoordinatedHeadState tx -> UTxOType tx

-- | List of transactions applied locally and pending inclusion in a
--   snapshot. Spec: T̂
[$sel:localTxs:CoordinatedHeadState] :: CoordinatedHeadState tx -> [tx]

-- | Map containing all the transactions ever seen by this node and not yet
--   included in a snapshot. Spec: Tall
[$sel:allTxs:CoordinatedHeadState] :: CoordinatedHeadState tx -> Map (TxIdType tx) tx

-- | The latest confirmed snapshot. Spec: U̅, s̅ and σ̅
[$sel:confirmedSnapshot:CoordinatedHeadState] :: CoordinatedHeadState tx -> ConfirmedSnapshot tx

-- | Last seen snapshot and signatures accumulator. Spec: Û, ŝ and Σ̂
[$sel:seenSnapshot:CoordinatedHeadState] :: CoordinatedHeadState tx -> SeenSnapshot tx

-- | An <a>Open</a> head with a <a>CoordinatedHeadState</a> tracking
--   off-chain transactions.
data OpenState tx
OpenState :: HeadParameters -> CoordinatedHeadState tx -> ChainStateType tx -> HeadId -> ChainSlot -> OpenState tx
[$sel:parameters:OpenState] :: OpenState tx -> HeadParameters
[$sel:coordinatedHeadState:OpenState] :: OpenState tx -> CoordinatedHeadState tx
[$sel:chainState:OpenState] :: OpenState tx -> ChainStateType tx
[$sel:headId:OpenState] :: OpenState tx -> HeadId
[$sel:currentSlot:OpenState] :: OpenState tx -> ChainSlot
type Committed tx = Map Party (UTxOType tx)
type PendingCommits = Set Party

-- | An <a>Initial</a> head which already has an identity and is collecting
--   commits.
data InitialState tx
InitialState :: HeadParameters -> PendingCommits -> Committed tx -> ChainStateType tx -> HeadId -> InitialState tx
[$sel:parameters:InitialState] :: InitialState tx -> HeadParameters
[$sel:pendingCommits:InitialState] :: InitialState tx -> PendingCommits
[$sel:committed:InitialState] :: InitialState tx -> Committed tx
[$sel:chainState:InitialState] :: InitialState tx -> ChainStateType tx
[$sel:headId:InitialState] :: InitialState tx -> HeadId

-- | An <a>Idle</a> head only having a chain state with things seen on
--   chain so far.
newtype IdleState tx
IdleState :: ChainStateType tx -> IdleState tx
[$sel:chainState:IdleState] :: IdleState tx -> ChainStateType tx

-- | The main state of the Hydra protocol state machine. It holds both, the
--   overall protocol state, but also the off-chain
--   <a>CoordinatedHeadState</a>.
--   
--   Each of the sub-types (InitialState, OpenState, etc.) contain
--   black-box <a>IdleState</a> corresponding to <tt>OnChainEvent</tt> that
--   has been observed leading to the state.
--   
--   Note that rollbacks are currently not fully handled in the head logic
--   and only this internal chain state gets replaced with the "rolled back
--   to" version.
data HeadState tx
Idle :: IdleState tx -> HeadState tx
Initial :: InitialState tx -> HeadState tx
Open :: OpenState tx -> HeadState tx
Closed :: ClosedState tx -> HeadState tx
data Environment
Environment :: Party -> SigningKey HydraKey -> [Party] -> ContestationPeriod -> Environment

-- | This is the p_i from the paper
[$sel:party:Environment] :: Environment -> Party
[$sel:signingKey:Environment] :: Environment -> SigningKey HydraKey
[$sel:otherParties:Environment] :: Environment -> [Party]
[$sel:contestationPeriod:Environment] :: Environment -> ContestationPeriod

-- | Update the chain state in any <a>HeadState</a>.
setChainState :: ChainStateType tx -> HeadState tx -> HeadState tx

-- | Get the last seen snapshot number given a <a>SeenSnapshot</a>.
seenSnapshotNumber :: SeenSnapshot tx -> SnapshotNumber
data WaitReason tx
WaitOnNotApplicableTx :: ValidationError -> WaitReason tx
[$sel:validationError:WaitOnNotApplicableTx] :: WaitReason tx -> ValidationError
WaitOnSnapshotNumber :: SnapshotNumber -> WaitReason tx
[$sel:waitingFor:WaitOnNotApplicableTx] :: WaitReason tx -> SnapshotNumber
WaitOnSeenSnapshot :: WaitReason tx
WaitOnTxs :: [TxIdType tx] -> WaitReason tx
[$sel:waitingForTxIds:WaitOnNotApplicableTx] :: WaitReason tx -> [TxIdType tx]
WaitOnContestationDeadline :: WaitReason tx
data Outcome tx
Effects :: [Effect tx] -> Outcome tx
[$sel:effects:Effects] :: Outcome tx -> [Effect tx]
StateChanged :: StateChanged tx -> Outcome tx
[$sel:event:Effects] :: Outcome tx -> StateChanged tx
Wait :: WaitReason tx -> Outcome tx
[$sel:reason:Effects] :: Outcome tx -> WaitReason tx
Error :: LogicError tx -> Outcome tx
[$sel:error:Effects] :: Outcome tx -> LogicError tx
Combined :: Outcome tx -> Outcome tx -> Outcome tx
[$sel:left:Effects] :: Outcome tx -> Outcome tx
[$sel:right:Effects] :: Outcome tx -> Outcome tx

-- | Head state changed event. These events represent all the internal
--   state changes, get persisted and processed in an event sourcing
--   manner.
data StateChanged tx
HeadInitialized :: HeadParameters -> ChainStateType tx -> HeadId -> StateChanged tx
[$sel:parameters:HeadInitialized] :: StateChanged tx -> HeadParameters
[$sel:chainState:HeadInitialized] :: StateChanged tx -> ChainStateType tx
[$sel:headId:HeadInitialized] :: StateChanged tx -> HeadId
CommittedUTxO :: Party -> UTxOType tx -> ChainStateType tx -> StateChanged tx
[$sel:party:HeadInitialized] :: StateChanged tx -> Party
[$sel:committedUTxO:HeadInitialized] :: StateChanged tx -> UTxOType tx
[$sel:chainState:HeadInitialized] :: StateChanged tx -> ChainStateType tx
HeadAborted :: ChainStateType tx -> StateChanged tx
[$sel:chainState:HeadInitialized] :: StateChanged tx -> ChainStateType tx
HeadOpened :: ChainStateType tx -> UTxOType tx -> StateChanged tx
[$sel:chainState:HeadInitialized] :: StateChanged tx -> ChainStateType tx
[$sel:initialUTxO:HeadInitialized] :: StateChanged tx -> UTxOType tx
TransactionAppliedToLocalUTxO :: tx -> UTxOType tx -> StateChanged tx
[$sel:tx:HeadInitialized] :: StateChanged tx -> tx
[$sel:newLocalUTxO:HeadInitialized] :: StateChanged tx -> UTxOType tx
SnapshotRequestDecided :: SnapshotNumber -> StateChanged tx
[$sel:snapshotNumber:HeadInitialized] :: StateChanged tx -> SnapshotNumber

-- | A snapshot was requested by some party. NOTE: We deliberately already
--   include an updated local ledger state to not need a ledger to
--   interpret this event.
SnapshotRequested :: Snapshot tx -> [TxIdType tx] -> UTxOType tx -> [tx] -> StateChanged tx
[$sel:snapshot:HeadInitialized] :: StateChanged tx -> Snapshot tx
[$sel:requestedTxIds:HeadInitialized] :: StateChanged tx -> [TxIdType tx]
[$sel:newLocalUTxO:HeadInitialized] :: StateChanged tx -> UTxOType tx
[$sel:newLocalTxs:HeadInitialized] :: StateChanged tx -> [tx]
TransactionReceived :: tx -> StateChanged tx
[$sel:tx:HeadInitialized] :: StateChanged tx -> tx
PartySignedSnapshot :: Snapshot tx -> Party -> Signature (Snapshot tx) -> StateChanged tx
[$sel:snapshot:HeadInitialized] :: StateChanged tx -> Snapshot tx
[$sel:party:HeadInitialized] :: StateChanged tx -> Party
[$sel:signature:HeadInitialized] :: StateChanged tx -> Signature (Snapshot tx)
SnapshotConfirmed :: Snapshot tx -> MultiSignature (Snapshot tx) -> StateChanged tx
[$sel:snapshot:HeadInitialized] :: StateChanged tx -> Snapshot tx
[$sel:signatures:HeadInitialized] :: StateChanged tx -> MultiSignature (Snapshot tx)
HeadClosed :: ChainStateType tx -> UTCTime -> StateChanged tx
[$sel:chainState:HeadInitialized] :: StateChanged tx -> ChainStateType tx
[$sel:contestationDeadline:HeadInitialized] :: StateChanged tx -> UTCTime
HeadIsReadyToFanout :: StateChanged tx
HeadFannedOut :: ChainStateType tx -> StateChanged tx
[$sel:chainState:HeadInitialized] :: StateChanged tx -> ChainStateType tx
ChainRolledBack :: ChainStateType tx -> StateChanged tx
[$sel:chainState:HeadInitialized] :: StateChanged tx -> ChainStateType tx
TickObserved :: ChainSlot -> StateChanged tx
[$sel:chainSlot:HeadInitialized] :: StateChanged tx -> ChainSlot

-- | Analogous to events, the pure head logic "core" can have effects
--   emited to the "shell" layers and we distinguish the same: effects onto
--   the client, the network and the chain.
data Effect tx

-- | Effect to be handled by the <a>Hydra.API</a>, results in sending this
--   <a>ServerOutput</a>.
ClientEffect :: ServerOutput tx -> Effect tx
[$sel:serverOutput:ClientEffect] :: Effect tx -> ServerOutput tx

-- | Effect to be handled by a <a>Hydra.Network</a>, results in a
--   <a>broadcast</a>.
NetworkEffect :: Message tx -> Effect tx
[$sel:message:ClientEffect] :: Effect tx -> Message tx

-- | Effect to be handled by a <a>Hydra.Chain</a>, results in a
--   <a>postTx</a>.
OnChainEffect :: PostChainTx tx -> Effect tx
[$sel:postChainTx:ClientEffect] :: Effect tx -> PostChainTx tx
collectEffects :: Outcome tx -> [Effect tx]
collectWaits :: Outcome tx -> [WaitReason tx]
isLeader :: HeadParameters -> Party -> SnapshotNumber -> Bool

module Hydra.Options
data InvalidOptions
MaximumNumberOfPartiesExceeded :: InvalidOptions
CardanoAndHydraKeysMissmatch :: InvalidOptions
data ChainConfig
DirectChainConfig :: NetworkId -> SocketPath -> FilePath -> [FilePath] -> Maybe ChainPoint -> ContestationPeriod -> ChainConfig

-- | Network identifer to which we expect to connect.
[networkId] :: ChainConfig -> NetworkId

-- | Path to a domain socket used to connect to the server.
[nodeSocket] :: ChainConfig -> SocketPath

-- | Path to the cardano signing key of the internal wallet.
[cardanoSigningKey] :: ChainConfig -> FilePath

-- | Paths to other node's verification keys.
[cardanoVerificationKeys] :: ChainConfig -> [FilePath]

-- | Point at which to start following the chain.
[startChainFrom] :: ChainConfig -> Maybe ChainPoint
[contestationPeriod] :: ChainConfig -> ContestationPeriod
newtype LedgerConfig
CardanoLedgerConfig :: FilePath -> LedgerConfig
[cardanoLedgerProtocolParametersFile] :: LedgerConfig -> FilePath
newtype GenerateKeyPair
GenerateKeyPair :: FilePath -> GenerateKeyPair
[outputFile] :: GenerateKeyPair -> FilePath
data RunOptions
RunOptions :: Verbosity -> NodeId -> IP -> PortNumber -> [Host] -> IP -> PortNumber -> Maybe PortNumber -> FilePath -> [FilePath] -> TxId -> FilePath -> ChainConfig -> LedgerConfig -> RunOptions
[verbosity] :: RunOptions -> Verbosity
[nodeId] :: RunOptions -> NodeId
[host] :: RunOptions -> IP
[port] :: RunOptions -> PortNumber
[peers] :: RunOptions -> [Host]
[apiHost] :: RunOptions -> IP
[apiPort] :: RunOptions -> PortNumber
[monitoringPort] :: RunOptions -> Maybe PortNumber
[hydraSigningKey] :: RunOptions -> FilePath
[hydraVerificationKeys] :: RunOptions -> [FilePath]
[hydraScriptsTxId] :: RunOptions -> TxId
[persistenceDir] :: RunOptions -> FilePath
[chainConfig] :: RunOptions -> ChainConfig
[ledgerConfig] :: RunOptions -> LedgerConfig
data PublishOptions
PublishOptions :: NetworkId -> SocketPath -> FilePath -> PublishOptions
[publishNetworkId] :: PublishOptions -> NetworkId
[publishNodeSocket] :: PublishOptions -> SocketPath
[publishSigningKey] :: PublishOptions -> FilePath
data Command
Run :: RunOptions -> Command
Publish :: PublishOptions -> Command
GenHydraKey :: GenerateKeyPair -> Command
data ParamMismatch
ContestationPeriodMismatch :: ContestationPeriod -> ContestationPeriod -> ParamMismatch
[loadedCp] :: ParamMismatch -> ContestationPeriod
[configuredCp] :: ParamMismatch -> ContestationPeriod
PartiesMismatch :: [Party] -> [Party] -> ParamMismatch
[loadedParties] :: ParamMismatch -> [Party]
[configuredParties] :: ParamMismatch -> [Party]
commandParser :: Parser Command
publishOptionsParser :: Parser PublishOptions
runOptionsParser :: Parser RunOptions
genHydraKeyParser :: Parser GenerateKeyPair
outputFileParser :: Parser FilePath
defaultLedgerConfig :: LedgerConfig
ledgerConfigParser :: Parser LedgerConfig
cardanoLedgerProtocolParametersParser :: Parser FilePath
defaultChainConfig :: ChainConfig
chainConfigParser :: Parser ChainConfig
networkIdParser :: Parser NetworkId
nodeSocketParser :: Parser SocketPath
cardanoSigningKeyFileParser :: Parser FilePath
cardanoVerificationKeyFileParser :: Parser FilePath
hydraSigningKeyFileParser :: Parser FilePath
hydraVerificationKeyFileParser :: Parser FilePath
peerParser :: Parser Host
nodeIdParser :: Parser NodeId
verbosityParser :: Parser Verbosity
hostParser :: Parser IP
portParser :: Parser PortNumber
apiHostParser :: Parser IP
apiPortParser :: Parser PortNumber
monitoringPortParser :: Parser PortNumber
startChainFromParser :: Parser ChainPoint
hydraScriptsTxIdParser :: Parser TxId
persistenceDirParser :: Parser FilePath
hydraNodeCommand :: ParserInfo Command
hydraNodeVersion :: Version
defaultContestationPeriod :: ContestationPeriod
contestationPeriodParser :: Parser ContestationPeriod
explain :: InvalidOptions -> String

-- | Validate cmd line arguments for hydra-node and check if they make
--   sense before actually running the node. Rules we apply: - Check if
--   number of parties is bigger than our hardcoded limit (by looking at
--   loaded hydra or cardano keys and comparing it to the
--   <a>maximumNumberOfParties</a>) - Check that number of loaded hydra
--   keys match with the number of loaded cardano keys (by comparing
--   lengths of the two lists)
validateRunOptions :: RunOptions -> Either InvalidOptions ()

-- | Parse command-line arguments into a <tt>Option</tt> or exit with
--   failure and error message.
parseHydraCommand :: IO Command

-- | Pure parsing of <tt>Option</tt> from a list of arguments.
parseHydraCommandFromArgs :: [String] -> ParserResult Command

-- | Convert an <tt>Options</tt> instance into the corresponding list of
--   command-line arguments.
--   
--   This is useful in situations where one wants to programatically define
--   <tt>Options</tt>, providing some measure of type safety, without
--   having to juggle with strings.
toArgs :: RunOptions -> [String]
defaultRunOptions :: RunOptions
toArgNetworkId :: NetworkId -> [String]
genFilePath :: String -> Gen FilePath
genDirPath :: Gen FilePath
genChainPoint :: Gen ChainPoint
data ParserResult a
Success :: a -> ParserResult a
Failure :: ParserFailure ParserHelp -> ParserResult a
CompletionInvoked :: CompletionResult -> ParserResult a
renderFailure :: ParserFailure ParserHelp -> String -> (String, ExitCode)
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Options.ParamMismatch
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Options.ParamMismatch
instance GHC.Show.Show Hydra.Options.ParamMismatch
instance GHC.Classes.Eq Hydra.Options.ParamMismatch
instance GHC.Generics.Generic Hydra.Options.ParamMismatch
instance GHC.Classes.Eq Hydra.Options.PublishOptions
instance GHC.Show.Show Hydra.Options.PublishOptions
instance GHC.Show.Show Hydra.Options.GenerateKeyPair
instance GHC.Classes.Eq Hydra.Options.GenerateKeyPair
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Options.LedgerConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Options.LedgerConfig
instance GHC.Generics.Generic Hydra.Options.LedgerConfig
instance GHC.Show.Show Hydra.Options.LedgerConfig
instance GHC.Classes.Eq Hydra.Options.LedgerConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Options.ChainConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Options.ChainConfig
instance GHC.Generics.Generic Hydra.Options.ChainConfig
instance GHC.Show.Show Hydra.Options.ChainConfig
instance GHC.Classes.Eq Hydra.Options.ChainConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Options.RunOptions
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Options.RunOptions
instance GHC.Generics.Generic Hydra.Options.RunOptions
instance GHC.Show.Show Hydra.Options.RunOptions
instance GHC.Classes.Eq Hydra.Options.RunOptions
instance GHC.Classes.Eq Hydra.Options.Command
instance GHC.Show.Show Hydra.Options.Command
instance GHC.Show.Show Hydra.Options.InvalidOptions
instance GHC.Classes.Eq Hydra.Options.InvalidOptions
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Options.RunOptions
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Options.ChainConfig
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Options.LedgerConfig
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Options.ParamMismatch

module Hydra.Utils
genHydraKeys :: GenerateKeyPair -> IO (Either (FileError ()) ())


-- | Chain component implementation which uses directly the Node-to-Client
--   protocols to submit "hand-rolled" transactions.
module Hydra.Chain.Direct
newtype NetworkMagic
NetworkMagic :: Word32 -> NetworkMagic

-- | The block type used in the node-to-client protocols.
type BlockType = BlockInMode CardanoMode

-- | Thrown when the user-provided custom point of intersection is unknown
--   to the local node. This may happen if users shut down their node
--   quickly after starting them and hold on a not-so-stable point of the
--   chain. When they turn the node back on, that point may no longer exist
--   on the network if a fork with deeper roots has been adopted in the
--   meantime.
newtype IntersectionNotFoundException
IntersectionNotFound :: ChainPoint -> IntersectionNotFoundException
[$sel:requestedPoint:IntersectionNotFound] :: IntersectionNotFoundException -> ChainPoint
data ConnectException
ConnectException :: IOException -> SocketPath -> NetworkId -> ConnectException
[$sel:ioException:ConnectException] :: ConnectException -> IOException
[$sel:nodeSocket:ConnectException] :: ConnectException -> SocketPath
[$sel:networkId:ConnectException] :: ConnectException -> NetworkId

-- | Build the <a>ChainContext</a> from a <a>ChainConfig</a> and additional
--   information.
loadChainContext :: ChainConfig -> Party -> [Party] -> TxId -> IO ChainContext
mkTinyWallet :: Tracer IO DirectChainLog -> ChainConfig -> IO (TinyWallet IO)
withDirectChain :: Tracer IO DirectChainLog -> ChainConfig -> ChainContext -> TinyWallet IO -> ChainStateHistory Tx -> ChainComponent Tx IO a
chainSyncClient :: forall m. (MonadSTM m, MonadThrow m) => ChainSyncHandler m -> TinyWallet m -> ChainPoint -> ChainSyncClient BlockType ChainPoint ChainTip m ()
txSubmissionClient :: forall m. MonadSTM m => Tracer m DirectChainLog -> TQueue m (Tx, TMVar m (Maybe (PostTxError Tx))) -> LocalTxSubmissionClient (TxInMode CardanoMode) (TxValidationErrorInMode CardanoMode) m ()
instance GHC.Show.Show Hydra.Chain.Direct.ConnectException
instance GHC.Show.Show Hydra.Chain.Direct.IntersectionNotFoundException
instance GHC.Exception.Type.Exception Hydra.Chain.Direct.IntersectionNotFoundException
instance GHC.Exception.Type.Exception Hydra.Chain.Direct.ConnectException

module Hydra.API.WSServer
wsApp :: forall tx. IsChainState tx => Party -> Tracer IO APIServerLog -> TVar [TimedServerOutput tx] -> (ClientInput tx -> IO ()) -> Projection STM (ServerOutput tx) HeadStatus -> Projection STM (ServerOutput tx) (Maybe (UTxOType tx)) -> TChan (TimedServerOutput tx) -> PendingConnection -> IO ()
nextSequenceNumber :: TVar [TimedServerOutput tx] -> STM Natural

module Hydra.API.Server

-- | Handle to provide a means for sending server outputs to clients.
newtype Server tx m
Server :: (ServerOutput tx -> m ()) -> Server tx m

-- | Send some output to all connected clients.
[sendOutput] :: Server tx m -> ServerOutput tx -> m ()

-- | Callback for receiving client inputs.
type ServerCallback tx m = ClientInput tx -> m ()

-- | A type tying both receiving input and sending output into a
--   <i>Component</i>.
type ServerComponent tx m a = ServerCallback tx m -> (Server tx m -> m a) -> m a
withAPIServer :: forall tx. IsChainState tx => IP -> PortNumber -> Party -> PersistenceIncremental (TimedServerOutput tx) IO -> Tracer IO APIServerLog -> Chain tx IO -> PParams LedgerEra -> ServerComponent tx IO ()

-- | An <a>IOException</a> with more <a>IP</a> and <a>PortNumber</a> added
--   as context.
data RunServerException
RunServerException :: IOException -> IP -> PortNumber -> RunServerException
[ioException] :: RunServerException -> IOException
[host] :: RunServerException -> IP
[port] :: RunServerException -> PortNumber
type NotifyServerRunning = IO ()
type WaitForServer = IO ()

-- | Setup notification and waiter to ensure that something only runs after
--   the server is actually listening.
setupServerNotification :: IO (NotifyServerRunning, WaitForServer)
instance GHC.Show.Show Hydra.API.Server.RunServerException
instance GHC.Exception.Type.Exception Hydra.API.Server.RunServerException


-- | Top-level module to run a single Hydra node.
--   
--   Checkout <a>Hydra Documentation</a> for some details about the overall
--   architecture of the <tt>Node</tt>.
module Hydra.Node

-- | Intialize the <a>Environment</a> from command line options.
initEnvironment :: RunOptions -> IO Environment

-- | Exception used to indicate command line options not matching the
--   persisted state.
newtype ParameterMismatch
ParameterMismatch :: [ParamMismatch] -> ParameterMismatch
data ParamMismatch
ContestationPeriodMismatch :: ContestationPeriod -> ContestationPeriod -> ParamMismatch
[$sel:loadedCp:ContestationPeriodMismatch] :: ParamMismatch -> ContestationPeriod
[$sel:configuredCp:ContestationPeriodMismatch] :: ParamMismatch -> ContestationPeriod
PartiesMismatch :: [Party] -> [Party] -> ParamMismatch
[$sel:loadedParties:ContestationPeriodMismatch] :: ParamMismatch -> [Party]
[$sel:configuredParties:ContestationPeriodMismatch] :: ParamMismatch -> [Party]

-- | Checks that command line options match a given <a>HeadState</a>. This
--   funciton takes <a>Environment</a> because it is derived from
--   <a>RunOptions</a> via <a>initEnvironment</a>.
--   
--   Throws: <a>ParameterMismatch</a> when state not matching the
--   environment.
checkHeadState :: MonadThrow m => Tracer m (HydraNodeLog tx) -> Environment -> HeadState tx -> m ()

-- | Main handle of a hydra node where all layers are tied together.
data HydraNode tx m
HydraNode :: EventQueue m (Event tx) -> Network m (Message tx) -> NodeState tx m -> Chain tx m -> Server tx m -> Ledger tx -> Environment -> PersistenceIncremental (StateChanged tx) m -> HydraNode tx m
[$sel:eq:HydraNode] :: HydraNode tx m -> EventQueue m (Event tx)
[$sel:hn:HydraNode] :: HydraNode tx m -> Network m (Message tx)
[$sel:nodeState:HydraNode] :: HydraNode tx m -> NodeState tx m
[$sel:oc:HydraNode] :: HydraNode tx m -> Chain tx m
[$sel:server:HydraNode] :: HydraNode tx m -> Server tx m
[$sel:ledger:HydraNode] :: HydraNode tx m -> Ledger tx
[$sel:env:HydraNode] :: HydraNode tx m -> Environment
[$sel:persistence:HydraNode] :: HydraNode tx m -> PersistenceIncremental (StateChanged tx) m
data HydraNodeLog tx
BeginEvent :: Party -> Word64 -> Event tx -> HydraNodeLog tx
[$sel:by:BeginEvent] :: HydraNodeLog tx -> Party
[$sel:eventId:BeginEvent] :: HydraNodeLog tx -> Word64
[$sel:event:BeginEvent] :: HydraNodeLog tx -> Event tx
EndEvent :: Party -> Word64 -> HydraNodeLog tx
[$sel:by:BeginEvent] :: HydraNodeLog tx -> Party
[$sel:eventId:BeginEvent] :: HydraNodeLog tx -> Word64
BeginEffect :: Party -> Word64 -> Word32 -> Effect tx -> HydraNodeLog tx
[$sel:by:BeginEvent] :: HydraNodeLog tx -> Party
[$sel:eventId:BeginEvent] :: HydraNodeLog tx -> Word64
[$sel:effectId:BeginEvent] :: HydraNodeLog tx -> Word32
[$sel:effect:BeginEvent] :: HydraNodeLog tx -> Effect tx
EndEffect :: Party -> Word64 -> Word32 -> HydraNodeLog tx
[$sel:by:BeginEvent] :: HydraNodeLog tx -> Party
[$sel:eventId:BeginEvent] :: HydraNodeLog tx -> Word64
[$sel:effectId:BeginEvent] :: HydraNodeLog tx -> Word32
LogicOutcome :: Party -> Outcome tx -> HydraNodeLog tx
[$sel:by:BeginEvent] :: HydraNodeLog tx -> Party
[$sel:outcome:BeginEvent] :: HydraNodeLog tx -> Outcome tx
LoadedState :: Word64 -> HydraNodeLog tx
[$sel:numberOfEvents:BeginEvent] :: HydraNodeLog tx -> Word64
Misconfiguration :: [ParamMismatch] -> HydraNodeLog tx
[$sel:misconfigurationErrors:BeginEvent] :: HydraNodeLog tx -> [ParamMismatch]
runHydraNode :: (MonadCatch m, MonadAsync m, IsChainState tx) => Tracer m (HydraNodeLog tx) -> HydraNode tx m -> m ()
stepHydraNode :: (MonadCatch m, MonadAsync m, IsChainState tx) => Tracer m (HydraNodeLog tx) -> HydraNode tx m -> m ()

-- | The time to wait between re-enqueuing a <a>Wait</a> outcome from
--   <tt>HeadLogic</tt>.
waitDelay :: DiffTime

-- | Monadic interface around <a>update</a>.
processNextEvent :: IsChainState tx => HydraNode tx m -> Event tx -> STM m (Outcome tx)
processEffects :: (MonadAsync m, MonadCatch m, IsChainState tx) => HydraNode tx m -> Tracer m (HydraNodeLog tx) -> Word64 -> Outcome tx -> m ()

-- | Handle to access and modify the state in the Hydra Node.
data NodeState tx m
NodeState :: (forall a. (HeadState tx -> (a, HeadState tx)) -> STM m a) -> STM m (HeadState tx) -> NodeState tx m
[$sel:modifyHeadState:NodeState] :: NodeState tx m -> forall a. (HeadState tx -> (a, HeadState tx)) -> STM m a
[$sel:queryHeadState:NodeState] :: NodeState tx m -> STM m (HeadState tx)

-- | Initialize a new <a>NodeState</a>.
createNodeState :: MonadLabelledSTM m => HeadState tx -> m (NodeState tx m)

-- | Load a <a>HeadState</a> from persistence.
loadState :: (MonadThrow m, IsChainState tx) => Tracer m (HydraNodeLog tx) -> PersistenceIncremental (StateChanged tx) m -> ChainStateType tx -> m (HeadState tx, ChainStateHistory tx)
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Node.ParamMismatch
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Node.ParamMismatch
instance GHC.Show.Show Hydra.Node.ParamMismatch
instance GHC.Classes.Eq Hydra.Node.ParamMismatch
instance GHC.Generics.Generic Hydra.Node.ParamMismatch
instance GHC.Exception.Type.Exception Hydra.Node.ParameterMismatch
instance GHC.Show.Show Hydra.Node.ParameterMismatch
instance GHC.Classes.Eq Hydra.Node.ParameterMismatch
instance GHC.Generics.Generic (Hydra.Node.HydraNodeLog tx)
instance Hydra.Chain.IsChainState tx => GHC.Classes.Eq (Hydra.Node.HydraNodeLog tx)
instance Hydra.Chain.IsChainState tx => GHC.Show.Show (Hydra.Node.HydraNodeLog tx)
instance Hydra.Chain.IsChainState tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.Node.HydraNodeLog tx)
instance Hydra.Chain.IsChainState tx => Data.Aeson.Types.FromJSON.FromJSON (Hydra.Node.HydraNodeLog tx)
instance (Hydra.Ledger.IsTx tx, Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Chain.ChainStateType tx)) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Node.HydraNodeLog tx)
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Node.ParamMismatch


-- | Aggregates all tracing messages in a single type.
--   
--   This module provides a central point where top-level traced messages
--   are grouped. This is useful for traces consumers that will need to do
--   something specific depending on various tracing messages, eg.
--   monitoring and metrics collection.
module Hydra.Logging.Messages
data HydraLog tx net
DirectChain :: DirectChainLog -> HydraLog tx net
[directChain] :: HydraLog tx net -> DirectChainLog
APIServer :: APIServerLog -> HydraLog tx net
[api] :: HydraLog tx net -> APIServerLog
Network :: net -> HydraLog tx net
[network] :: HydraLog tx net -> net
Node :: HydraNodeLog tx -> HydraLog tx net
[node] :: HydraLog tx net -> HydraNodeLog tx
NodeOptions :: RunOptions -> HydraLog tx net
[runOptions] :: HydraLog tx net -> RunOptions
Authentication :: AuthLog -> HydraLog tx net
[authentication] :: HydraLog tx net -> AuthLog
instance GHC.Generics.Generic (Hydra.Logging.Messages.HydraLog tx net)
instance (GHC.Classes.Eq net, GHC.Classes.Eq (Hydra.Node.HydraNodeLog tx)) => GHC.Classes.Eq (Hydra.Logging.Messages.HydraLog tx net)
instance (GHC.Show.Show net, GHC.Show.Show (Hydra.Node.HydraNodeLog tx)) => GHC.Show.Show (Hydra.Logging.Messages.HydraLog tx net)
instance (Data.Aeson.Types.ToJSON.ToJSON net, Data.Aeson.Types.ToJSON.ToJSON (Hydra.Node.HydraNodeLog tx)) => Data.Aeson.Types.ToJSON.ToJSON (Hydra.Logging.Messages.HydraLog tx net)
instance (Data.Aeson.Types.FromJSON.FromJSON net, Data.Aeson.Types.FromJSON.FromJSON (Hydra.Node.HydraNodeLog tx)) => Data.Aeson.Types.FromJSON.FromJSON (Hydra.Logging.Messages.HydraLog tx net)
instance (Test.QuickCheck.Arbitrary.Arbitrary net, Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Node.HydraNodeLog tx)) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Logging.Messages.HydraLog tx net)


-- | Provides Prometheus-based metrics server based on <a>Tracer</a>
--   collection.
--   
--   To add a new metric, one needs to:
--   
--   <ul>
--   <li>Add a <a>MetricDefinition</a> to the <a>allMetrics</a> list,
--   providing a unique <a>Name</a>, the relevant constructor for the
--   <a>Metric</a> value and a registration function,</li>
--   <li>Update the <a>monitor</a> function to Handle relevant
--   <a>HydraLog</a> entries and update underlying Prometheus metrics
--   store. Nested helpers are provided to increase a <tt>Counter</tt> by
--   one (<tt>tick</tt>), by some integral value (<tt>tickN</tt>), and to
--   <a>observe</a> some value in an <tt>Histogram</tt>.</li>
--   </ul>
module Hydra.Logging.Monitoring

-- | Wraps a monadic action using a <a>Tracer</a> and capture metrics based
--   on traces. Given a <tt>portNumber</tt>, this wrapper starts a
--   Prometheus-compliant server on this port. This is a no-op if given
--   <a>Nothing</a>. This function is not polymorphic over the type of
--   messages because it needs to understand them in order to provide
--   meaningful metrics.
withMonitoring :: (MonadIO m, MonadAsync m, IsTx tx, MonadMonotonicTime m) => Maybe PortNumber -> Tracer m (HydraLog tx net) -> (Tracer m (HydraLog tx net) -> m ()) -> m ()
